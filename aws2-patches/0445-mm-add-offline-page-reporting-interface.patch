From bce9e1f0fcac1a4a1d4053adb7820df8000062ea Mon Sep 17 00:00:00 2001
From: Frank van der Linden <fllinden@amazon.com>
Date: Thu, 6 Jan 2022 19:05:17 +0000
Subject: mm: add offline page reporting interface

Add an interface to report offlined pages as free to the hypervisor.

Define a new entry point for page reporting drivers, report_offline.
If a driver sets it, it will be called after a range of memory
has been offlined.

This is done separately, and not with a memory notifier, since with
memmap_on_memory, there are pages that are only freed outside of
offline_pages, where the notifiers are called.

Since this will be called asynchronously (e.g. not from the page
reporting work queues), protect it with the page reporting mutex
so that a driver can't be unloaded while calling the entry point.

Signed-off-by: Frank van der Linden <fllinden@amazon.com>
---
 drivers/base/memory.c          |  5 +++++
 include/linux/page_reporting.h |  4 ++++
 mm/page_reporting.c            | 13 +++++++++++++
 3 files changed, 22 insertions(+)

diff --git a/drivers/base/memory.c b/drivers/base/memory.c
index 486bff952109..770bbd3e9c20 100644
--- a/drivers/base/memory.c
+++ b/drivers/base/memory.c
@@ -19,6 +19,7 @@
 #include <linux/memory.h>
 #include <linux/memory_hotplug.h>
 #include <linux/mm.h>
+#include <linux/page_reporting.h>
 #include <linux/stat.h>
 #include <linux/slab.h>
 #include <linux/xarray.h>
@@ -239,6 +240,10 @@ static int memory_block_offline(struct memory_block *mem)
 	if (nr_vmemmap_pages)
 		mhp_deinit_memmap_on_memory(start_pfn, nr_vmemmap_pages);
 
+#ifdef CONFIG_PAGE_REPORTING
+	page_report_offline(start_pfn, nr_pages);
+#endif
+
 	return ret;
 }
 
diff --git a/include/linux/page_reporting.h b/include/linux/page_reporting.h
index 3b99e0ec24f2..197c1d992836 100644
--- a/include/linux/page_reporting.h
+++ b/include/linux/page_reporting.h
@@ -12,6 +12,8 @@ struct page_reporting_dev_info {
 	/* function that alters pages to make them "reported" */
 	int (*report)(struct page_reporting_dev_info *prdev,
 		      struct scatterlist *sg, unsigned int nents);
+	int (*report_offline)(struct page_reporting_dev_info *prdev,
+			      unsigned long start_pfn, unsigned int nr_pages);
 
 	/* work struct for processing reports */
 	struct delayed_work work;
@@ -20,6 +22,8 @@ struct page_reporting_dev_info {
 	atomic_t state;
 };
 
+void page_report_offline(unsigned long start_pfn, unsigned int nr_pages);
+
 /* Tear-down and bring-up for page reporting devices */
 void page_reporting_unregister(struct page_reporting_dev_info *prdev);
 int page_reporting_register(struct page_reporting_dev_info *prdev);
diff --git a/mm/page_reporting.c b/mm/page_reporting.c
index cd8e13d41df4..c47e07f2bbeb 100644
--- a/mm/page_reporting.c
+++ b/mm/page_reporting.c
@@ -312,6 +312,19 @@ static void page_reporting_process(struct work_struct *work)
 static DEFINE_MUTEX(page_reporting_mutex);
 DEFINE_STATIC_KEY_FALSE(page_reporting_enabled);
 
+void page_report_offline(unsigned long start_pfn, unsigned int nr_pages)
+{
+	struct page_reporting_dev_info *prdev;
+
+	mutex_lock(&page_reporting_mutex);
+
+	prdev = rcu_access_pointer(pr_dev_info);
+	if (prdev && prdev->report_offline)
+		prdev->report_offline(prdev, start_pfn, nr_pages);
+
+	mutex_unlock(&page_reporting_mutex);
+}
+
 int page_reporting_register(struct page_reporting_dev_info *prdev)
 {
 	int err = 0;
-- 
2.32.0

