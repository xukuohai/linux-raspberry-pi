From ab2b02caf2dd9915b1665fb36609e4b6b9170bca Mon Sep 17 00:00:00 2001
From: Anchal Agarwal <anchalag@amazon.com>
Date: Mon, 11 Oct 2021 18:14:05 +0000
Subject: Revert "mm/damon/dbgfs: Implement recording feature"

This reverts commit aa7b879ca35ba55a1e6b6ff8fe7f6742b3b620cd.
---
 mm/damon/dbgfs.c | 261 +----------------------------------------------
 1 file changed, 2 insertions(+), 259 deletions(-)

diff --git a/mm/damon/dbgfs.c b/mm/damon/dbgfs.c
index dce4409e5887..db15380737d1 100644
--- a/mm/damon/dbgfs.c
+++ b/mm/damon/dbgfs.c
@@ -15,17 +15,6 @@
 #include <linux/page_idle.h>
 #include <linux/slab.h>
 
-#define MIN_RECORD_BUFFER_LEN	1024
-#define MAX_RECORD_BUFFER_LEN	(4 * 1024 * 1024)
-#define MAX_RFILE_PATH_LEN	256
-
-struct dbgfs_recorder {
-	unsigned char *rbuf;
-	unsigned int rbuf_len;
-	unsigned int rbuf_offset;
-	char *rfile_path;
-};
-
 static struct damon_ctx **dbgfs_ctxs;
 static int dbgfs_nr_ctxs;
 static struct dentry **dbgfs_dirs;
@@ -108,116 +97,6 @@ static ssize_t dbgfs_attrs_write(struct file *file,
 	return ret;
 }
 
-static ssize_t dbgfs_record_read(struct file *file,
-		char __user *buf, size_t count, loff_t *ppos)
-{
-	struct damon_ctx *ctx = file->private_data;
-	struct dbgfs_recorder *rec = ctx->callback.private;
-	char record_buf[20 + MAX_RFILE_PATH_LEN];
-	int ret;
-
-	mutex_lock(&ctx->kdamond_lock);
-	ret = scnprintf(record_buf, ARRAY_SIZE(record_buf), "%u %s\n",
-			rec->rbuf_len, rec->rfile_path);
-	mutex_unlock(&ctx->kdamond_lock);
-	return simple_read_from_buffer(buf, count, ppos, record_buf, ret);
-}
-
-/*
- * dbgfs_set_recording() - Set attributes for the recording.
- * @ctx:	target kdamond context
- * @rbuf_len:	length of the result buffer
- * @rfile_path:	path to the monitor result files
- *
- * Setting 'rbuf_len' 0 disables recording.
- *
- * This function should not be called while the kdamond is running.
- *
- * Return: 0 on success, negative error code otherwise.
- */
-static int dbgfs_set_recording(struct damon_ctx *ctx,
-			unsigned int rbuf_len, char *rfile_path)
-{
-	struct dbgfs_recorder *recorder;
-	size_t rfile_path_len;
-
-	if (rbuf_len && (rbuf_len > MAX_RECORD_BUFFER_LEN ||
-			rbuf_len < MIN_RECORD_BUFFER_LEN)) {
-		pr_err("result buffer size (%u) is out of [%d,%d]\n",
-				rbuf_len, MIN_RECORD_BUFFER_LEN,
-				MAX_RECORD_BUFFER_LEN);
-		return -EINVAL;
-	}
-	rfile_path_len = strnlen(rfile_path, MAX_RFILE_PATH_LEN);
-	if (rfile_path_len >= MAX_RFILE_PATH_LEN) {
-		pr_err("too long (>%d) result file path %s\n",
-				MAX_RFILE_PATH_LEN, rfile_path);
-		return -EINVAL;
-	}
-
-	recorder = ctx->callback.private;
-	if (!recorder) {
-		recorder = kzalloc(sizeof(*recorder), GFP_KERNEL);
-		if (!recorder)
-			return -ENOMEM;
-		ctx->callback.private = recorder;
-	}
-
-	recorder->rbuf_len = rbuf_len;
-	kfree(recorder->rbuf);
-	recorder->rbuf = NULL;
-	kfree(recorder->rfile_path);
-	recorder->rfile_path = NULL;
-
-	if (rbuf_len) {
-		recorder->rbuf = kvmalloc(rbuf_len, GFP_KERNEL);
-		if (!recorder->rbuf)
-			return -ENOMEM;
-	}
-	recorder->rfile_path = kmalloc(rfile_path_len + 1, GFP_KERNEL);
-	if (!recorder->rfile_path)
-		return -ENOMEM;
-	strncpy(recorder->rfile_path, rfile_path, rfile_path_len + 1);
-
-	return 0;
-}
-
-static ssize_t dbgfs_record_write(struct file *file,
-		const char __user *buf, size_t count, loff_t *ppos)
-{
-	struct damon_ctx *ctx = file->private_data;
-	char *kbuf;
-	unsigned int rbuf_len;
-	char rfile_path[MAX_RFILE_PATH_LEN];
-	ssize_t ret = count;
-	int err;
-
-	kbuf = user_input_str(buf, count, ppos);
-	if (IS_ERR(kbuf))
-		return PTR_ERR(kbuf);
-
-	if (sscanf(kbuf, "%u %s",
-				&rbuf_len, rfile_path) != 2) {
-		ret = -EINVAL;
-		goto out;
-	}
-
-	mutex_lock(&ctx->kdamond_lock);
-	if (ctx->kdamond) {
-		ret = -EBUSY;
-		goto unlock_out;
-	}
-
-	err = dbgfs_set_recording(ctx, rbuf_len, rfile_path);
-	if (err)
-		ret = err;
-unlock_out:
-	mutex_unlock(&ctx->kdamond_lock);
-out:
-	kfree(kbuf);
-	return ret;
-}
-
 #define targetid_is_pid(ctx)	\
 	(ctx->primitive.target_valid == damon_va_target_valid)
 
@@ -372,13 +251,6 @@ static const struct file_operations attrs_fops = {
 	.write = dbgfs_attrs_write,
 };
 
-static const struct file_operations record_fops = {
-	.owner = THIS_MODULE,
-	.open = damon_dbgfs_open,
-	.read = dbgfs_record_read,
-	.write = dbgfs_record_write,
-};
-
 static const struct file_operations target_ids_fops = {
 	.owner = THIS_MODULE,
 	.open = damon_dbgfs_open,
@@ -388,9 +260,8 @@ static const struct file_operations target_ids_fops = {
 
 static int dbgfs_fill_ctx_dir(struct dentry *dir, struct damon_ctx *ctx)
 {
-	const char * const file_names[] = {"attrs", "record", "target_ids"};
-	const struct file_operations *fops[] = {&attrs_fops, &record_fops,
-		&target_ids_fops};
+	const char * const file_names[] = {"attrs", "target_ids"};
+	const struct file_operations *fops[] = {&attrs_fops, &target_ids_fops};
 	int i;
 
 	for (i = 0; i < ARRAY_SIZE(file_names); i++) {
@@ -404,126 +275,6 @@ static int dbgfs_fill_ctx_dir(struct dentry *dir, struct damon_ctx *ctx)
 	return 0;
 }
 
-/*
- * Flush the content in the result buffer to the result file
- */
-static void dbgfs_flush_rbuffer(struct dbgfs_recorder *rec)
-{
-	ssize_t sz;
-	loff_t pos = 0;
-	struct file *rfile;
-
-	if (!rec->rbuf_offset)
-		return;
-
-	rfile = filp_open(rec->rfile_path,
-			O_CREAT | O_RDWR | O_APPEND | O_LARGEFILE, 0644);
-	if (IS_ERR(rfile)) {
-		pr_err("Cannot open the result file %s\n",
-				rec->rfile_path);
-		return;
-	}
-
-	while (rec->rbuf_offset) {
-		sz = kernel_write(rfile, rec->rbuf, rec->rbuf_offset, &pos);
-		if (sz < 0)
-			break;
-		rec->rbuf_offset -= sz;
-	}
-	filp_close(rfile, NULL);
-}
-
-/*
- * Write a data into the result buffer
- */
-static void dbgfs_write_rbuf(struct damon_ctx *ctx, void *data, ssize_t size)
-{
-	struct dbgfs_recorder *rec = ctx->callback.private;
-
-	if (!rec->rbuf_len || !rec->rbuf || !rec->rfile_path)
-		return;
-	if (rec->rbuf_offset + size > rec->rbuf_len)
-		dbgfs_flush_rbuffer(ctx->callback.private);
-	if (rec->rbuf_offset + size > rec->rbuf_len) {
-		pr_warn("%s: flush failed, or wrong size given(%u, %zu)\n",
-				__func__, rec->rbuf_offset, size);
-		return;
-	}
-
-	memcpy(&rec->rbuf[rec->rbuf_offset], data, size);
-	rec->rbuf_offset += size;
-}
-
-static void dbgfs_write_record_header(struct damon_ctx *ctx)
-{
-	int recfmt_ver = 2;
-
-	dbgfs_write_rbuf(ctx, "damon_recfmt_ver", 16);
-	dbgfs_write_rbuf(ctx, &recfmt_ver, sizeof(recfmt_ver));
-}
-
-static unsigned int nr_damon_targets(struct damon_ctx *ctx)
-{
-	struct damon_target *t;
-	unsigned int nr_targets = 0;
-
-	damon_for_each_target(t, ctx)
-		nr_targets++;
-
-	return nr_targets;
-}
-
-static int dbgfs_before_start(struct damon_ctx *ctx)
-{
-	dbgfs_write_record_header(ctx);
-	return 0;
-}
-
-/*
- * Store the aggregated monitoring results to the result buffer
- *
- * The format for the result buffer is as below:
- *
- *   <time> <number of targets> <array of target infos>
- *
- *   target info: <id> <number of regions> <array of region infos>
- *   region info: <start address> <end address> <nr_accesses>
- */
-static int dbgfs_after_aggregation(struct damon_ctx *c)
-{
-	struct damon_target *t;
-	struct timespec64 now;
-	unsigned int nr;
-
-	ktime_get_coarse_ts64(&now);
-
-	dbgfs_write_rbuf(c, &now, sizeof(now));
-	nr = nr_damon_targets(c);
-	dbgfs_write_rbuf(c, &nr, sizeof(nr));
-
-	damon_for_each_target(t, c) {
-		struct damon_region *r;
-
-		dbgfs_write_rbuf(c, &t->id, sizeof(t->id));
-		nr = damon_nr_regions(t);
-		dbgfs_write_rbuf(c, &nr, sizeof(nr));
-		damon_for_each_region(r, t) {
-			dbgfs_write_rbuf(c, &r->ar.start, sizeof(r->ar.start));
-			dbgfs_write_rbuf(c, &r->ar.end, sizeof(r->ar.end));
-			dbgfs_write_rbuf(c, &r->nr_accesses,
-					sizeof(r->nr_accesses));
-		}
-	}
-
-	return 0;
-}
-
-static int dbgfs_before_terminate(struct damon_ctx *ctx)
-{
-	dbgfs_flush_rbuffer(ctx->callback.private);
-	return 0;
-}
-
 static struct damon_ctx *dbgfs_new_ctx(void)
 {
 	struct damon_ctx *ctx;
@@ -532,15 +283,7 @@ static struct damon_ctx *dbgfs_new_ctx(void)
 	if (!ctx)
 		return NULL;
 
-	if (dbgfs_set_recording(ctx, 0, "none")) {
-		damon_destroy_ctx(ctx);
-		return NULL;
-	}
-
 	damon_va_set_primitives(ctx);
-	ctx->callback.before_start = dbgfs_before_start;
-	ctx->callback.after_aggregation = dbgfs_after_aggregation;
-	ctx->callback.before_terminate = dbgfs_before_terminate;
 	return ctx;
 }
 
-- 
2.32.0

