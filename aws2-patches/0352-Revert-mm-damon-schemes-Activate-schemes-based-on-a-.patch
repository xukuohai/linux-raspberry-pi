From a8a695586f5ba602aab58bffaf01752f47635566 Mon Sep 17 00:00:00 2001
From: SeongJae Park <sjpark@amazon.de>
Date: Tue, 23 Nov 2021 14:01:46 +0000
Subject: Revert "mm/damon/schemes: Activate schemes based on a watermarks
 mechanism"

This reverts commit 4b02b90f1ba35c218f2a719ca0ab1eaaacba44f7.
---
 include/linux/damon.h | 52 +----------------------
 mm/damon/core.c       | 97 +------------------------------------------
 mm/damon/dbgfs.c      |  5 +--
 3 files changed, 3 insertions(+), 151 deletions(-)

diff --git a/include/linux/damon.h b/include/linux/damon.h
index 08b83539a7d5..940e98248e3e 100644
--- a/include/linux/damon.h
+++ b/include/linux/damon.h
@@ -146,45 +146,6 @@ struct damos_quota {
 	unsigned int min_score;
 };
 
-/**
- * enum damos_wmark_metric - Represents the watermark metric.
- *
- * @DAMOS_WMARK_NONE:		Ignore the watermarks of the given scheme.
- * @DAMOS_WMARK_FREE_MEM_RATE:	Free memory rate of the system in [0,1000].
- */
-enum damos_wmark_metric {
-	DAMOS_WMARK_NONE,
-	DAMOS_WMARK_FREE_MEM_RATE,
-};
-
-/**
- * struct damos_watermarks - Controls when a given scheme should be activated.
- * @metric:	Metric for the watermarks.
- * @interval:	Watermarks check time interval in microseconds.
- * @high:	High watermark.
- * @mid:	Middle watermark.
- * @low:	Low watermark.
- *
- * If &metric is &DAMOS_WMARK_NONE, the scheme is always active.  Being active
- * means DAMON does monitoring and applying the action of the scheme to
- * appropriate memory regions.  Else, DAMON checks &metric of the system for at
- * least every &interval microseconds and works as below.
- *
- * If &metric is higher than &high, the scheme is inactivated.  If &metric is
- * between &mid and &low, the scheme is activated.  If &metric is lower than
- * &low, the scheme is inactivated.
- */
-struct damos_watermarks {
-	enum damos_wmark_metric metric;
-	unsigned long interval;
-	unsigned long high;
-	unsigned long mid;
-	unsigned long low;
-
-/* private: */
-	bool activated;
-};
-
 /**
  * struct damos - Represents a Data Access Monitoring-based Operation Scheme.
  * @min_sz_region:	Minimum size of target regions.
@@ -195,7 +156,6 @@ struct damos_watermarks {
  * @max_age_region:	Maximum age of target regions.
  * @action:		&damo_action to be applied to the target regions.
  * @quota:		Control the aggressiveness of this scheme.
- * @wmarks:		Watermarks for automated (in)activation of this scheme.
  * @stat_count:		Total number of regions that this scheme is applied.
  * @stat_sz:		Total size of regions that this scheme is applied.
  * @list:		List head for siblings.
@@ -206,14 +166,6 @@ struct damos_watermarks {
  * those.  To avoid consuming too much CPU time or IO resources for the
  * &action, &quota is used.
  *
- * To do the work only when needed, schemes can be activated for specific
- * system situations using &wmarks.  If all schemes that registered to the
- * monitoring context are inactive, DAMON stops monitoring either, and just
- * repeatedly checks the watermarks.
- *
- * If all schemes that registered to a &struct damon_ctx are inactive, DAMON
- * stops monitoring and just repeatedly checks the watermarks.
- *
  * After applying the &action to each region, &stat_count and &stat_sz is
  * updated to reflect the number of regions and total size of regions that the
  * &action is applied.
@@ -227,7 +179,6 @@ struct damos {
 	unsigned int max_age_region;
 	enum damos_action action;
 	struct damos_quota quota;
-	struct damos_watermarks wmarks;
 	unsigned long stat_count;
 	unsigned long stat_sz;
 	struct list_head list;
@@ -461,8 +412,7 @@ struct damos *damon_new_scheme(
 		unsigned long min_sz_region, unsigned long max_sz_region,
 		unsigned int min_nr_accesses, unsigned int max_nr_accesses,
 		unsigned int min_age_region, unsigned int max_age_region,
-		enum damos_action action, struct damos_quota *quota,
-		struct damos_watermarks *wmarks);
+		enum damos_action action, struct damos_quota *quota);
 void damon_add_scheme(struct damon_ctx *ctx, struct damos *s);
 void damon_destroy_scheme(struct damos *s);
 
diff --git a/mm/damon/core.c b/mm/damon/core.c
index 54f9ea6f96bb..be6bbe685597 100644
--- a/mm/damon/core.c
+++ b/mm/damon/core.c
@@ -10,7 +10,6 @@
 #include <linux/damon.h>
 #include <linux/delay.h>
 #include <linux/kthread.h>
-#include <linux/mm.h>
 #include <linux/random.h>
 #include <linux/slab.h>
 #include <linux/string.h>
@@ -86,8 +85,7 @@ struct damos *damon_new_scheme(
 		unsigned long min_sz_region, unsigned long max_sz_region,
 		unsigned int min_nr_accesses, unsigned int max_nr_accesses,
 		unsigned int min_age_region, unsigned int max_age_region,
-		enum damos_action action, struct damos_quota *quota,
-		struct damos_watermarks *wmarks)
+		enum damos_action action, struct damos_quota *quota)
 {
 	struct damos *scheme;
 
@@ -119,13 +117,6 @@ struct damos *damon_new_scheme(
 	scheme->quota.charge_target_from = NULL;
 	scheme->quota.charge_addr_from = 0;
 
-	scheme->wmarks.metric = wmarks->metric;
-	scheme->wmarks.interval = wmarks->interval;
-	scheme->wmarks.high = wmarks->high;
-	scheme->wmarks.mid = wmarks->mid;
-	scheme->wmarks.low = wmarks->low;
-	scheme->wmarks.activated = true;
-
 	return scheme;
 }
 
@@ -591,9 +582,6 @@ static void damon_do_apply_schemes(struct damon_ctx *c,
 		unsigned long sz = r->ar.end - r->ar.start;
 		struct timespec64 begin, end;
 
-		if (!s->wmarks.activated)
-			continue;
-
 		/* Check the quota */
 		if (quota->esz && quota->charged_sz >= quota->esz)
 			continue;
@@ -696,9 +684,6 @@ static void kdamond_apply_schemes(struct damon_ctx *c)
 		unsigned long cumulated_sz;
 		unsigned int score, max_score = 0;
 
-		if (!s->wmarks.activated)
-			continue;
-
 		if (!quota->ms && !quota->sz)
 			continue;
 
@@ -942,83 +927,6 @@ static bool kdamond_need_stop(struct damon_ctx *ctx)
 	return true;
 }
 
-static unsigned long damos_wmark_metric_value(enum damos_wmark_metric metric)
-{
-	struct sysinfo i;
-
-	switch (metric) {
-	case DAMOS_WMARK_FREE_MEM_RATE:
-		si_meminfo(&i);
-		return i.freeram * 1000 / i.totalram;
-	default:
-		break;
-	}
-	return -EINVAL;
-}
-
-/*
- * Returns zero if the scheme is active.  Else, returns time to wait for next
- * watermark check in micro-seconds.
- */
-static unsigned long damos_wmark_wait_us(struct damos *scheme)
-{
-	unsigned long metric;
-
-	if (scheme->wmarks.metric == DAMOS_WMARK_NONE)
-		return 0;
-
-	metric = damos_wmark_metric_value(scheme->wmarks.metric);
-	/* higher than high watermark or lower than low watermark */
-	if (metric > scheme->wmarks.high || scheme->wmarks.low > metric) {
-		if (scheme->wmarks.activated)
-			pr_info("inactivate a scheme (%d) for %s wmark\n",
-					scheme->action,
-					metric > scheme->wmarks.high ?
-					"high" : "low");
-		scheme->wmarks.activated = false;
-		return scheme->wmarks.interval;
-	}
-
-	/* inactive and higher than middle watermark */
-	if ((scheme->wmarks.high >= metric && metric >= scheme->wmarks.mid) &&
-			!scheme->wmarks.activated)
-		return scheme->wmarks.interval;
-
-	if (!scheme->wmarks.activated)
-		pr_info("activate a scheme (%d)\n", scheme->action);
-	scheme->wmarks.activated = true;
-	return 0;
-}
-
-static void kdamond_usleep(unsigned long usecs)
-{
-	if (usecs > 100 * 1000)
-		schedule_timeout_interruptible(usecs_to_jiffies(usecs));
-	else
-		usleep_range(usecs, usecs + 1);
-}
-
-/* Returns negative error code if it's not activated but should return */
-static int kdamond_wait_activation(struct damon_ctx *ctx)
-{
-	struct damos *s;
-	unsigned long wait_time;
-	unsigned long min_wait_time = 0;
-
-	while (!kdamond_need_stop(ctx)) {
-		damon_for_each_scheme(s, ctx) {
-			wait_time = damos_wmark_wait_us(s);
-			if (!min_wait_time || wait_time < min_wait_time)
-				min_wait_time = wait_time;
-		}
-		if (!min_wait_time)
-			return 0;
-
-		kdamond_usleep(min_wait_time);
-	}
-	return -EBUSY;
-}
-
 static void set_kdamond_stop(struct damon_ctx *ctx)
 {
 	mutex_lock(&ctx->kdamond_lock);
@@ -1047,9 +955,6 @@ static int kdamond_fn(void *data)
 	sz_limit = damon_region_sz_limit(ctx);
 
 	while (!kdamond_need_stop(ctx)) {
-		if (kdamond_wait_activation(ctx))
-			continue;
-
 		if (ctx->primitive.prepare_access_checks)
 			ctx->primitive.prepare_access_checks(ctx);
 		if (ctx->callback.after_sampling &&
diff --git a/mm/damon/dbgfs.c b/mm/damon/dbgfs.c
index a065f09fc5ae..b03ff44a4787 100644
--- a/mm/damon/dbgfs.c
+++ b/mm/damon/dbgfs.c
@@ -317,9 +317,6 @@ static struct damos **str_to_schemes(const char *str, ssize_t len,
 	*nr_schemes = 0;
 	while (pos < len && *nr_schemes < max_nr_schemes) {
 		struct damos_quota quota = {};
-		struct damos_watermarks wmarks = {
-			.metric = DAMOS_WMARK_NONE,
-		};
 
 		ret = sscanf(&str[pos],
 				"%lu %lu %u %u %u %u %u %lu %lu %lu %u %u %u%n",
@@ -337,7 +334,7 @@ static struct damos **str_to_schemes(const char *str, ssize_t len,
 
 		pos += parsed;
 		scheme = damon_new_scheme(min_sz, max_sz, min_nr_a, max_nr_a,
-				min_age, max_age, action, &quota, &wmarks);
+				min_age, max_age, action, &quota);
 		if (!scheme)
 			goto fail;
 
-- 
2.32.0

