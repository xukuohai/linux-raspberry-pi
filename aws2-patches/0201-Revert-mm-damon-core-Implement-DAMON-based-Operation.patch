From 059701e40506f8417b47c551e21c4168ee05fb41 Mon Sep 17 00:00:00 2001
From: Anchal Agarwal <anchalag@amazon.com>
Date: Mon, 11 Oct 2021 18:13:57 +0000
Subject: Revert "mm/damon/core: Implement DAMON-based Operation Schemes
 (DAMOS)"

This reverts commit 765ceca9d4b9b6eaa605483887b3801eedaaa406.
---
 include/linux/damon.h |  66 -------------------------
 mm/damon/core.c       | 109 ------------------------------------------
 2 files changed, 175 deletions(-)

diff --git a/include/linux/damon.h b/include/linux/damon.h
index b70d893d073e..aade1fbedb48 100644
--- a/include/linux/damon.h
+++ b/include/linux/damon.h
@@ -67,48 +67,6 @@ struct damon_target {
 	struct list_head list;
 };
 
-/**
- * enum damos_action - Represents an action of a Data Access Monitoring-based
- * Operation Scheme.
- *
- * @DAMOS_WILLNEED:	Call ``madvise()`` for the region with MADV_WILLNEED.
- * @DAMOS_COLD:		Call ``madvise()`` for the region with MADV_COLD.
- * @DAMOS_PAGEOUT:	Call ``madvise()`` for the region with MADV_PAGEOUT.
- * @DAMOS_HUGEPAGE:	Call ``madvise()`` for the region with MADV_HUGEPAGE.
- * @DAMOS_NOHUGEPAGE:	Call ``madvise()`` for the region with MADV_NOHUGEPAGE.
- */
-enum damos_action {
-	DAMOS_WILLNEED,
-	DAMOS_COLD,
-	DAMOS_PAGEOUT,
-	DAMOS_HUGEPAGE,
-	DAMOS_NOHUGEPAGE,
-};
-
-/**
- * struct damos - Represents a Data Access Monitoring-based Operation Scheme.
- * @min_sz_region:	Minimum size of target regions.
- * @max_sz_region:	Maximum size of target regions.
- * @min_nr_accesses:	Minimum ``->nr_accesses`` of target regions.
- * @max_nr_accesses:	Maximum ``->nr_accesses`` of target regions.
- * @min_age_region:	Minimum age of target regions.
- * @max_age_region:	Maximum age of target regions.
- * @action:		&damo_action to be applied to the target regions.
- * @list:		List head for siblings.
- *
- * Note that both the minimums and the maximums are inclusive.
- */
-struct damos {
-	unsigned long min_sz_region;
-	unsigned long max_sz_region;
-	unsigned int min_nr_accesses;
-	unsigned int max_nr_accesses;
-	unsigned int min_age_region;
-	unsigned int max_age_region;
-	enum damos_action action;
-	struct list_head list;
-};
-
 struct damon_ctx;
 
 /**
@@ -119,7 +77,6 @@ struct damon_ctx;
  * @prepare_access_checks:	Prepare next access check of target regions.
  * @check_accesses:		Check the accesses to target regions.
  * @reset_aggregated:		Reset aggregated accesses monitoring results.
- * @apply_scheme:		Apply a DAMON-based operation scheme.
  * @target_valid:		Determine if the target is valid.
  * @cleanup:			Clean up the context.
  *
@@ -145,9 +102,6 @@ struct damon_ctx;
  * of its update.  The value will be used for regions adjustment threshold.
  * @reset_aggregated should reset the access monitoring results that aggregated
  * by @check_accesses.
- * @apply_scheme is called from @kdamond when a region for user provided
- * DAMON-based operation scheme is found.  It should apply the scheme's action
- * to the region.  This is not used for &DAMON_ARBITRARY_TARGET case.
  * @target_valid should check whether the target is still valid for the
  * monitoring.
  * @cleanup is called from @kdamond just before its termination.
@@ -158,8 +112,6 @@ struct damon_primitive {
 	void (*prepare_access_checks)(struct damon_ctx *context);
 	unsigned int (*check_accesses)(struct damon_ctx *context);
 	void (*reset_aggregated)(struct damon_ctx *context);
-	int (*apply_scheme)(struct damon_ctx *context, struct damon_target *t,
-			struct damon_region *r, struct damos *scheme);
 	bool (*target_valid)(void *target);
 	void (*cleanup)(struct damon_ctx *context);
 };
@@ -238,7 +190,6 @@ struct damon_callback {
  * @min_nr_regions:	The minimum number of adaptive monitoring regions.
  * @max_nr_regions:	The maximum number of adaptive monitoring regions.
  * @adaptive_targets:	Head of monitoring targets (&damon_target) list.
- * @schemes:		Head of schemes (&damos) list.
  */
 struct damon_ctx {
 	unsigned long sample_interval;
@@ -260,7 +211,6 @@ struct damon_ctx {
 	unsigned long min_nr_regions;
 	unsigned long max_nr_regions;
 	struct list_head adaptive_targets;
-	struct list_head schemes;
 };
 
 #define damon_next_region(r) \
@@ -281,12 +231,6 @@ struct damon_ctx {
 #define damon_for_each_target_safe(t, next, ctx)	\
 	list_for_each_entry_safe(t, next, &(ctx)->adaptive_targets, list)
 
-#define damon_for_each_scheme(s, ctx) \
-	list_for_each_entry(s, &(ctx)->schemes, list)
-
-#define damon_for_each_scheme_safe(s, next, ctx) \
-	list_for_each_entry_safe(s, next, &(ctx)->schemes, list)
-
 #ifdef CONFIG_DAMON
 
 struct damon_region *damon_new_region(unsigned long start, unsigned long end);
@@ -295,14 +239,6 @@ inline void damon_insert_region(struct damon_region *r,
 void damon_add_region(struct damon_region *r, struct damon_target *t);
 void damon_destroy_region(struct damon_region *r);
 
-struct damos *damon_new_scheme(
-		unsigned long min_sz_region, unsigned long max_sz_region,
-		unsigned int min_nr_accesses, unsigned int max_nr_accesses,
-		unsigned int min_age_region, unsigned int max_age_region,
-		enum damos_action action);
-void damon_add_scheme(struct damon_ctx *ctx, struct damos *s);
-void damon_destroy_scheme(struct damos *s);
-
 struct damon_target *damon_new_target(unsigned long id);
 void damon_add_target(struct damon_ctx *ctx, struct damon_target *t);
 void damon_free_target(struct damon_target *t);
@@ -316,8 +252,6 @@ int damon_set_targets(struct damon_ctx *ctx,
 int damon_set_attrs(struct damon_ctx *ctx, unsigned long sample_int,
 		unsigned long aggr_int, unsigned long primitive_upd_int,
 		unsigned long min_nr_reg, unsigned long max_nr_reg);
-int damon_set_schemes(struct damon_ctx *ctx,
-			struct damos **schemes, ssize_t nr_schemes);
 int damon_nr_running_ctxs(void);
 
 int damon_start(struct damon_ctx **ctxs, int nr_ctxs);
diff --git a/mm/damon/core.c b/mm/damon/core.c
index 7a294afd624d..00aae299e80d 100644
--- a/mm/damon/core.c
+++ b/mm/damon/core.c
@@ -76,50 +76,6 @@ void damon_destroy_region(struct damon_region *r)
 	damon_free_region(r);
 }
 
-struct damos *damon_new_scheme(
-		unsigned long min_sz_region, unsigned long max_sz_region,
-		unsigned int min_nr_accesses, unsigned int max_nr_accesses,
-		unsigned int min_age_region, unsigned int max_age_region,
-		enum damos_action action)
-{
-	struct damos *scheme;
-
-	scheme = kmalloc(sizeof(*scheme), GFP_KERNEL);
-	if (!scheme)
-		return NULL;
-	scheme->min_sz_region = min_sz_region;
-	scheme->max_sz_region = max_sz_region;
-	scheme->min_nr_accesses = min_nr_accesses;
-	scheme->max_nr_accesses = max_nr_accesses;
-	scheme->min_age_region = min_age_region;
-	scheme->max_age_region = max_age_region;
-	scheme->action = action;
-	INIT_LIST_HEAD(&scheme->list);
-
-	return scheme;
-}
-
-void damon_add_scheme(struct damon_ctx *ctx, struct damos *s)
-{
-	list_add_tail(&s->list, &ctx->schemes);
-}
-
-static void damon_del_scheme(struct damos *s)
-{
-	list_del(&s->list);
-}
-
-static void damon_free_scheme(struct damos *s)
-{
-	kfree(s);
-}
-
-void damon_destroy_scheme(struct damos *s)
-{
-	damon_del_scheme(s);
-	damon_free_scheme(s);
-}
-
 /*
  * Construct a damon_target struct
  *
@@ -196,7 +152,6 @@ struct damon_ctx *damon_new_ctx(void)
 	ctx->max_nr_regions = 1000;
 
 	INIT_LIST_HEAD(&ctx->adaptive_targets);
-	INIT_LIST_HEAD(&ctx->schemes);
 
 	return ctx;
 }
@@ -216,13 +171,7 @@ static void damon_destroy_targets(struct damon_ctx *ctx)
 
 void damon_destroy_ctx(struct damon_ctx *ctx)
 {
-	struct damos *s, *next_s;
-
 	damon_destroy_targets(ctx);
-
-	damon_for_each_scheme_safe(s, next_s, ctx)
-		damon_destroy_scheme(s);
-
 	kfree(ctx);
 }
 
@@ -297,30 +246,6 @@ int damon_set_attrs(struct damon_ctx *ctx, unsigned long sample_int,
 	return 0;
 }
 
-/**
- * damon_set_schemes() - Set data access monitoring based operation schemes.
- * @ctx:	monitoring context
- * @schemes:	array of the schemes
- * @nr_schemes:	number of entries in @schemes
- *
- * This function should not be called while the kdamond of the context is
- * running.
- *
- * Return: 0 if success, or negative error code otherwise.
- */
-int damon_set_schemes(struct damon_ctx *ctx, struct damos **schemes,
-			ssize_t nr_schemes)
-{
-	struct damos *s, *next;
-	ssize_t i;
-
-	damon_for_each_scheme_safe(s, next, ctx)
-		damon_destroy_scheme(s);
-	for (i = 0; i < nr_schemes; i++)
-		damon_add_scheme(ctx, schemes[i]);
-	return 0;
-}
-
 /**
  * damon_nr_running_ctxs() - Return number of currently running contexts.
  */
@@ -524,39 +449,6 @@ static void kdamond_reset_aggregated(struct damon_ctx *c)
 	}
 }
 
-static void damon_do_apply_schemes(struct damon_ctx *c,
-				   struct damon_target *t,
-				   struct damon_region *r)
-{
-	struct damos *s;
-	unsigned long sz;
-
-	damon_for_each_scheme(s, c) {
-		sz = r->ar.end - r->ar.start;
-		if (sz < s->min_sz_region || s->max_sz_region < sz)
-			continue;
-		if (r->nr_accesses < s->min_nr_accesses ||
-				s->max_nr_accesses < r->nr_accesses)
-			continue;
-		if (r->age < s->min_age_region || s->max_age_region < r->age)
-			continue;
-		if (c->primitive.apply_scheme)
-			c->primitive.apply_scheme(c, t, r, s);
-		r->age = 0;
-	}
-}
-
-static void kdamond_apply_schemes(struct damon_ctx *c)
-{
-	struct damon_target *t;
-	struct damon_region *r;
-
-	damon_for_each_target(t, c) {
-		damon_for_each_region(r, t)
-			damon_do_apply_schemes(c, t, r);
-	}
-}
-
 #define sz_damon_region(r) (r->ar.end - r->ar.start)
 
 /*
@@ -796,7 +688,6 @@ static int kdamond_fn(void *data)
 			if (ctx->callback.after_aggregation &&
 					ctx->callback.after_aggregation(ctx))
 				set_kdamond_stop(ctx);
-			kdamond_apply_schemes(ctx);
 			kdamond_reset_aggregated(ctx);
 			kdamond_split_regions(ctx);
 			if (ctx->primitive.reset_aggregated)
-- 
2.32.0

