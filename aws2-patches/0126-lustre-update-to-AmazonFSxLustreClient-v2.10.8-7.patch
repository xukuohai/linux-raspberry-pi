From 8310d921111af7e8ba71179601340f76c16bf0fe Mon Sep 17 00:00:00 2001
From: Shaoying Xu <shaoyi@amazon.com>
Date: Mon, 26 Apr 2021 21:18:28 +0000
Subject: lustre: update to AmazonFSxLustreClient v2.10.8-7

Signed-off-by: Shaoying Xu <shaoyi@amazon.com>
---
 drivers/staging/lustrefsx/config.h            |  65 +++--
 .../lustrefsx/libcfs/include/libcfs/libcfs.h  |   3 +
 .../libcfs/include/libcfs/libcfs_private.h    |   5 +-
 .../include/libcfs/linux/linux-crypto.h       |   5 +
 .../libcfs/include/libcfs/linux/linux-fs.h    |  18 ++
 .../libcfs/include/libcfs/linux/linux-mem.h   |  38 +++
 .../libcfs/include/libcfs/linux/linux-misc.h  |   4 +
 .../libcfs/include/libcfs/linux/linux-net.h   |  72 +++++
 .../libcfs/include/libcfs/linux/linux-time.h  |  33 +--
 .../lustrefsx/libcfs/libcfs/libcfs_mem.c      |  60 +++++
 .../libcfs/libcfs/linux/linux-crypto-adler.c  |   3 +-
 .../libcfs/libcfs/linux/linux-crypto-crc32.c  |   4 +-
 .../libcfs/linux/linux-crypto-crc32c-pclmul.c |   4 +-
 .../libcfs/linux/linux-crypto-crc32pclmul.c   |   3 +-
 .../libcfs/libcfs/linux/linux-curproc.c       |   4 +-
 .../libcfs/libcfs/linux/linux-prim.c          |  12 +
 .../staging/lustrefsx/libcfs/libcfs/module.c  |   3 +-
 .../lustrefsx/libcfs/libcfs/tracefile.c       |  12 +
 .../lustrefsx/lnet/include/lnet/lib-lnet.h    |  26 +-
 .../lustrefsx/lnet/klnds/o2iblnd/o2iblnd.c    | 189 ++++++-------
 .../lustrefsx/lnet/klnds/o2iblnd/o2iblnd.h    |  10 +-
 .../lustrefsx/lnet/klnds/o2iblnd/o2iblnd_cb.c |   6 +-
 .../lustrefsx/lnet/klnds/socklnd/socklnd.c    | 158 ++++-------
 .../lustrefsx/lnet/klnds/socklnd/socklnd.h    |   2 +
 .../lnet/klnds/socklnd/socklnd_lib.c          | 251 ++++++++----------
 drivers/staging/lustrefsx/lnet/lnet/config.c  | 177 ++++++------
 .../staging/lustrefsx/lnet/lnet/lib-socket.c  | 239 +++--------------
 .../staging/lustrefsx/lnet/lnet/router_proc.c |  19 ++
 .../staging/lustrefsx/lnet/selftest/conctl.c  |   1 -
 .../staging/lustrefsx/lnet/selftest/conrpc.c  |   6 +-
 .../staging/lustrefsx/lnet/selftest/conrpc.h  |   1 -
 .../staging/lustrefsx/lnet/selftest/console.h |   1 -
 .../lustrefsx/lustre/fid/fid_handler.c        |   2 +-
 .../staging/lustrefsx/lustre/fid/lproc_fid.c  |  11 +-
 .../lustrefsx/lustre/fld/fld_internal.h       |   2 +-
 .../staging/lustrefsx/lustre/fld/lproc_fld.c  |   7 +-
 .../lustrefsx/lustre/include/lprocfs_status.h |  41 ++-
 .../lustre/include/lustre/ll_fiemap.h         |   2 -
 .../staging/lustrefsx/lustre/include/lvfs.h   |   1 -
 .../lustrefsx/lustre/include/obd_support.h    |   4 +-
 .../lustrefsx/lustre/ldlm/ldlm_resource.c     |  24 +-
 .../lustrefsx/lustre/llite/llite_mmap.c       |  27 +-
 drivers/staging/lustrefsx/lustre/llite/rw26.c |   4 +-
 .../staging/lustrefsx/lustre/llite/vvp_dev.c  |   1 +
 .../staging/lustrefsx/lustre/llite/vvp_io.c   |  48 ++--
 .../staging/lustrefsx/lustre/llite/xattr.c    |  17 +-
 .../lustrefsx/lustre/lmv/lmv_internal.h       |   2 +-
 .../staging/lustrefsx/lustre/lmv/lproc_lmv.c  |  11 +-
 .../lustrefsx/lustre/lov/lov_internal.h       |   2 +-
 .../staging/lustrefsx/lustre/lov/lov_pool.c   |   9 +-
 .../staging/lustrefsx/lustre/lov/lproc_lov.c  |  11 +-
 .../lustre/obdclass/lprocfs_jobstats.c        |  11 +-
 .../lustre/obdclass/lprocfs_status.c          |  56 ++--
 .../lustrefsx/lustre/obdclass/lu_ref.c        |  11 +-
 .../lustrefsx/lustre/obdclass/obd_config.c    |   5 +-
 .../lustrefsx/lustre/ptlrpc/lproc_ptlrpc.c    |   9 +-
 .../staging/lustrefsx/lustre/ptlrpc/sec_ctx.c |   9 -
 drivers/staging/lustrefsx/undef.h             |  36 ++-
 58 files changed, 910 insertions(+), 887 deletions(-)
 create mode 100644 drivers/staging/lustrefsx/libcfs/include/libcfs/linux/linux-net.h

diff --git a/drivers/staging/lustrefsx/config.h b/drivers/staging/lustrefsx/config.h
index 0d000a1f58fb..2ecd0c99d380 100644
--- a/drivers/staging/lustrefsx/config.h
+++ b/drivers/staging/lustrefsx/config.h
@@ -116,7 +116,7 @@
 /* #undef HAVE_CANCEL_DIRTY_PAGE */
 
 /* kernel has clean_bdev_aliases */
-#define HAVE_CLEAN_BDEV_ALIASES 1
+/* #undef HAVE_CLEAN_BDEV_ALIASES */
 
 /* have clear_inode */
 #define HAVE_CLEAR_INODE 1
@@ -292,8 +292,11 @@
 /* filldir_t needs struct dir_context as argument */
 #define HAVE_FILLDIR_USE_CTX 1
 
+/* FMR pool API is available */
+/* #undef HAVE_FMR_POOL_API */
+
 /* fpu/api.h is present */
-/* #undef HAVE_FPU_API_HEADER */
+#define HAVE_FPU_API_HEADER 1
 
 /* struct file_system_type has mount field */
 #define HAVE_FSTYPE_MOUNT 1
@@ -302,7 +305,7 @@
 /* #undef HAVE_FS_STRUCT_RWLOCK */
 
 /* fs_struct use seqcount */
-#define HAVE_FS_STRUCT_SEQCOUNT 1
+/* #undef HAVE_FS_STRUCT_SEQCOUNT */
 
 /* full_name_hash need 3 arguments */
 #define HAVE_FULL_NAME_HASH_3ARGS 1
@@ -365,7 +368,7 @@
 #define HAVE_IB_DEVICE_ATTRS 1
 
 /* if struct ib_device_ops is defined */
-#define HAVE_IB_DEVICE_OPS 1
+/* #undef HAVE_IB_DEVICE_OPS */
 
 /* ib_get_dma_mr is defined */
 /* #undef HAVE_IB_GET_DMA_MR */
@@ -466,9 +469,15 @@
 /* i_uid_read is present */
 #define HAVE_I_UID_READ 1
 
+/* jiffies_to_timespec64() is available */
+#define HAVE_JIFFIES_TO_TIMESPEC64 1
+
 /* kernel_locked is defined */
 /* #undef HAVE_KERNEL_LOCKED */
 
+/* kernel_setsockopt still in use */
+/* #undef HAVE_KERNEL_SETSOCKOPT */
+
 /* 'struct sock' accept function requires bool argument */
 #define HAVE_KERN_SOCK_ACCEPT_FLAG_ARG 1
 
@@ -548,9 +557,6 @@
 /* 'ktime_to_timespec64' is available */
 #define HAVE_KTIME_TO_TIMESPEC64 1
 
-/* ns_to_timespec64 is available */
-#define HAVE_NS_TO_TIMESPEC64
-
 /* enable use of ldiskfsprogs package */
 /* #undef HAVE_LDISKFSPROGS */
 
@@ -579,7 +585,7 @@
 #define HAVE_LINUX_RANDOM_H 1
 
 /* if linux/selinux.h exists */
-#undef HAVE_LINUX_SELINUX_IS_ENABLED
+/* #undef HAVE_LINUX_SELINUX_IS_ENABLED */
 
 /* Define to 1 if you have the <linux/types.h> header file. */
 #define HAVE_LINUX_TYPES_H 1
@@ -621,6 +627,9 @@
 /* kernel has include/linux/migrate_mode.h */
 /* #undef HAVE_MIGRATE_MODE_H */
 
+/* mmap_lock API is available. */
+#define HAVE_MMAP_LOCK 1
+
 /* kernel module loading is possible */
 #define HAVE_MODULE_LOADING_SUPPORT 1
 
@@ -636,6 +645,9 @@
 /* 'kernel_write' aligns with read/write helpers */
 #define HAVE_NEW_KERNEL_WRITE 1
 
+/* NR_UNSTABLE_NFS is still in use. */
+/* #undef HAVE_NR_UNSTABLE_NFS */
+
 /* with oldsize */
 /* #undef HAVE_OLDSIZE_TRUNCATE_PAGECACHE */
 
@@ -646,7 +658,7 @@
 #define HAVE_PAGEVEC_INIT_ONE_PARAM 1
 
 /* have PCLMULQDQ instruction */
-/* #undef HAVE_PCLMULQDQ */
+#define HAVE_PCLMULQDQ 1
 
 /* percpu_counter_init uses GFP_* flag */
 #define HAVE_PERCPU_COUNTER_INIT_GFP_FLAG 1
@@ -663,6 +675,9 @@
 /* posix_acl_valid takes struct user_namespace */
 #define HAVE_POSIX_ACL_VALID_USER_NS 1
 
+/* struct proc_ops exists */
+#define HAVE_PROC_OPS 1
+
 /* proc_remove is defined */
 #define HAVE_PROC_REMOVE 1
 
@@ -684,6 +699,9 @@
 /* rdma_create_id wants 5 args */
 #define HAVE_RDMA_CREATE_ID_5ARG 1
 
+/* rdma_reject has 4 arguments */
+#define HAVE_RDMA_REJECT_4ARGS 1
+
 /* reinit_completion is exist */
 #define HAVE_REINIT_COMPLETION 1
 
@@ -718,10 +736,10 @@
 /* #undef HAVE_SECURITY_IINITSEC_QSTR */
 
 /* support for selinux */
-/* #undef HAVE_SELINUX */
+#define HAVE_SELINUX 1
 
 /* Define to 1 if you have the <selinux/selinux.h> header file. */
-/* #undef HAVE_SELINUX_SELINUX_H */
+#define HAVE_SELINUX_SELINUX_H 1
 
 /* support server */
 /* #undef HAVE_SERVER_SUPPORT */
@@ -751,12 +769,6 @@
 /* kernel has sk_sleep */
 #define HAVE_SK_SLEEP 1
 
-/* sock_alloc_file is exported */
-/* #undef HAVE_SOCK_ALLOC_FILE */
-
-/* sock_alloc_file takes 3 arguments */
-#define HAVE_SOCK_ALLOC_FILE_3ARGS 1
-
 /* sock_create_kern use net as first parameter */
 #define HAVE_SOCK_CREATE_KERN_USE_NET 1
 
@@ -847,6 +859,9 @@
 /* 'timespec64_to_ktime' is available */
 #define HAVE_TIMESPEC64_TO_KTIME 1
 
+/* have_time_t */
+/* #undef HAVE_TIME_T */
+
 /* topology_sibling_cpumask is available */
 #define HAVE_TOPOLOGY_SIBLING_CPUMASK 1
 
@@ -880,6 +895,9 @@
 /* kernel has vfs_unlink with 3 args */
 #define HAVE_VFS_UNLINK_3ARGS 1
 
+/* __vmalloc only takes 2 args. */
+#define HAVE_VMALLOC_2ARGS 1
+
 /* virtual_address has been replaced by address field */
 #define HAVE_VM_FAULT_ADDRESS 1
 
@@ -922,12 +940,6 @@
 /* __add_wait_queue_exclusive exists */
 /* #undef HAVE___ADD_WAIT_QUEUE_EXCLUSIVE */
 
-/* NR_UNSTABLE_NFS is still in use. */
-/* #undef HAVE_NR_UNSTABLE_NFS */
-
-/* rdma_reject has 4 arguments */
-#define HAVE_RDMA_REJECT_4ARGS
-
 /* ext4_journal_start takes 3 arguments */
 /* #undef JOURNAL_START_HAS_3ARGS */
 
@@ -969,10 +981,10 @@
 #define MKE2FS "mke2fs"
 
 /* need pclmulqdq based crc32c */
-#define NEED_CRC32C_ACCEL 1
+/* #undef NEED_CRC32C_ACCEL */
 
 /* need pclmulqdq based crc32 */
-#define NEED_CRC32_ACCEL 1
+/* #undef NEED_CRC32_ACCEL */
 
 /* 'ktime_get_real_ns' is not available */
 /* #undef NEED_KTIME_GET_REAL_NS */
@@ -1004,6 +1016,9 @@
 /* name of parallel fsck program */
 #define PFSCK "fsck"
 
+/* proc handler methods use __user */
+/* #undef PROC_HANDLER_USE_USER_ATTR */
+
 /* enable randomly alloc failure */
 #define RANDOM_FAIL_ALLOC 1
 
diff --git a/drivers/staging/lustrefsx/libcfs/include/libcfs/libcfs.h b/drivers/staging/lustrefsx/libcfs/include/libcfs/libcfs.h
index 8055d3751092..f01170c6e1d9 100644
--- a/drivers/staging/lustrefsx/libcfs/include/libcfs/libcfs.h
+++ b/drivers/staging/lustrefsx/libcfs/include/libcfs/libcfs.h
@@ -144,4 +144,7 @@ static inline void *__container_of(const void *ptr, unsigned long shift)
 
 #endif /* __KERNEL__ */
 
+/* atomic-context safe vfree */
+void libcfs_vfree_atomic(const void *addr);
+
 #endif /* _LIBCFS_LIBCFS_H_ */
diff --git a/drivers/staging/lustrefsx/libcfs/include/libcfs/libcfs_private.h b/drivers/staging/lustrefsx/libcfs/include/libcfs/libcfs_private.h
index bcd7d56b65a9..ebcdc990203b 100644
--- a/drivers/staging/lustrefsx/libcfs/include/libcfs/libcfs_private.h
+++ b/drivers/staging/lustrefsx/libcfs/include/libcfs/libcfs_private.h
@@ -213,6 +213,9 @@ do {									    \
 #define LIBCFS_CPT_ALLOC(ptr, cptab, cpt, size)				    \
 	LIBCFS_CPT_ALLOC_GFP(ptr, cptab, cpt, size, GFP_NOFS)
 
+void init_libcfs_vfree_atomic(void);
+void exit_libcfs_vfree_atomic(void);
+
 #define LIBCFS_FREE(ptr, size)						\
 do {									\
 	int s = (size);                                                 \
@@ -225,7 +228,7 @@ do {									\
 	CDEBUG(D_MALLOC, "kfreed '" #ptr "': %d at %p (tot %d).\n",     \
 	       s, (ptr), libcfs_kmem_read());				\
 	if (unlikely(s > LIBCFS_VMALLOC_SIZE))                          \
-		vfree(ptr);						\
+		libcfs_vfree_atomic(ptr);						\
 	else								\
 		kfree(ptr);						\
 } while (0)
diff --git a/drivers/staging/lustrefsx/libcfs/include/libcfs/linux/linux-crypto.h b/drivers/staging/lustrefsx/libcfs/include/libcfs/linux/linux-crypto.h
index 6346c59e516e..a9c15a66ab20 100644
--- a/drivers/staging/lustrefsx/libcfs/include/libcfs/linux/linux-crypto.h
+++ b/drivers/staging/lustrefsx/libcfs/include/libcfs/linux/linux-crypto.h
@@ -26,6 +26,11 @@
  * Copyright 2012 Xyratex Technology Limited
  */
 
+/* Added in v4.15-rc4 (commit a208fa8f3303) */
+#ifndef CRYPTO_ALG_OPTIONAL_KEY
+#define CRYPTO_ALG_OPTIONAL_KEY 0x00004000
+#endif
+
 /**
  * Linux crypto hash specific functions.
  */
diff --git a/drivers/staging/lustrefsx/libcfs/include/libcfs/linux/linux-fs.h b/drivers/staging/lustrefsx/libcfs/include/libcfs/linux/linux-fs.h
index 59d9874bbf97..dbc84de17214 100644
--- a/drivers/staging/lustrefsx/libcfs/include/libcfs/linux/linux-fs.h
+++ b/drivers/staging/lustrefsx/libcfs/include/libcfs/linux/linux-fs.h
@@ -99,4 +99,22 @@ static inline struct dentry *file_dentry(const struct file *file)
 #ifndef HAVE_POSIX_ACL_VALID_USER_NS
 #define posix_acl_valid(a,b) posix_acl_valid(b)
 #endif
+
+#ifdef HAVE_PROC_OPS
+#define PROC_OWNER(_fn)
+#else
+#define proc_ops file_operations
+#define PROC_OWNER(_owner)		.owner = (_owner),
+#define proc_open			open
+#define proc_read			read
+#define proc_write			write
+#define proc_lseek			llseek
+#define proc_release			release
+#define proc_poll			poll
+#define proc_ioctl			unlocked_ioctl
+#define proc_compat_ioctl		compat_ioctl
+#define proc_mmap			mmap
+#define proc_get_unmapped_area		get_unmapped_area
+#endif
+
 #endif
diff --git a/drivers/staging/lustrefsx/libcfs/include/libcfs/linux/linux-mem.h b/drivers/staging/lustrefsx/libcfs/include/libcfs/linux/linux-mem.h
index 086d16baeaf1..f08d623bd8a8 100644
--- a/drivers/staging/lustrefsx/libcfs/include/libcfs/linux/linux-mem.h
+++ b/drivers/staging/lustrefsx/libcfs/include/libcfs/linux/linux-mem.h
@@ -129,4 +129,42 @@ void remove_shrinker(struct shrinker *shrinker)
         kfree(shrinker);
 }
 
+#ifndef HAVE_MMAP_LOCK
+static inline void mmap_write_lock(struct mm_struct *mm)
+{
+	down_write(&mm->mmap_sem);
+}
+
+static inline bool mmap_write_trylock(struct mm_struct *mm)
+{
+	return down_write_trylock(&mm->mmap_sem) != 0;
+}
+
+static inline void mmap_write_unlock(struct mm_struct *mm)
+{
+	up_write(&mm->mmap_sem);
+}
+
+static inline void mmap_read_lock(struct mm_struct *mm)
+{
+	down_read(&mm->mmap_sem);
+}
+
+static inline bool mmap_read_trylock(struct mm_struct *mm)
+{
+	return down_read_trylock(&mm->mmap_sem) != 0;
+}
+
+static inline void mmap_read_unlock(struct mm_struct *mm)
+{
+	up_read(&mm->mmap_sem);
+}
+#endif
+
+#ifdef HAVE_VMALLOC_2ARGS
+#define __ll_vmalloc(size, flags) __vmalloc(size, flags)
+#else
+#define __ll_vmalloc(size, flags) __vmalloc(size, flags, PAGE_KERNEL)
+#endif
+
 #endif /* __LINUX_CFS_MEM_H__ */
diff --git a/drivers/staging/lustrefsx/libcfs/include/libcfs/linux/linux-misc.h b/drivers/staging/lustrefsx/libcfs/include/libcfs/linux/linux-misc.h
index 8b3d398459c7..754f18305048 100644
--- a/drivers/staging/lustrefsx/libcfs/include/libcfs/linux/linux-misc.h
+++ b/drivers/staging/lustrefsx/libcfs/include/libcfs/linux/linux-misc.h
@@ -60,6 +60,10 @@
 #endif
 #endif /* HAVE_IOV_ITER_TYPE */
 
+#ifndef HAVE_LINUX_SELINUX_IS_ENABLED
+bool selinux_is_enabled(void);
+#endif
+
 #ifndef HAVE_UIDGID_HEADER
 
 #ifndef _LINUX_UIDGID_H
diff --git a/drivers/staging/lustrefsx/libcfs/include/libcfs/linux/linux-net.h b/drivers/staging/lustrefsx/libcfs/include/libcfs/linux/linux-net.h
new file mode 100644
index 000000000000..41484bd3b44a
--- /dev/null
+++ b/drivers/staging/lustrefsx/libcfs/include/libcfs/linux/linux-net.h
@@ -0,0 +1,72 @@
+/*
+ * GPL HEADER START
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 only,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License version 2 for more details (a copy is included
+ * in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License
+ * version 2 along with this program; If not, see
+ * http://www.gnu.org/licenses/gpl-2.0.html
+ *
+ * GPL HEADER END
+ */
+
+#ifndef __LIBCFS_LINUX_NET_H__
+#define __LIBCFS_LINUX_NET_H__
+
+#ifdef HAVE_KERNEL_SETSOCKOPT
+
+#include <net/tcp.h>
+
+static inline void tcp_sock_set_quickack(struct sock *sk, int opt)
+{
+	struct socket *sock = sk->sk_socket;
+
+	kernel_setsockopt(sock, SOL_TCP, TCP_QUICKACK,
+			  (char *)&opt, sizeof(opt));
+}
+
+static inline void tcp_sock_set_nodelay(struct sock *sk)
+{
+	int opt = 1;
+	struct socket *sock = sk->sk_socket;
+
+	kernel_setsockopt(sock, SOL_TCP, TCP_NODELAY,
+			  (char *)&opt, sizeof(opt));
+}
+
+static inline int tcp_sock_set_keepidle(struct sock *sk, int opt)
+{
+	struct socket *sock = sk->sk_socket;
+
+	return kernel_setsockopt(sock, SOL_TCP, TCP_KEEPIDLE,
+				 (char *)&opt, sizeof(opt));
+}
+
+static inline int tcp_sock_set_keepintvl(struct sock *sk, int opt)
+{
+	struct socket *sock = sk->sk_socket;
+
+	return kernel_setsockopt(sock, SOL_TCP, TCP_KEEPINTVL,
+				 (char *)&opt, sizeof(opt));
+}
+
+static inline int tcp_sock_set_keepcnt(struct sock *sk, int opt)
+{
+	struct socket *sock = sk->sk_socket;
+
+	return kernel_setsockopt(sock, SOL_TCP, TCP_KEEPCNT,
+				 (char *)&opt, sizeof(opt));
+}
+#endif /* HAVE_KERNEL_SETSOCKOPT */
+
+#endif /* __LIBCFS_LINUX_NET_H__ */
diff --git a/drivers/staging/lustrefsx/libcfs/include/libcfs/linux/linux-time.h b/drivers/staging/lustrefsx/libcfs/include/libcfs/linux/linux-time.h
index d22bda9895fe..07dd2e05a608 100644
--- a/drivers/staging/lustrefsx/libcfs/include/libcfs/linux/linux-time.h
+++ b/drivers/staging/lustrefsx/libcfs/include/libcfs/linux/linux-time.h
@@ -143,29 +143,22 @@ static inline struct timespec timespec64_to_timespec(const struct timespec64 ts6
 
 #endif /* HAVE_TIMESPEC64 */
 
-#if __BITS_PER_LONG == 64
-#define time_t long
-#else
-#error "lustre is not supported on 32bit"
+#ifndef HAVE_TIME_T
+typedef __kernel_old_time_t time_t;
 #endif
 
-#ifndef HAVE_NS_TO_TIMESPEC64
-static inline struct timespec64 ns_to_timespec64(const s64 nsec)
+#ifndef HAVE_JIFFIES_TO_TIMESPEC64
+static inline void
+jiffies_to_timespec64(const unsigned long jiffies, struct timespec64 *value)
 {
-	struct timespec64 ts;
-	s32 rem;
-
-	if (!nsec)
-		return (struct timespec64) {0, 0};
-
-	ts.tv_sec = div_s64_rem(nsec, NSEC_PER_SEC, &rem);
-	if (unlikely(rem < 0)) {
-		ts.tv_sec--;
-		rem += NSEC_PER_SEC;
-	}
-	ts.tv_nsec = rem;
-
-	return ts;
+	/*
+	 * Convert jiffies to nanoseconds and separate with
+	 * one divide.
+	 */
+	u32 rem;
+	value->tv_sec = div_u64_rem((u64)jiffies * TICK_NSEC,
+					NSEC_PER_SEC, &rem);
+	value->tv_nsec = rem;
 }
 #endif
 
diff --git a/drivers/staging/lustrefsx/libcfs/libcfs/libcfs_mem.c b/drivers/staging/lustrefsx/libcfs/libcfs/libcfs_mem.c
index 3e83f5057991..2f401e74a7dd 100644
--- a/drivers/staging/lustrefsx/libcfs/libcfs/libcfs_mem.c
+++ b/drivers/staging/lustrefsx/libcfs/libcfs/libcfs_mem.c
@@ -33,6 +33,7 @@
 
 #define DEBUG_SUBSYSTEM S_LNET
 
+#include <linux/workqueue.h>
 #include <libcfs/libcfs.h>
 
 struct cfs_var_array {
@@ -170,3 +171,62 @@ cfs_array_alloc(int count, unsigned int size)
 	return (void *)&arr->va_ptrs[0];
 }
 EXPORT_SYMBOL(cfs_array_alloc);
+
+/*
+ * This is opencoding of vfree_atomic from Linux kernel added in 4.10 with
+ * minimum changes needed to work on older kernels too.
+ */
+
+#ifndef raw_cpu_ptr
+#define raw_cpu_ptr(p) __this_cpu_ptr(p)
+#endif
+
+#ifndef llist_for_each_safe
+#define llist_for_each_safe(pos, n, node)                       \
+		for ((pos) = (node); (pos) && ((n) = (pos)->next, true); (pos) = (n))
+#endif
+
+struct vfree_deferred {
+		struct llist_head list;
+		struct work_struct wq;
+};
+static DEFINE_PER_CPU(struct vfree_deferred, vfree_deferred);
+
+static void free_work(struct work_struct *w)
+{
+	struct vfree_deferred *p = container_of(w, struct vfree_deferred, wq);
+	struct llist_node *t, *llnode;
+
+	llist_for_each_safe(llnode, t, llist_del_all(&p->list))
+		vfree((void *)llnode);
+}
+
+void libcfs_vfree_atomic(const void *addr)
+{
+	struct vfree_deferred *p = raw_cpu_ptr(&vfree_deferred);
+
+	if (!addr)
+		return;
+
+	if (llist_add((struct llist_node *)addr, &p->list))
+		schedule_work(&p->wq);
+}
+EXPORT_SYMBOL(libcfs_vfree_atomic);
+
+void __init init_libcfs_vfree_atomic(void)
+{
+	int i;
+
+	for_each_possible_cpu(i) {
+		struct vfree_deferred *p;
+
+		p = &per_cpu(vfree_deferred, i);
+		init_llist_head(&p->list);
+		INIT_WORK(&p->wq, free_work);
+	}
+}
+
+void __exit exit_libcfs_vfree_atomic(void)
+{
+	flush_scheduled_work();
+}
diff --git a/drivers/staging/lustrefsx/libcfs/libcfs/linux/linux-crypto-adler.c b/drivers/staging/lustrefsx/libcfs/libcfs/linux/linux-crypto-adler.c
index b71d7f8bc9d6..0f507d555e60 100644
--- a/drivers/staging/lustrefsx/libcfs/libcfs/linux/linux-crypto-adler.c
+++ b/drivers/staging/lustrefsx/libcfs/libcfs/linux/linux-crypto-adler.c
@@ -116,9 +116,10 @@ static struct shash_alg alg = {
 		.cra_name		= "adler32",
 		.cra_driver_name	= "adler32-zlib",
 		.cra_priority		= 100,
+		.cra_flags		= CRYPTO_ALG_OPTIONAL_KEY,
 		.cra_blocksize		= CHKSUM_BLOCK_SIZE,
 		.cra_ctxsize		= sizeof(u32),
-		.cra_module		= THIS_MODULE,
+		.cra_module		= NULL,
 		.cra_init		= adler32_cra_init,
 	}
 };
diff --git a/drivers/staging/lustrefsx/libcfs/libcfs/linux/linux-crypto-crc32.c b/drivers/staging/lustrefsx/libcfs/libcfs/linux/linux-crypto-crc32.c
index 85fc287cb884..c20e5e9a8194 100644
--- a/drivers/staging/lustrefsx/libcfs/libcfs/linux/linux-crypto-crc32.c
+++ b/drivers/staging/lustrefsx/libcfs/libcfs/linux/linux-crypto-crc32.c
@@ -65,7 +65,6 @@ static int crc32_setkey(struct crypto_shash *hash, const u8 *key,
 
 	if (keylen != sizeof(u32))
 		return -EINVAL;
-
 	*mctx = le32_to_cpup((__le32 *)key);
 	return 0;
 }
@@ -129,9 +128,10 @@ static struct shash_alg alg = {
 		.cra_name		= "crc32",
 		.cra_driver_name	= "crc32-table",
 		.cra_priority		= 100,
+		.cra_flags		= CRYPTO_ALG_OPTIONAL_KEY,
 		.cra_blocksize		= CHKSUM_BLOCK_SIZE,
 		.cra_ctxsize		= sizeof(u32),
-		.cra_module		= THIS_MODULE,
+		.cra_module		= NULL,
 		.cra_init		= crc32_cra_init,
 	}
 };
diff --git a/drivers/staging/lustrefsx/libcfs/libcfs/linux/linux-crypto-crc32c-pclmul.c b/drivers/staging/lustrefsx/libcfs/libcfs/linux/linux-crypto-crc32c-pclmul.c
index 40d9e7416068..5262f071b8a7 100644
--- a/drivers/staging/lustrefsx/libcfs/libcfs/linux/linux-crypto-crc32c-pclmul.c
+++ b/drivers/staging/lustrefsx/libcfs/libcfs/linux/linux-crypto-crc32c-pclmul.c
@@ -63,7 +63,6 @@ static int crc32c_pclmul_setkey(struct crypto_shash *hash, const u8 *key,
 
 	if (keylen != sizeof(u32))
 		return -EINVAL;
-
 	*mctx = le32_to_cpup((__le32 *)key);
 	return 0;
 }
@@ -132,9 +131,10 @@ static struct shash_alg alg = {
 			.cra_name		= "crc32c",
 			.cra_driver_name	= "crc32c-pclmul",
 			.cra_priority		= 150,
+			.cra_flags		= CRYPTO_ALG_OPTIONAL_KEY,
 			.cra_blocksize		= CHKSUM_BLOCK_SIZE,
 			.cra_ctxsize		= sizeof(u32),
-			.cra_module		= THIS_MODULE,
+			.cra_module		= NULL,
 			.cra_init		= crc32c_pclmul_cra_init,
 	}
 };
diff --git a/drivers/staging/lustrefsx/libcfs/libcfs/linux/linux-crypto-crc32pclmul.c b/drivers/staging/lustrefsx/libcfs/libcfs/linux/linux-crypto-crc32pclmul.c
index 88e697897b15..4ad3b7c31003 100644
--- a/drivers/staging/lustrefsx/libcfs/libcfs/linux/linux-crypto-crc32pclmul.c
+++ b/drivers/staging/lustrefsx/libcfs/libcfs/linux/linux-crypto-crc32pclmul.c
@@ -102,7 +102,6 @@ static int crc32_pclmul_setkey(struct crypto_shash *hash, const u8 *key,
 
 	if (keylen != sizeof(u32))
 		return -EINVAL;
-
 	*mctx = le32_to_cpup((__le32 *)key);
 	return 0;
 }
@@ -170,7 +169,7 @@ static struct shash_alg alg = {
 			.cra_priority		= 200,
 			.cra_blocksize		= CHKSUM_BLOCK_SIZE,
 			.cra_ctxsize		= sizeof(u32),
-			.cra_module		= THIS_MODULE,
+			.cra_module		= NULL,
 			.cra_init		= crc32_pclmul_cra_init,
 	}
 };
diff --git a/drivers/staging/lustrefsx/libcfs/libcfs/linux/linux-curproc.c b/drivers/staging/lustrefsx/libcfs/libcfs/linux/linux-curproc.c
index 36a4fdef2dc2..cd00d0ae5717 100644
--- a/drivers/staging/lustrefsx/libcfs/libcfs/linux/linux-curproc.c
+++ b/drivers/staging/lustrefsx/libcfs/libcfs/linux/linux-curproc.c
@@ -141,7 +141,7 @@ static int cfs_access_process_vm(struct task_struct *tsk,
 	 * which is already holding mmap_lock for writes.  If some other
 	 * thread gets the write lock in the meantime, this thread will
 	 * block, but at least it won't deadlock on itself.  LU-1735 */
-	if (down_read_trylock(&mm->mmap_lock) == 0)
+	if (!mmap_read_trylock(mm))
 		return -EDEADLK;
 
 	/* ignore errors, just check how much was successfully transferred */
@@ -181,7 +181,7 @@ static int cfs_access_process_vm(struct task_struct *tsk,
 		buf += bytes;
 		addr += bytes;
 	}
-	up_read(&mm->mmap_lock);
+	mmap_read_unlock(mm);
 
 	return buf - old_buf;
 }
diff --git a/drivers/staging/lustrefsx/libcfs/libcfs/linux/linux-prim.c b/drivers/staging/lustrefsx/libcfs/libcfs/linux/linux-prim.c
index e63f7317485d..4b73ed6e79a9 100644
--- a/drivers/staging/lustrefsx/libcfs/libcfs/linux/linux-prim.c
+++ b/drivers/staging/lustrefsx/libcfs/libcfs/linux/linux-prim.c
@@ -97,6 +97,18 @@ time64_t ktime_get_seconds(void)
 EXPORT_SYMBOL(ktime_get_seconds);
 #endif /* HAVE_KTIME_GET_SECONDS */
 
+#ifndef HAVE_LINUX_SELINUX_IS_ENABLED
+static char **cfs_lsm_names;
+
+bool selinux_is_enabled(void)
+{
+	if (cfs_lsm_names)
+		return !!strstr("selinux", *cfs_lsm_names);
+	return false;
+}
+EXPORT_SYMBOL(selinux_is_enabled);
+#endif
+
 int cfs_kernel_write(struct file *filp, const void *buf, size_t count,
 		     loff_t *pos)
 {
diff --git a/drivers/staging/lustrefsx/libcfs/libcfs/module.c b/drivers/staging/lustrefsx/libcfs/libcfs/module.c
index 910a44bc97f4..f832a6fd02bc 100644
--- a/drivers/staging/lustrefsx/libcfs/libcfs/module.c
+++ b/drivers/staging/lustrefsx/libcfs/libcfs/module.c
@@ -727,7 +727,7 @@ static void remove_proc(void)
 static int __init libcfs_init(void)
 {
 	int rc;
-
+	init_libcfs_vfree_atomic();
 	rc = libcfs_debug_init(5 * 1024 * 1024);
 	if (rc < 0) {
 		printk(KERN_ERR "LustreError: libcfs_debug_init: %d\n", rc);
@@ -816,6 +816,7 @@ static void __exit libcfs_exit(void)
 	if (rc)
 		printk(KERN_ERR "LustreError: libcfs_debug_cleanup: %d\n",
 		       rc);
+	exit_libcfs_vfree_atomic();
 }
 
 MODULE_AUTHOR("OpenSFS, Inc. <http://www.lustre.org/>");
diff --git a/drivers/staging/lustrefsx/libcfs/libcfs/tracefile.c b/drivers/staging/lustrefsx/libcfs/libcfs/tracefile.c
index 798471bb694d..ac762726fa5c 100644
--- a/drivers/staging/lustrefsx/libcfs/libcfs/tracefile.c
+++ b/drivers/staging/lustrefsx/libcfs/libcfs/tracefile.c
@@ -737,8 +737,12 @@ int cfs_trace_copyin_string(char *knl_buffer, int knl_buffer_nob,
         if (usr_buffer_nob > knl_buffer_nob)
                 return -EOVERFLOW;
 
+#ifdef PROC_HANDLER_USE_USER_ATTR
 	if (copy_from_user(knl_buffer, usr_buffer, usr_buffer_nob))
                 return -EFAULT;
+#else
+	memcpy(knl_buffer, usr_buffer, usr_buffer_nob);
+#endif
 
         nob = strnlen(knl_buffer, usr_buffer_nob);
         while (nob-- >= 0)                      /* strip trailing whitespace */
@@ -767,12 +771,20 @@ int cfs_trace_copyout_string(char __user *usr_buffer, int usr_buffer_nob,
         if (nob > usr_buffer_nob)
                 nob = usr_buffer_nob;
 
+#ifdef PROC_HANDLER_USE_USER_ATTR
 	if (copy_to_user(usr_buffer, knl_buffer, nob))
                 return -EFAULT;
+#else
+	memcpy(usr_buffer, knl_buffer, nob);
+#endif
 
         if (append != NULL && nob < usr_buffer_nob) {
+#ifdef PROC_HANDLER_USE_USER_ATTR
 		if (copy_to_user(usr_buffer + nob, append, 1))
                         return -EFAULT;
+#else
+		memcpy(usr_buffer + nob, append, 1);
+#endif
 
                 nob++;
         }
diff --git a/drivers/staging/lustrefsx/lnet/include/lnet/lib-lnet.h b/drivers/staging/lustrefsx/lnet/include/lnet/lib-lnet.h
index 15b89a9f8504..c905eda43b5b 100644
--- a/drivers/staging/lustrefsx/lnet/include/lnet/lib-lnet.h
+++ b/drivers/staging/lustrefsx/lnet/include/lnet/lib-lnet.h
@@ -37,9 +37,7 @@
 #ifndef __LNET_LIB_LNET_H__
 #define __LNET_LIB_LNET_H__
 
-#ifndef __KERNEL__
-# error This include is only for kernel use.
-#endif
+#include <linux/netdevice.h>
 
 #include <libcfs/linux/linux-misc.h>
 #include <libcfs/libcfs.h>
@@ -83,11 +81,6 @@ extern struct lnet the_lnet;			/* THE network */
 		kernel_getsockname(sock, addr, addrlen)
 #endif
 
-#ifndef HAVE_KERNEL_SETSOCKOPT
-int kernel_setsockopt(struct socket *sock, int level, int optname,
-                        char *optval, unsigned int optlen);
-#endif
-
 static inline int lnet_is_route_alive(struct lnet_route *route)
 {
 	if (!route->lr_gateway->lpni_alive)
@@ -783,12 +776,17 @@ int lnet_acceptor_port(void);
 int lnet_acceptor_start(void);
 void lnet_acceptor_stop(void);
 
-int lnet_ipif_query(char *name, int *up, __u32 *ip, __u32 *mask,
-		    struct net *ns);
-int lnet_ipif_enumerate(char ***names, struct net *ns);
-void lnet_ipif_free_enumeration(char **names, int n);
-int lnet_sock_setbuf(struct socket *socket, int txbufsize, int rxbufsize);
-int lnet_sock_getbuf(struct socket *socket, int *txbufsize, int *rxbufsize);
+struct lnet_inetdev {
+	u32	li_cpt;
+	u32	li_flags;
+	u32	li_ipaddr;
+	u32	li_netmask;
+	char	li_name[IFNAMSIZ];
+};
+
+int lnet_inet_enumerate(struct lnet_inetdev **dev_list, struct net *ns);
+void lnet_sock_setbuf(struct socket *socket, int txbufsize, int rxbufsize);
+void lnet_sock_getbuf(struct socket *socket, int *txbufsize, int *rxbufsize);
 int lnet_sock_getaddr(struct socket *socket, bool remote, __u32 *ip, int *port);
 int lnet_sock_write(struct socket *sock, void *buffer, int nob, int timeout);
 int lnet_sock_read(struct socket *sock, void *buffer, int nob, int timeout);
diff --git a/drivers/staging/lustrefsx/lnet/klnds/o2iblnd/o2iblnd.c b/drivers/staging/lustrefsx/lnet/klnds/o2iblnd/o2iblnd.c
index ba4090556550..90645f6388ea 100644
--- a/drivers/staging/lustrefsx/lnet/klnds/o2iblnd/o2iblnd.c
+++ b/drivers/staging/lustrefsx/lnet/klnds/o2iblnd/o2iblnd.c
@@ -1472,10 +1472,13 @@ kiblnd_destroy_fmr_pool(kib_fmr_pool_t *fpo)
 {
 	LASSERT(fpo->fpo_map_count == 0);
 
+#ifdef HAVE_FMR_POOL_API
 	if (fpo->fpo_is_fmr) {
 		if (fpo->fmr.fpo_fmr_pool)
 			ib_destroy_fmr_pool(fpo->fmr.fpo_fmr_pool);
-	} else {
+	} else
+#endif /* HAVE_FMR_POOL_API */
+	{
 		struct kib_fast_reg_descriptor *frd, *tmp;
 		int i = 0;
 
@@ -1529,6 +1532,7 @@ kiblnd_fmr_flush_trigger(struct lnet_ioctl_config_o2iblnd_tunables *tunables,
 	return max(IBLND_FMR_POOL_FLUSH, size);
 }
 
+#ifdef HAVE_FMR_POOL_API
 static int kiblnd_alloc_fmr_pool(kib_fmr_poolset_t *fps, kib_fmr_pool_t *fpo)
 {
 	struct ib_fmr_pool_param param = {
@@ -1555,6 +1559,7 @@ static int kiblnd_alloc_fmr_pool(kib_fmr_poolset_t *fps, kib_fmr_pool_t *fpo)
 
 	return rc;
 }
+#endif /* HAVE_FMR_POOL_API */
 
 static int kiblnd_alloc_freg_pool(kib_fmr_poolset_t *fps, kib_fmr_pool_t *fpo)
 {
@@ -1667,6 +1672,7 @@ kiblnd_create_fmr_pool(kib_fmr_poolset_t *fps, kib_fmr_pool_t **pp_fpo)
 	}
 #endif
 
+#ifdef HAVE_FMR_POOL_API
 	/* Check for FMR or FastReg support */
 	fpo->fpo_is_fmr = 0;
 #ifdef HAVE_IB_DEVICE_OPS
@@ -1682,7 +1688,9 @@ kiblnd_create_fmr_pool(kib_fmr_poolset_t *fps, kib_fmr_pool_t **pp_fpo)
 #endif
 		LCONSOLE_INFO("Using FMR for registration\n");
 		fpo->fpo_is_fmr = 1;
-	} else if (dev_attr->device_cap_flags & IB_DEVICE_MEM_MGT_EXTENSIONS) {
+	} else
+#endif /* HAVE_FMR_POOL_API */
+	if (dev_attr->device_cap_flags & IB_DEVICE_MEM_MGT_EXTENSIONS) {
 		LCONSOLE_INFO("Using FastReg for registration\n");
 	} else {
 		rc = -ENOSYS;
@@ -1690,9 +1698,11 @@ kiblnd_create_fmr_pool(kib_fmr_poolset_t *fps, kib_fmr_pool_t **pp_fpo)
 		goto out_dev_attr;
 	}
 
+#ifdef HAVE_FMR_POOL_API
 	if (fpo->fpo_is_fmr)
 		rc = kiblnd_alloc_fmr_pool(fps, fpo);
 	else
+#endif /* HAVE_FMR_POOL_API */
 		rc = kiblnd_alloc_freg_pool(fps, fpo);
 	if (rc)
 		goto out_fpo;
@@ -1787,6 +1797,7 @@ kiblnd_fmr_pool_is_idle(kib_fmr_pool_t *fpo, cfs_time_t now)
         return cfs_time_aftereq(now, fpo->fpo_deadline);
 }
 
+#if defined(HAVE_FMR_POOL_API) || !defined(HAVE_IB_MAP_MR_SG)
 static int
 kiblnd_map_tx_pages(kib_tx_t *tx, kib_rdma_desc_t *rd)
 {
@@ -1808,6 +1819,7 @@ kiblnd_map_tx_pages(kib_tx_t *tx, kib_rdma_desc_t *rd)
 
 	return npages;
 }
+#endif
 
 void
 kiblnd_fmr_pool_unmap(kib_fmr_t *fmr, int status)
@@ -1817,12 +1829,13 @@ kiblnd_fmr_pool_unmap(kib_fmr_t *fmr, int status)
 	kib_fmr_poolset_t *fps;
 	cfs_time_t         now = cfs_time_current();
 	kib_fmr_pool_t    *tmp;
-	int                rc;
 
 	if (!fpo)
 		return;
 
 	fps = fpo->fpo_owner;
+
+#ifdef HAVE_FMR_POOL_API
 	if (fpo->fpo_is_fmr) {
 		if (fmr->fmr_pfmr) {
 			ib_fmr_pool_unmap(fmr->fmr_pfmr);
@@ -1830,10 +1843,12 @@ kiblnd_fmr_pool_unmap(kib_fmr_t *fmr, int status)
 		}
 
 		if (status) {
-			rc = ib_flush_fmr_pool(fpo->fmr.fpo_fmr_pool);
+			int rc = ib_flush_fmr_pool(fpo->fmr.fpo_fmr_pool);
 			LASSERT(!rc);
 		}
-	} else {
+	} else
+#endif /* HAVE_FMR_POOL_API */
+	{
 		struct kib_fast_reg_descriptor *frd = fmr->fmr_frd;
 
 		if (frd) {
@@ -1870,11 +1885,13 @@ kiblnd_fmr_pool_map(kib_fmr_poolset_t *fps, kib_tx_t *tx, kib_rdma_desc_t *rd,
 		    __u32 nob, __u64 iov, kib_fmr_t *fmr, bool *is_fastreg)
 {
 	kib_fmr_pool_t *fpo;
-	__u64 *pages = tx->tx_pages;
 	__u64 version;
 	bool is_rx = (rd != tx->tx_rd);
+#ifdef HAVE_FMR_POOL_API
+	__u64 *pages = tx->tx_pages;
 	bool tx_pages_mapped = 0;
 	int npages = 0;
+#endif
 	int rc;
 
 again:
@@ -1884,6 +1901,8 @@ kiblnd_fmr_pool_map(kib_fmr_poolset_t *fps, kib_tx_t *tx, kib_rdma_desc_t *rd,
 		fpo->fpo_deadline = cfs_time_shift(IBLND_POOL_DEADLINE);
 		fpo->fpo_map_count++;
 
+#ifdef HAVE_FMR_POOL_API
+		fmr->fmr_pfmr = NULL;
 		if (fpo->fpo_is_fmr) {
 			struct ib_pool_fmr *pfmr;
 
@@ -1906,7 +1925,9 @@ kiblnd_fmr_pool_map(kib_fmr_poolset_t *fps, kib_tx_t *tx, kib_rdma_desc_t *rd,
 				return 0;
 			}
 			rc = PTR_ERR(pfmr);
-		} else {
+		} else
+#endif /* HAVE_FMR_POOL_API */
+		{
 			*is_fastreg = 1;
 			if (!list_empty(&fpo->fast_reg.fpo_pool_list)) {
 				struct kib_fast_reg_descriptor *frd;
@@ -1953,7 +1974,7 @@ kiblnd_fmr_pool_map(kib_fmr_poolset_t *fps, kib_tx_t *tx, kib_rdma_desc_t *rd,
 #else
 				n = ib_map_mr_sg(mr, tx->tx_frags,
 						 tx->tx_nfrags, PAGE_SIZE);
-#endif
+#endif /* HAVE_IB_MAP_MR_SG_5ARGS */
 				if (unlikely(n != tx->tx_nfrags)) {
 					CERROR("Failed to map mr %d/%d "
 					       "elements\n", n, tx->tx_nfrags);
@@ -1971,7 +1992,7 @@ kiblnd_fmr_pool_map(kib_fmr_poolset_t *fps, kib_tx_t *tx, kib_rdma_desc_t *rd,
 				wr->key = is_rx ? mr->rkey : mr->lkey;
 				wr->access = (IB_ACCESS_LOCAL_WRITE |
 					      IB_ACCESS_REMOTE_WRITE);
-#else
+#else /* HAVE_IB_MAP_MR_SG */
 				if (!tx_pages_mapped) {
 					npages = kiblnd_map_tx_pages(tx, rd);
 					tx_pages_mapped = 1;
@@ -1998,11 +2019,10 @@ kiblnd_fmr_pool_map(kib_fmr_poolset_t *fps, kib_tx_t *tx, kib_rdma_desc_t *rd,
 				wr->wr.wr.fast_reg.access_flags =
 						(IB_ACCESS_LOCAL_WRITE |
 						 IB_ACCESS_REMOTE_WRITE);
-#endif
+#endif /* HAVE_IB_MAP_MR_SG */
 
 				fmr->fmr_key  = is_rx ? mr->rkey : mr->lkey;
 				fmr->fmr_frd  = frd;
-				fmr->fmr_pfmr = NULL;
 				fmr->fmr_pool = fpo;
 				return 0;
 			}
@@ -2875,59 +2895,6 @@ kiblnd_destroy_dev (kib_dev_t *dev)
         LIBCFS_FREE(dev, sizeof(*dev));
 }
 
-static kib_dev_t *
-kiblnd_create_dev(char *ifname, struct net *ns)
-{
-        struct net_device *netdev;
-        kib_dev_t         *dev;
-        __u32              netmask;
-        __u32              ip;
-        int                up;
-        int                rc;
-
-	rc = lnet_ipif_query(ifname, &up, &ip, &netmask, ns);
-        if (rc != 0) {
-                CERROR("Can't query IPoIB interface %s: %d\n",
-                       ifname, rc);
-                return NULL;
-        }
-
-        if (!up) {
-                CERROR("Can't query IPoIB interface %s: it's down\n", ifname);
-                return NULL;
-        }
-
-        LIBCFS_ALLOC(dev, sizeof(*dev));
-        if (dev == NULL)
-                return NULL;
-
-	netdev = dev_get_by_name(ns, ifname);
-        if (netdev == NULL) {
-                dev->ibd_can_failover = 0;
-        } else {
-                dev->ibd_can_failover = !!(netdev->flags & IFF_MASTER);
-                dev_put(netdev);
-        }
-
-	INIT_LIST_HEAD(&dev->ibd_nets);
-	INIT_LIST_HEAD(&dev->ibd_list); /* not yet in kib_devs */
-	INIT_LIST_HEAD(&dev->ibd_fail_list);
-        dev->ibd_ifip = ip;
-        strcpy(&dev->ibd_ifname[0], ifname);
-
-        /* initialize the device */
-	rc = kiblnd_dev_failover(dev, ns);
-        if (rc != 0) {
-                CERROR("Can't initialize device: %d\n", rc);
-                LIBCFS_FREE(dev, sizeof(*dev));
-                return NULL;
-        }
-
-	list_add_tail(&dev->ibd_list,
-                          &kiblnd_data.kib_devs);
-        return dev;
-}
-
 static void
 kiblnd_base_shutdown(void)
 {
@@ -3208,8 +3175,7 @@ kiblnd_start_schedulers(struct kib_sched_info *sched)
 	return rc;
 }
 
-static int
-kiblnd_dev_start_threads(kib_dev_t *dev, int newdev, __u32 *cpts, int ncpts)
+static int kiblnd_dev_start_threads(kib_dev_t *dev, __u32 *cpts, int ncpts)
 {
 	int	cpt;
 	int	rc;
@@ -3221,7 +3187,7 @@ kiblnd_dev_start_threads(kib_dev_t *dev, int newdev, __u32 *cpts, int ncpts)
 		cpt = (cpts == NULL) ? i : cpts[i];
 		sched = kiblnd_data.kib_scheds[cpt];
 
-		if (!newdev && sched->ibs_nthreads > 0)
+		if (sched->ibs_nthreads > 0)
 			continue;
 
 		rc = kiblnd_start_schedulers(kiblnd_data.kib_scheds[cpt]);
@@ -3234,49 +3200,16 @@ kiblnd_dev_start_threads(kib_dev_t *dev, int newdev, __u32 *cpts, int ncpts)
 	return 0;
 }
 
-static kib_dev_t *
-kiblnd_dev_search(char *ifname)
-{
-	kib_dev_t	*alias = NULL;
-	kib_dev_t	*dev;
-	char		*colon;
-	char		*colon2;
-
-	colon = strchr(ifname, ':');
-	list_for_each_entry(dev, &kiblnd_data.kib_devs, ibd_list) {
-		if (strcmp(&dev->ibd_ifname[0], ifname) == 0)
-			return dev;
-
-		if (alias != NULL)
-			continue;
-
-		colon2 = strchr(dev->ibd_ifname, ':');
-		if (colon != NULL)
-			*colon = 0;
-		if (colon2 != NULL)
-			*colon2 = 0;
-
-		if (strcmp(&dev->ibd_ifname[0], ifname) == 0)
-			alias = dev;
-
-		if (colon != NULL)
-			*colon = ':';
-		if (colon2 != NULL)
-			*colon2 = ':';
-	}
-	return alias;
-}
-
 static int
 kiblnd_startup(struct lnet_ni *ni)
 {
         char                     *ifname;
+	struct lnet_inetdev *ifaces = NULL;
         kib_dev_t                *ibdev = NULL;
         kib_net_t                *net;
         unsigned long             flags;
         int                       rc;
-	int			  newdev;
-	int			  node_id;
+	int i;
 
         LASSERT (ni->ni_net->net_lnd == &the_o2iblnd);
 
@@ -3297,10 +3230,8 @@ kiblnd_startup(struct lnet_ni *ni)
 
 	if (ni->ni_interfaces[0] != NULL) {
 		/* Use the IPoIB interface specified in 'networks=' */
-
-		CLASSERT(LNET_NUM_INTERFACES > 1);
 		if (ni->ni_interfaces[1] != NULL) {
-			CERROR("Multiple interfaces not supported\n");
+			CERROR("ko2iblnd: Multiple interfaces not supported\n");
 			goto failed;
 		}
 
@@ -3314,24 +3245,51 @@ kiblnd_startup(struct lnet_ni *ni)
                 goto failed;
         }
 
-	ibdev = kiblnd_dev_search(ifname);
+	rc = lnet_inet_enumerate(&ifaces, ni->ni_net_ns);
+	if (rc < 0)
+		goto failed;
+
+	for (i = 0; i < rc; i++) {
+		if (strcmp(ifname, ifaces[i].li_name) == 0)
+			break;
+	}
+
+	if (i == rc) {
+		CERROR("ko2iblnd: No matching interfaces\n");
+		rc = -ENOENT;
+		goto failed;
+	}
+
+	LIBCFS_ALLOC(ibdev, sizeof(*ibdev));
+	if (!ibdev) {
+		rc = -ENOMEM;
+		goto failed;
+	}
+
+	ibdev->ibd_ifip = ifaces[i].li_ipaddr;
+	strlcpy(ibdev->ibd_ifname, ifaces[i].li_name,
+		sizeof(ibdev->ibd_ifname));
+	ibdev->ibd_can_failover = !!(ifaces[i].li_flags & IFF_MASTER);
 
-	newdev = ibdev == NULL;
-	/* hmm...create kib_dev even for alias */
-	if (ibdev == NULL || strcmp(&ibdev->ibd_ifname[0], ifname) != 0)
-		ibdev = kiblnd_create_dev(ifname, ni->ni_net_ns);
+	INIT_LIST_HEAD(&ibdev->ibd_nets);
+	INIT_LIST_HEAD(&ibdev->ibd_list); /* not yet in kib_devs */
+	INIT_LIST_HEAD(&ibdev->ibd_fail_list);
 
-	if (ibdev == NULL)
+	/* initialize the device */
+	rc = kiblnd_dev_failover(ibdev, ni->ni_net_ns);
+	if (rc) {
+		CERROR("ko2iblnd: Can't initialize device: rc = %d\n", rc);
 		goto failed;
+	}
 
-	node_id = dev_to_node(ibdev->ibd_hdev->ibh_ibdev->dma_device);
-	ni->ni_dev_cpt = cfs_cpt_of_node(lnet_cpt_table(), node_id);
+	list_add_tail(&ibdev->ibd_list, &kiblnd_data.kib_devs);
 
 	net->ibn_dev = ibdev;
 	ni->ni_nid = LNET_MKNID(LNET_NIDNET(ni->ni_nid), ibdev->ibd_ifip);
 
-	rc = kiblnd_dev_start_threads(ibdev, newdev,
-				      ni->ni_cpts, ni->ni_ncpts);
+	ni->ni_dev_cpt = ifaces[i].li_cpt;
+
+	rc = kiblnd_dev_start_threads(ibdev, ni->ni_cpts, ni->ni_ncpts);
 	if (rc != 0)
 		goto failed;
 
@@ -3354,6 +3312,7 @@ kiblnd_startup(struct lnet_ni *ni)
 	if (net != NULL && net->ibn_dev == NULL && ibdev != NULL)
                 kiblnd_destroy_dev(ibdev);
 
+	kfree(ifaces);
         kiblnd_shutdown(ni);
 
         CDEBUG(D_NET, "kiblnd_startup failed\n");
diff --git a/drivers/staging/lustrefsx/lnet/klnds/o2iblnd/o2iblnd.h b/drivers/staging/lustrefsx/lnet/klnds/o2iblnd/o2iblnd.h
index c7dabdf6b98b..7a9a1c3de16a 100644
--- a/drivers/staging/lustrefsx/lnet/klnds/o2iblnd/o2iblnd.h
+++ b/drivers/staging/lustrefsx/lnet/klnds/o2iblnd/o2iblnd.h
@@ -71,7 +71,9 @@
 #include <rdma/rdma_cm.h>
 #include <rdma/ib_cm.h>
 #include <rdma/ib_verbs.h>
+#ifdef HAVE_FMR_POOL_API
 #include <rdma/ib_fmr_pool.h>
+#endif
 
 #define DEBUG_SUBSYSTEM S_LND
 
@@ -334,24 +336,30 @@ typedef struct
 	struct list_head	fpo_list;	/* chain on pool list */
 	struct kib_hca_dev     *fpo_hdev;	/* device for this pool */
 	kib_fmr_poolset_t      *fpo_owner;	/* owner of this pool */
+#ifdef HAVE_FMR_POOL_API
 	union {
 		struct {
 			struct ib_fmr_pool *fpo_fmr_pool; /* IB FMR pool */
 		} fmr;
+#endif
 		struct { /* For fast registration */
 			struct list_head  fpo_pool_list;
 			int		  fpo_pool_size;
 		} fast_reg;
+#ifdef HAVE_FMR_POOL_API
 	};
+	int			fpo_is_fmr;
+#endif
 	cfs_time_t		fpo_deadline;	/* deadline of this pool */
 	int			fpo_failed;	/* fmr pool is failed */
 	int			fpo_map_count;	/* # of mapped FMR */
-	int			fpo_is_fmr;
 } kib_fmr_pool_t;
 
 typedef struct {
 	kib_fmr_pool_t			*fmr_pool;	/* pool of FMR */
+#ifdef HAVE_FMR_POOL_API
 	struct ib_pool_fmr		*fmr_pfmr;	/* IB pool fmr */
+#endif /* HAVE_FMR_POOL_API */
 	struct kib_fast_reg_descriptor	*fmr_frd;
 	u32				 fmr_key;
 } kib_fmr_t;
diff --git a/drivers/staging/lustrefsx/lnet/klnds/o2iblnd/o2iblnd_cb.c b/drivers/staging/lustrefsx/lnet/klnds/o2iblnd/o2iblnd_cb.c
index a27a83748c37..707cb1510455 100644
--- a/drivers/staging/lustrefsx/lnet/klnds/o2iblnd/o2iblnd_cb.c
+++ b/drivers/staging/lustrefsx/lnet/klnds/o2iblnd/o2iblnd_cb.c
@@ -580,7 +580,11 @@ kiblnd_fmr_map_tx(kib_net_t *net, kib_tx_t *tx, kib_rdma_desc_t *rd, __u32 nob)
 static void
 kiblnd_unmap_tx(kib_tx_t *tx)
 {
-	if (tx->fmr.fmr_pfmr || tx->fmr.fmr_frd)
+	if (
+#ifdef HAVE_FMR_POOL_API
+		tx->fmr.fmr_pfmr ||
+#endif
+		tx->fmr.fmr_frd)
 		kiblnd_fmr_pool_unmap(&tx->fmr, tx->tx_status);
 
 	if (tx->tx_nfrags != 0) {
diff --git a/drivers/staging/lustrefsx/lnet/klnds/socklnd/socklnd.c b/drivers/staging/lustrefsx/lnet/klnds/socklnd/socklnd.c
index 541504ba88d1..d0b875614358 100644
--- a/drivers/staging/lustrefsx/lnet/klnds/socklnd/socklnd.c
+++ b/drivers/staging/lustrefsx/lnet/klnds/socklnd/socklnd.c
@@ -37,8 +37,8 @@
  * Author: Eric Barton <eric@bartonsoftware.com>
  */
 
-#include <linux/pci.h>
 #include "socklnd.h"
+#include <linux/inetdevice.h>
 
 static struct lnet_lnd the_ksocklnd;
 ksock_nal_data_t        ksocknal_data;
@@ -2620,63 +2620,6 @@ ksocknal_shutdown(struct lnet_ni *ni)
                 ksocknal_base_shutdown();
 }
 
-static int
-ksocknal_enumerate_interfaces(ksock_net_t *net, struct net *ns)
-{
-        char      **names;
-        int         i;
-        int         j;
-        int         rc;
-        int         n;
-
-	n = lnet_ipif_enumerate(&names, ns);
-        if (n <= 0) {
-                CERROR("Can't enumerate interfaces: %d\n", n);
-                return n;
-        }
-
-        for (i = j = 0; i < n; i++) {
-                int        up;
-                __u32      ip;
-                __u32      mask;
-
-                if (!strcmp(names[i], "lo")) /* skip the loopback IF */
-                        continue;
-
-		rc = lnet_ipif_query(names[i], &up, &ip, &mask, ns);
-                if (rc != 0) {
-                        CWARN("Can't get interface %s info: %d\n",
-                              names[i], rc);
-                        continue;
-                }
-
-                if (!up) {
-                        CWARN("Ignoring interface %s (down)\n",
-                              names[i]);
-                        continue;
-                }
-
-		if (j == LNET_NUM_INTERFACES) {
-			CWARN("Ignoring interface %s (too many interfaces)\n",
-			      names[i]);
-			continue;
-		}
-
-                net->ksnn_interfaces[j].ksni_ipaddr = ip;
-                net->ksnn_interfaces[j].ksni_netmask = mask;
-		strlcpy(net->ksnn_interfaces[j].ksni_name,
-			names[i], sizeof(net->ksnn_interfaces[j].ksni_name));
-                j++;
-        }
-
-	lnet_ipif_free_enumeration(names, n);
-
-        if (j == 0)
-                CERROR("Can't find any usable interfaces\n");
-
-        return j;
-}
-
 static int
 ksocknal_search_new_ipif(ksock_net_t *net)
 {
@@ -2796,10 +2739,10 @@ int
 ksocknal_startup(struct lnet_ni *ni)
 {
 	ksock_net_t  *net;
-	int           rc;
-	int           i;
-	struct net_device *net_dev;
-	int node_id;
+	ksock_interface_t *ksi = NULL;
+	struct lnet_inetdev *ifaces = NULL;
+	int i = 0;
+	int rc;
 
         LASSERT (ni->ni_net->net_lnd == &the_ksocklnd);
 
@@ -2829,52 +2772,69 @@ ksocknal_startup(struct lnet_ni *ni)
 	}
 
 
-	if (ni->ni_interfaces[0] == NULL) {
-		rc = ksocknal_enumerate_interfaces(net, ni->ni_net_ns);
-		if (rc <= 0)
-			goto fail_1;
+	rc = lnet_inet_enumerate(&ifaces, ni->ni_net_ns);
+	if (rc < 0)
+		goto fail_1;
 
+	if (!ni->ni_interfaces[0]) {
+		ksi = &net->ksnn_interfaces[0];
+
+		/* Use the first discovered interface */
 		net->ksnn_ninterfaces = 1;
+		ni->ni_dev_cpt = ifaces[0].li_cpt;
+		ksi->ksni_ipaddr = ifaces[0].li_ipaddr;
+		ksi->ksni_netmask = ifaces[0].li_netmask;
+		strlcpy(ksi->ksni_name, ifaces[0].li_name,
+			sizeof(ksi->ksni_name));
 	} else {
+		/* Before Multi-Rail ksocklnd would manage
+		 * multiple interfaces with its own tcp bonding.
+		 * If we encounter an old configuration using
+		 * this tcp bonding approach then we need to
+		 * handle more than one ni_interfaces.
+		 *
+		 * In Multi-Rail configuration only ONE ni_interface
+		 * should exist. Each IP alias should be mapped to
+		 * each 'struct net_ni'.
+		 */
 		for (i = 0; i < LNET_NUM_INTERFACES; i++) {
-			int up;
+			int j;
 
-			if (ni->ni_interfaces[i] == NULL)
+			if (!ni->ni_interfaces[i])
 				break;
 
-			rc = lnet_ipif_query(ni->ni_interfaces[i], &up,
-				&net->ksnn_interfaces[i].ksni_ipaddr,
-				&net->ksnn_interfaces[i].ksni_netmask,
-				ni->ni_net_ns);
-
-			if (rc != 0) {
-				CERROR("Can't get interface %s info: %d\n",
-				       ni->ni_interfaces[i], rc);
-				goto fail_1;
-			}
-
-			if (!up) {
-				CERROR("Interface %s is down\n",
-				       ni->ni_interfaces[i]);
-				goto fail_1;
+			for (j = 0; j < LNET_NUM_INTERFACES;  j++) {
+				if (i != j && ni->ni_interfaces[j] &&
+				    strcmp(ni->ni_interfaces[i],
+					   ni->ni_interfaces[j]) == 0) {
+					rc = -EEXIST;
+					CERROR("ksocklnd: found duplicate %s at %d and %d, rc = %d\n",
+					       ni->ni_interfaces[i], i, j, rc);
+					goto fail_1;
+				}
 			}
 
-			strlcpy(net->ksnn_interfaces[i].ksni_name,
-				ni->ni_interfaces[i],
-				sizeof(net->ksnn_interfaces[i].ksni_name));
+			for (j = 0; j < rc; j++) {
+				if (strcmp(ifaces[j].li_name,
+					   ni->ni_interfaces[i]) != 0)
+					continue;
 
+				ksi = &net->ksnn_interfaces[j];
+				ni->ni_dev_cpt = ifaces[j].li_cpt;
+				ksi->ksni_ipaddr = ifaces[j].li_ipaddr;
+				ksi->ksni_netmask = ifaces[j].li_netmask;
+				strlcpy(ksi->ksni_name, ifaces[j].li_name,
+					sizeof(ksi->ksni_name));
+				net->ksnn_ninterfaces++;
+				break;
+			}
+		}
+		/* ni_interfaces don't map to all network interfaces */
+		if (!ksi || net->ksnn_ninterfaces != i) {
+			CERROR("ksocklnd: requested %d but only %d interfaces found\n",
+			       i, net->ksnn_ninterfaces);
+			goto fail_1;
 		}
-		net->ksnn_ninterfaces = i;
-	}
-
-	net_dev = dev_get_by_name(ni->ni_net_ns,
-				  net->ksnn_interfaces[0].ksni_name);
-	if (net_dev != NULL) {
-		node_id = dev_to_node(&net_dev->dev);
-		ni->ni_dev_cpt = cfs_cpt_of_node(lnet_cpt_table(), node_id);
-		dev_put(net_dev);
-	} else {
-		ni->ni_dev_cpt = CFS_CPT_ANY;
 	}
 
 	/* call it before add it to ksocknal_data.ksnd_nets */
@@ -2882,8 +2842,8 @@ ksocknal_startup(struct lnet_ni *ni)
 	if (rc != 0)
 		goto fail_1;
 
-	ni->ni_nid = LNET_MKNID(LNET_NIDNET(ni->ni_nid),
-				net->ksnn_interfaces[0].ksni_ipaddr);
+	LASSERT(ksi);
+	ni->ni_nid = LNET_MKNID(LNET_NIDNET(ni->ni_nid), ksi->ksni_ipaddr);
 	list_add(&net->ksnn_list, &ksocknal_data.ksnd_nets);
 
         ksocknal_data.ksnd_nnets++;
diff --git a/drivers/staging/lustrefsx/lnet/klnds/socklnd/socklnd.h b/drivers/staging/lustrefsx/lnet/klnds/socklnd/socklnd.h
index 4668fc162ba3..12d6cb83ef4a 100644
--- a/drivers/staging/lustrefsx/lnet/klnds/socklnd/socklnd.h
+++ b/drivers/staging/lustrefsx/lnet/klnds/socklnd/socklnd.h
@@ -55,6 +55,8 @@
 #include <lnet/lib-lnet.h>
 #include <lnet/socklnd.h>
 
+#include <libcfs/linux/linux-net.h>
+
 #ifdef HAVE_TCP_SENDPAGE_USE_SOCKET
 # define cfs_tcp_sendpage(sk, page, offset, size, flags) \
 	tcp_sendpage((sk)->sk_socket, page, offset, size, flags)
diff --git a/drivers/staging/lustrefsx/lnet/klnds/socklnd/socklnd_lib.c b/drivers/staging/lustrefsx/lnet/klnds/socklnd/socklnd_lib.c
index b72bf1954130..91a9cf05e2ad 100644
--- a/drivers/staging/lustrefsx/lnet/klnds/socklnd/socklnd_lib.c
+++ b/drivers/staging/lustrefsx/lnet/klnds/socklnd/socklnd_lib.c
@@ -183,16 +183,14 @@ ksocknal_lib_send_kiov(ksock_conn_t *conn, ksock_tx_t *tx)
 void
 ksocknal_lib_eager_ack (ksock_conn_t *conn)
 {
-        int            opt = 1;
-        struct socket *sock = conn->ksnc_sock;
+	struct socket *sock = conn->ksnc_sock;
 
-        /* Remind the socket to ACK eagerly.  If I don't, the socket might
-         * think I'm about to send something it could piggy-back the ACK
-         * on, introducing delay in completing zero-copy sends in my
-         * peer_ni. */
+	/* Remind the socket to ACK eagerly.  If I don't, the socket might
+	 * think I'm about to send something it could piggy-back the ACK on,
+	 * introducing delay in completing zero-copy sends in my peer_ni.
+	 */
 
-	kernel_setsockopt(sock, SOL_TCP, TCP_QUICKACK,
-			  (char *)&opt, sizeof(opt));
+	tcp_sock_set_quickack(sock->sk, 1);
 }
 
 int
@@ -421,162 +419,132 @@ ksocknal_lib_csum_tx(ksock_tx_t *tx)
 int
 ksocknal_lib_get_conn_tunables (ksock_conn_t *conn, int *txmem, int *rxmem, int *nagle)
 {
-        struct socket *sock = conn->ksnc_sock;
-        int            len;
-        int            rc;
+	struct socket *sock = conn->ksnc_sock;
+	struct tcp_sock *tp = tcp_sk(sock->sk);
+
+	if (ksocknal_connsock_addref(conn) < 0) {
+		LASSERT(conn->ksnc_closing);
+		*txmem = 0;
+		*rxmem = 0;
+		*nagle = 0;
+		return -ESHUTDOWN;
+	}
 
-        rc = ksocknal_connsock_addref(conn);
-        if (rc != 0) {
-                LASSERT (conn->ksnc_closing);
-                *txmem = *rxmem = *nagle = 0;
-                return (-ESHUTDOWN);
-        }
+	lnet_sock_getbuf(sock, txmem, rxmem);
 
-	rc = lnet_sock_getbuf(sock, txmem, rxmem);
-        if (rc == 0) {
-                len = sizeof(*nagle);
-		rc = sock->ops->getsockopt(sock, SOL_TCP, TCP_NODELAY,
-					   (char *)nagle, &len);
-        }
+	*nagle = !(tp->nonagle & TCP_NAGLE_OFF);
 
-        ksocknal_connsock_decref(conn);
+	ksocknal_connsock_decref(conn);
 
-        if (rc == 0)
-                *nagle = !*nagle;
-        else
-                *txmem = *rxmem = *nagle = 0;
 
-        return (rc);
+	return 0;
 }
 
 int
 ksocknal_lib_setup_sock (struct socket *sock)
 {
-        int             rc;
-        int             option;
-        int             keep_idle;
-        int             keep_intvl;
-        int             keep_count;
-        int             do_keepalive;
-        struct linger   linger;
+	int rc;
+	int keep_idle;
+	int keep_intvl;
+	int keep_count;
+	int do_keepalive;
+	struct tcp_sock *tp = tcp_sk(sock->sk);
 
-        sock->sk->sk_allocation = GFP_NOFS;
+	sock->sk->sk_allocation = GFP_NOFS;
 
-        /* Ensure this socket aborts active sends immediately when we close
-         * it. */
+	/* Ensure this socket aborts active sends immediately when closed. */
+	sock_reset_flag(sock->sk, SOCK_LINGER);
 
-        linger.l_onoff = 0;
-        linger.l_linger = 0;
+	tp->linger2 = -1;
 
-	rc = kernel_setsockopt(sock, SOL_SOCKET, SO_LINGER,
-			       (char *)&linger, sizeof(linger));
-        if (rc != 0) {
-                CERROR ("Can't set SO_LINGER: %d\n", rc);
-                return (rc);
-        }
+	if (!*ksocknal_tunables.ksnd_nagle)
+		tcp_sock_set_nodelay(sock->sk);
 
-        option = -1;
-	rc = kernel_setsockopt(sock, SOL_TCP, TCP_LINGER2,
-			       (char *)&option, sizeof(option));
-        if (rc != 0) {
-                CERROR ("Can't set SO_LINGER2: %d\n", rc);
-                return (rc);
-        }
-
-        if (!*ksocknal_tunables.ksnd_nagle) {
-                option = 1;
-
-		rc = kernel_setsockopt(sock, SOL_TCP, TCP_NODELAY,
-				       (char *)&option, sizeof(option));
-                if (rc != 0) {
-                        CERROR ("Can't disable nagle: %d\n", rc);
-                        return (rc);
-                }
-        }
-
-	rc = lnet_sock_setbuf(sock,
-			      *ksocknal_tunables.ksnd_tx_buffer_size,
-			      *ksocknal_tunables.ksnd_rx_buffer_size);
-        if (rc != 0) {
-                CERROR ("Can't set buffer tx %d, rx %d buffers: %d\n",
-                        *ksocknal_tunables.ksnd_tx_buffer_size,
-                        *ksocknal_tunables.ksnd_rx_buffer_size, rc);
-                return (rc);
-        }
+	lnet_sock_setbuf(sock,
+			 *ksocknal_tunables.ksnd_tx_buffer_size,
+			 *ksocknal_tunables.ksnd_rx_buffer_size);
 
 /* TCP_BACKOFF_* sockopt tunables unsupported in stock kernels */
 #ifdef SOCKNAL_BACKOFF
-        if (*ksocknal_tunables.ksnd_backoff_init > 0) {
-                option = *ksocknal_tunables.ksnd_backoff_init;
+	if (*ksocknal_tunables.ksnd_backoff_init > 0) {
+		int option = *ksocknal_tunables.ksnd_backoff_init;
 #ifdef SOCKNAL_BACKOFF_MS
-                option *= 1000;
+		option *= 1000;
 #endif
 
 		rc = kernel_setsockopt(sock, SOL_TCP, TCP_BACKOFF_INIT,
 				       (char *)&option, sizeof(option));
-                if (rc != 0) {
-                        CERROR ("Can't set initial tcp backoff %d: %d\n",
-                                option, rc);
-                        return (rc);
-                }
-        }
+		if (rc != 0) {
+			CERROR("Can't set initial tcp backoff %d: %d\n",
+			       option, rc);
+			return rc;
+		}
+	}
 
-        if (*ksocknal_tunables.ksnd_backoff_max > 0) {
-                option = *ksocknal_tunables.ksnd_backoff_max;
+	if (*ksocknal_tunables.ksnd_backoff_max > 0) {
+		int option = *ksocknal_tunables.ksnd_backoff_max;
 #ifdef SOCKNAL_BACKOFF_MS
-                option *= 1000;
+		option *= 1000;
 #endif
 
 		rc = kernel_setsockopt(sock, SOL_TCP, TCP_BACKOFF_MAX,
 				       (char *)&option, sizeof(option));
-                if (rc != 0) {
-                        CERROR ("Can't set maximum tcp backoff %d: %d\n",
-                                option, rc);
-                        return (rc);
-                }
-        }
+		if (rc != 0) {
+			CERROR("Can't set maximum tcp backoff %d: %d\n",
+			       option, rc);
+			return rc;
+		}
+	}
 #endif
 
-        /* snapshot tunables */
-        keep_idle  = *ksocknal_tunables.ksnd_keepalive_idle;
-        keep_count = *ksocknal_tunables.ksnd_keepalive_count;
-        keep_intvl = *ksocknal_tunables.ksnd_keepalive_intvl;
+	/* snapshot tunables */
+	keep_idle  = *ksocknal_tunables.ksnd_keepalive_idle;
+	keep_count = *ksocknal_tunables.ksnd_keepalive_count;
+	keep_intvl = *ksocknal_tunables.ksnd_keepalive_intvl;
 
-        do_keepalive = (keep_idle > 0 && keep_count > 0 && keep_intvl > 0);
+	do_keepalive = (keep_idle > 0 && keep_count > 0 && keep_intvl > 0);
 
-        option = (do_keepalive ? 1 : 0);
-	rc = kernel_setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE,
-			       (char *)&option, sizeof(option));
-        if (rc != 0) {
-                CERROR ("Can't set SO_KEEPALIVE: %d\n", rc);
-                return (rc);
-        }
-
-        if (!do_keepalive)
-                return (0);
-
-	rc = kernel_setsockopt(sock, SOL_TCP, TCP_KEEPIDLE,
-			       (char *)&keep_idle, sizeof(keep_idle));
-        if (rc != 0) {
-                CERROR ("Can't set TCP_KEEPIDLE: %d\n", rc);
-                return (rc);
-        }
+#ifdef HAVE_KERNEL_SETSOCKOPT
+	/* open-coded version doesn't work in all kernels, and
+	 * there is no helper function, so call kernel_setsockopt()
+	 * directly.
+	 */
+	{
+		int option = (do_keepalive ? 1 : 0);
+		kernel_setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE,
+				  (char *)&option, sizeof(option));
+	}
+#else
+	if (sock->sk->sk_prot->keepalive)
+		sock->sk->sk_prot->keepalive(sock->sk, do_keepalive);
+	if (do_keepalive)
+		sock_set_flag(sock->sk, SOCK_KEEPOPEN);
+	else
+		sock_reset_flag(sock->sk, SOCK_KEEPOPEN);
+#endif /* HAVE_KERNEL_SETSOCKOPT */
+
+	if (!do_keepalive)
+		return (0);
+
+	rc = tcp_sock_set_keepidle(sock->sk, keep_idle);
+	if (rc != 0) {
+		CERROR("Can't set TCP_KEEPIDLE: %d\n", rc);
+		return rc;
+	}
 
-	rc = kernel_setsockopt(sock, SOL_TCP, TCP_KEEPINTVL,
-			       (char *)&keep_intvl, sizeof(keep_intvl));
-        if (rc != 0) {
-                CERROR ("Can't set TCP_KEEPINTVL: %d\n", rc);
-                return (rc);
-        }
+	rc = tcp_sock_set_keepintvl(sock->sk, keep_intvl);
+	if (rc != 0) {
+		CERROR("Can't set TCP_KEEPINTVL: %d\n", rc);
+		return rc;
+	}
 
-	rc = kernel_setsockopt(sock, SOL_TCP, TCP_KEEPCNT,
-			       (char *)&keep_count, sizeof(keep_count));
-        if (rc != 0) {
-                CERROR ("Can't set TCP_KEEPCNT: %d\n", rc);
-                return (rc);
-        }
+	rc = tcp_sock_set_keepcnt(sock->sk, keep_count);
+	if (rc != 0) {
+		CERROR("Can't set TCP_KEEPCNT: %d\n", rc);
+		return rc;
+	}
 
-        return (0);
+	return (0);
 }
 
 void
@@ -585,30 +553,27 @@ ksocknal_lib_push_conn (ksock_conn_t *conn)
         struct sock    *sk;
         struct tcp_sock *tp;
         int             nonagle;
-        int             val = 1;
         int             rc;
 
-        rc = ksocknal_connsock_addref(conn);
-        if (rc != 0)                            /* being shut down */
-                return;
+	rc = ksocknal_connsock_addref(conn);
+	if (rc != 0)                            /* being shut down */
+		return;
 
 	sk = conn->ksnc_sock->sk;
 	tp = tcp_sk(sk);
 
-        lock_sock (sk);
-        nonagle = tp->nonagle;
-        tp->nonagle = 1;
-        release_sock (sk);
+	lock_sock(sk);
+	nonagle = tp->nonagle;
+	tp->nonagle = TCP_NAGLE_OFF;
+	release_sock(sk);
 
-	rc = kernel_setsockopt(conn->ksnc_sock, SOL_TCP, TCP_NODELAY,
-			       (char *)&val, sizeof(val));
-        LASSERT (rc == 0);
+	tcp_sock_set_nodelay(conn->ksnc_sock->sk);
 
-        lock_sock (sk);
-        tp->nonagle = nonagle;
-        release_sock (sk);
+	lock_sock(sk);
+	tp->nonagle = nonagle;
+	release_sock(sk);
 
-        ksocknal_connsock_decref(conn);
+	ksocknal_connsock_decref(conn);
 }
 
 extern void ksocknal_read_callback (ksock_conn_t *conn);
diff --git a/drivers/staging/lustrefsx/lnet/lnet/config.c b/drivers/staging/lustrefsx/lnet/lnet/config.c
index 8b790353c60a..2f90e90849ac 100644
--- a/drivers/staging/lustrefsx/lnet/lnet/config.c
+++ b/drivers/staging/lustrefsx/lnet/lnet/config.c
@@ -31,6 +31,8 @@
  */
 
 #define DEBUG_SUBSYSTEM S_LNET
+
+#include <linux/inetdevice.h>
 #include <linux/nsproxy.h>
 #include <net/net_namespace.h>
 #include <lnet/lib-lnet.h>
@@ -1599,113 +1601,136 @@ lnet_match_networks (char **networksp, char *ip2nets, __u32 *ipaddrs, int nip)
 	*networksp = networks;
 	return count;
 }
-
-static void
-lnet_ipaddr_free_enumeration(__u32 *ipaddrs, int nip)
-{
-	LIBCFS_FREE(ipaddrs, nip * sizeof(*ipaddrs));
-}
-
-static int
-lnet_ipaddr_enumerate(__u32 **ipaddrsp, struct net *ns)
+/*
+ * kernel 5.3: commit ef11db3310e272d3d8dbe8739e0770820dd20e52
+ * added in_dev_for_each_ifa_rtnl and in_dev_for_each_ifa_rcu
+ * and removed for_ifa and endfor_ifa.
+ * Use the _rntl variant as the current locking is rtnl.
+ */
+#ifdef in_dev_for_each_ifa_rtnl
+#define DECLARE_CONST_IN_IFADDR(ifa)		const struct in_ifaddr *ifa
+#define endfor_ifa(in_dev)
+#else
+#define DECLARE_CONST_IN_IFADDR(ifa)
+#define in_dev_for_each_ifa_rtnl(ifa, in_dev)	for_ifa((in_dev))
+#endif
+
+int lnet_inet_enumerate(struct lnet_inetdev **dev_list, struct net *ns)
 {
-	int	   up;
-	__u32	   netmask;
-	__u32	  *ipaddrs;
-	__u32	  *ipaddrs2;
-	int	   nip;
-	char	 **ifnames;
-	int	   nif = lnet_ipif_enumerate(&ifnames, ns);
-	int	   i;
-	int	   rc;
-
-	if (nif <= 0)
-		return nif;
-
-	LIBCFS_ALLOC(ipaddrs, nif * sizeof(*ipaddrs));
-	if (ipaddrs == NULL) {
-		CERROR("Can't allocate ipaddrs[%d]\n", nif);
-		lnet_ipif_free_enumeration(ifnames, nif);
-		return -ENOMEM;
-	}
-
-	for (i = nip = 0; i < nif; i++) {
-		if (!strcmp(ifnames[i], "lo"))
+	struct lnet_inetdev *ifaces = NULL;
+	struct net_device *dev;
+	int nalloc = 0;
+	int nip = 0;
+	DECLARE_CONST_IN_IFADDR(ifa);
+
+	rtnl_lock();
+	for_each_netdev(ns, dev) {
+		int flags = dev_get_flags(dev);
+		struct in_device *in_dev;
+		int node_id;
+		int cpt;
+
+		if (flags & IFF_LOOPBACK) /* skip the loopback IF */
 			continue;
 
-		rc = lnet_ipif_query(ifnames[i], &up,
-				       &ipaddrs[nip], &netmask, ns);
-		if (rc != 0) {
-			CWARN("Can't query interface %s: %d\n",
-			      ifnames[i], rc);
+		if (!(flags & IFF_UP)) {
+			CWARN("lnet: Ignoring interface %s: it's down\n",
+			      dev->name);
 			continue;
 		}
 
-		if (!up) {
-			CWARN("Ignoring interface %s: it's down\n",
-			      ifnames[i]);
+		in_dev = __in_dev_get_rtnl(dev);
+		if (!in_dev) {
+			CWARN("lnet: Interface %s has no IPv4 status.\n",
+			      dev->name);
 			continue;
 		}
 
-		nip++;
-	}
-
-	lnet_ipif_free_enumeration(ifnames, nif);
-
-	if (nip == nif) {
-		*ipaddrsp = ipaddrs;
-	} else {
-		if (nip > 0) {
-			LIBCFS_ALLOC(ipaddrs2, nip * sizeof(*ipaddrs2));
-			if (ipaddrs2 == NULL) {
-				CERROR("Can't allocate ipaddrs[%d]\n", nip);
-				nip = -ENOMEM;
-			} else {
-				memcpy(ipaddrs2, ipaddrs,
-					nip * sizeof(*ipaddrs));
-				*ipaddrsp = ipaddrs2;
-				rc = nip;
+		node_id = dev_to_node(&dev->dev);
+		cpt = cfs_cpt_of_node(lnet_cpt_table(), node_id);
+
+		in_dev_for_each_ifa_rtnl(ifa, in_dev) {
+			if (nip >= nalloc) {
+				struct lnet_inetdev *tmp;
+
+				nalloc += LNET_NUM_INTERFACES;
+				tmp = krealloc(ifaces, nalloc * sizeof(*tmp),
+					       GFP_KERNEL);
+				if (!tmp) {
+					kfree(ifaces);
+					ifaces = NULL;
+					nip = -ENOMEM;
+					goto unlock_rtnl;
+				}
+				ifaces = tmp;
 			}
+
+			ifaces[nip].li_cpt = cpt;
+			ifaces[nip].li_flags = flags;
+			ifaces[nip].li_ipaddr = ntohl(ifa->ifa_local);
+			ifaces[nip].li_netmask = ntohl(ifa->ifa_mask);
+			strlcpy(ifaces[nip].li_name, ifa->ifa_label,
+				sizeof(ifaces[nip].li_name));
+			nip++;
 		}
-		lnet_ipaddr_free_enumeration(ipaddrs, nif);
+		endfor_ifa(in_dev);
+	}
+unlock_rtnl:
+	rtnl_unlock();
+
+	if (nip == 0) {
+		CERROR("lnet: Can't find any usable interfaces, rc = -ENOENT\n");
+		nip = -ENOENT;
 	}
+
+	*dev_list = ifaces;
 	return nip;
 }
+EXPORT_SYMBOL(lnet_inet_enumerate);
 
 int
 lnet_parse_ip2nets (char **networksp, char *ip2nets)
 {
+	struct lnet_inetdev *ifaces = NULL;
 	__u32	  *ipaddrs = NULL;
-	int	   nip;
+	int nip;
 	int	   rc;
+	int i;
 
-	nip = lnet_ipaddr_enumerate(&ipaddrs, current->nsproxy->net_ns);
-
+	nip = lnet_inet_enumerate(&ifaces, current->nsproxy->net_ns);
 	if (nip < 0) {
-		LCONSOLE_ERROR_MSG(0x117, "Error %d enumerating local IP "
-				   "interfaces for ip2nets to match\n", nip);
+		if (nip != -ENOENT) {
+			LCONSOLE_ERROR_MSG(0x117,
+					   "Error %d enumerating local IP interfaces for ip2nets to match\n",
+					   nip);
+		} else {
+			LCONSOLE_ERROR_MSG(0x118,
+					   "No local IP interfaces for ip2nets to match\n");
+		}
 		return nip;
 	}
 
-	if (nip == 0) {
-		LCONSOLE_ERROR_MSG(0x118, "No local IP interfaces "
-				   "for ip2nets to match\n");
-		return -ENOENT;
+	LIBCFS_ALLOC(ipaddrs, nip * sizeof(*ipaddrs));
+	if (!ipaddrs) {
+		rc = -ENOMEM;
+		CERROR("lnet: Can't allocate ipaddrs[%d], rc = %d\n",
+		       nip, rc);
+		goto out_free_addrs;
 	}
 
-	rc = lnet_match_networks(networksp, ip2nets, ipaddrs, nip);
-	lnet_ipaddr_free_enumeration(ipaddrs, nip);
+	for (i = 0; i < nip; i++)
+		ipaddrs[i] = ifaces[i].li_ipaddr;
 
+	rc = lnet_match_networks(networksp, ip2nets, ipaddrs, nip);
 	if (rc < 0) {
 		LCONSOLE_ERROR_MSG(0x119, "Error %d parsing ip2nets\n", rc);
-		return rc;
-	}
-
-	if (rc == 0) {
+	} else if (rc == 0) {
 		LCONSOLE_ERROR_MSG(0x11a, "ip2nets does not match "
 				   "any local IP interfaces\n");
-		return -ENOENT;
+		rc = -ENOENT;
 	}
-
-	return 0;
+	LIBCFS_FREE(ipaddrs, nip * sizeof(*ipaddrs));
+out_free_addrs:
+	kfree(ifaces);
+	return rc > 0 ? 0 : rc;
 }
diff --git a/drivers/staging/lustrefsx/lnet/lnet/lib-socket.c b/drivers/staging/lustrefsx/lnet/lnet/lib-socket.c
index b01cdd55193a..973587a2a1dc 100644
--- a/drivers/staging/lustrefsx/lnet/lnet/lib-socket.c
+++ b/drivers/staging/lustrefsx/lnet/lnet/lib-socket.c
@@ -40,26 +40,30 @@
 #include <linux/syscalls.h>
 #include <net/sock.h>
 
+#include <libcfs/linux/linux-net.h>
 #include <libcfs/libcfs.h>
+#include <libcfs/linux/linux-time.h>
 #include <lnet/lib-lnet.h>
 
-#include <linux/inetdevice.h>
-
-#ifndef HAVE_KERNEL_SETSOCKOPT
-int kernel_setsockopt(struct socket *sock, int level, int optname,
-			char *val, unsigned int optlen)
-{
-	sockptr_t optval = KERNEL_SOCKPTR(val);
-	int err;
+/*
+ * kernel 5.1: commit 7f1bc6e95d7840d4305595b3e4025cddda88cee5
+ * Y2038 64-bit time.
+ *  SO_TIMESTAMP, SO_TIMESTAMPNS and SO_TIMESTAMPING options, the
+ *  way they are currently defined, are not y2038 safe.
+ *  Subsequent patches in the series add new y2038 safe versions
+ *  of these options which provide 64 bit timestamps on all
+ *  architectures uniformly.
+ *  Hence, rename existing options with OLD tag suffixes.
+ *
+ * NOTE: When updating to timespec64 change change these to '_NEW'.
+ *
+ */
+#ifndef SO_SNDTIMEO
+#define SO_SNDTIMEO SO_SNDTIMEO_OLD
+#endif
 
-	if (level == SOL_SOCKET)
-		err = sock_setsockopt(sock, level, optname, optval, optlen);
-	else
-		err = sock->ops->setsockopt(sock, level, optname, optval,
-					    optlen);
-	return err;
-}
-EXPORT_SYMBOL(kernel_setsockopt);
+#ifndef SO_RCVTIMEO
+#define SO_RCVTIMEO SO_RCVTIMEO_OLD
 #endif
 
 static int
@@ -76,164 +80,11 @@ lnet_sock_create_kern(struct socket **sock, struct net *ns)
 	return rc;
 }
 
-int
-lnet_ipif_query(char *name, int *up, __u32 *ip, __u32 *mask, struct net *ns)
-{
-	struct net_device *dev;
-	struct in_device *in_dev;
-	const struct in_ifaddr *ifa;
-	unsigned int flags;
-	char *colon, *ifname;
-	int ret;
-	size_t slen;
-
-	/*
-	 * Copy the interface name, since we may be about to modify it.
-	 */
-	slen = strlen(name) + 1;
-	ifname = kzalloc(slen, GFP_KERNEL);
-	if (ifname == NULL)
-		return -ENOMEM;
-
-	memcpy(ifname, name, slen);
-	colon = strchr(ifname, ':');
-	if (colon)
-		*colon = 0;
-
-	dev_load(ns, ifname);
-	ret = -ENODEV;
-
-	rtnl_lock();
-
-	dev = __dev_get_by_name(ns, ifname);
-
-	if (colon)
-		*colon = ':';
-
-	if (dev == NULL) {
-		CERROR("Can't find interface %s\n", name);
-		goto out;
-	}
-
-	flags = dev_get_flags(dev);
-	if ((flags & IFF_UP) == 0) {
-		CDEBUG(D_NET, "Interface %s down\n", name);
-		*up = 0;
-		*ip = *mask = 0;
-		ret = 0;
-		goto out;
-	}
-
-	/*
-	 * Only support IPv4, so just walk the list of IPv4 assigned
-	 * addresses to a device.
-	 */
-	in_dev = __in_dev_get_rtnl(dev);
-
-	in_dev_for_each_ifa_rtnl(ifa, in_dev) {
-		if (!strcmp(ifa->ifa_label, ifname))
-			break;
-	}
-
-	if (ifa != NULL) {
-		*up = 1;
-		*mask = ntohl(ifa->ifa_mask);
-		*ip = ntohl(ifa->ifa_local);
-		ret = 0;
-	} else {
-		CERROR("Can't get mask/ip for interface %s\n", name);
-	}
-
-out:
-	rtnl_unlock();
-	kfree(ifname);
-	return ret;
-}
-EXPORT_SYMBOL(lnet_ipif_query);
-
-void
-lnet_ipif_free_enumeration(char **names, int n)
-{
-	LIBCFS_FREE(names, PAGE_SIZE / IFNAMSIZ);
-	LIBCFS_FREE(names[0], PAGE_SIZE);
-}
-EXPORT_SYMBOL(lnet_ipif_free_enumeration);
-
-int
-lnet_ipif_enumerate(char ***namesp, struct net *ns)
-{
-	char **names;
-	char *space;
-	const struct in_ifaddr *ifa;
-	struct net_device *dev;
-	struct in_device *in_dev;
-	int maxifs, nifs, toobig;
-	size_t used, slen;
-
-	maxifs = PAGE_SIZE / IFNAMSIZ;
-	nifs = 0;
-	used = 0;
-	toobig = 0;
-
-	/*
-	 * For simplicity, just allocate the maximum number of names
-	 * that can be dealt with. The free function will ignore the
-	 * arg
-	 */
-	LIBCFS_ALLOC(names, maxifs * sizeof (*names));
-	if (names == NULL)
-		return -ENOMEM;
-
-	LIBCFS_ALLOC(space, PAGE_SIZE);
-	if (space == NULL) {
-		LIBCFS_FREE(names, maxifs * sizeof (*names));
-		return -ENOMEM;
-	}
-
-	/*
-	 * Only IPv4 is supported, so just loop all network
-	 * devices, and loop the IPv4 interfaces (addresses)
-	 * assigned to each device.
-	 */
-	rtnl_lock();
-	for_each_netdev(ns, dev) {
-		in_dev = __in_dev_get_rtnl(dev);
-		if (!in_dev)
-			continue;
-
-		in_dev_for_each_ifa_rtnl(ifa, in_dev) {
-			nifs++;
-			if (toobig)
-				continue;
-
-			if (nifs > maxifs) {
-				toobig = 1;
-				continue;
-			}
-
-			slen = strlen(ifa->ifa_label) + 1;
-			if (used + slen > PAGE_SIZE) {
-				toobig = 1;
-				continue;
-			}
-			memcpy(space + used, ifa->ifa_label, slen);
-			names[nifs - 1] = space + used;
-			used += slen;
-		}
-	}
-	rtnl_unlock();
-
-	*namesp = names;
-
-	return nifs;
-}
-EXPORT_SYMBOL(lnet_ipif_enumerate);
-
 int
 lnet_sock_write(struct socket *sock, void *buffer, int nob, int timeout)
 {
 	int rc;
-	long jiffies_left = cfs_time_seconds(timeout);
+	long jiffies_left = timeout * msecs_to_jiffies(MSEC_PER_SEC);
 	unsigned long then;
 
 	LASSERT(nob > 0);
@@ -252,6 +103,7 @@ lnet_sock_write(struct socket *sock, void *buffer, int nob, int timeout)
 		if (timeout != 0) {
 			struct sock *sk = sock->sk;
 
+			/* Set send timeout to remaining time */
 			lock_sock(sk);
 			sk->sk_sndtimeo = jiffies_left;
 			release_sock(sk);
@@ -286,7 +138,7 @@ int
 lnet_sock_read(struct socket *sock, void *buffer, int nob, int timeout)
 {
 	int rc;
-	long jiffies_left = cfs_time_seconds(timeout);
+	long jiffies_left = timeout * msecs_to_jiffies(MSEC_PER_SEC);
 	unsigned long then;
 
 	LASSERT(nob > 0);
@@ -334,9 +186,8 @@ lnet_sock_create(struct socket **sockp, int *fatal,
 		 __u32 local_ip, int local_port, struct net *ns)
 {
 	struct sockaddr_in  locaddr;
-	struct socket	   *sock;
-	int		    rc;
-	int		    option;
+	struct socket *sock;
+	int rc;
 
 	/* All errors are fatal except bind failure if the port is in use */
 	*fatal = 1;
@@ -348,13 +199,7 @@ lnet_sock_create(struct socket **sockp, int *fatal,
 		return rc;
 	}
 
-	option = 1;
-	rc = kernel_setsockopt(sock, SOL_SOCKET, SO_REUSEADDR,
-			       (char *)&option, sizeof(option));
-	if (rc != 0) {
-		CERROR("Can't set SO_REUSEADDR for socket: %d\n", rc);
-		goto failed;
-	}
+	sock->sk->sk_reuseport = 1;
 
 	if (local_ip != 0 || local_port != 0) {
 		memset(&locaddr, 0, sizeof(locaddr));
@@ -383,34 +228,21 @@ lnet_sock_create(struct socket **sockp, int *fatal,
 	return rc;
 }
 
-int
+void
 lnet_sock_setbuf(struct socket *sock, int txbufsize, int rxbufsize)
 {
-	int		    option;
-	int		    rc;
+	struct sock *sk = sock->sk;
 
 	if (txbufsize != 0) {
-		option = txbufsize;
-		rc = kernel_setsockopt(sock, SOL_SOCKET, SO_SNDBUF,
-				       (char *)&option, sizeof(option));
-		if (rc != 0) {
-			CERROR("Can't set send buffer %d: %d\n",
-				option, rc);
-			return rc;
-		}
+		sk->sk_userlocks |= SOCK_SNDBUF_LOCK;
+		sk->sk_sndbuf = txbufsize;
+		sk->sk_write_space(sk);
 	}
 
 	if (rxbufsize != 0) {
-		option = rxbufsize;
-		rc = kernel_setsockopt(sock, SOL_SOCKET, SO_RCVBUF,
-				       (char *)&option, sizeof(option));
-		if (rc != 0) {
-			CERROR("Can't set receive buffer %d: %d\n",
-				option, rc);
-			return rc;
-		}
+		sk->sk_userlocks |= SOCK_RCVBUF_LOCK;
+		sk->sk_sndbuf = rxbufsize;
 	}
-	return 0;
 }
 EXPORT_SYMBOL(lnet_sock_setbuf);
 
@@ -445,16 +277,13 @@ lnet_sock_getaddr(struct socket *sock, bool remote, __u32 *ip, int *port)
 }
 EXPORT_SYMBOL(lnet_sock_getaddr);
 
-int
-lnet_sock_getbuf(struct socket *sock, int *txbufsize, int *rxbufsize)
+void lnet_sock_getbuf(struct socket *sock, int *txbufsize, int *rxbufsize)
 {
 	if (txbufsize != NULL)
 		*txbufsize = sock->sk->sk_sndbuf;
 
 	if (rxbufsize != NULL)
 		*rxbufsize = sock->sk->sk_rcvbuf;
-
-	return 0;
 }
 EXPORT_SYMBOL(lnet_sock_getbuf);
 
diff --git a/drivers/staging/lustrefsx/lnet/lnet/router_proc.c b/drivers/staging/lustrefsx/lnet/lnet/router_proc.c
index da73b32ea937..b7d513521b43 100644
--- a/drivers/staging/lustrefsx/lnet/lnet/router_proc.c
+++ b/drivers/staging/lustrefsx/lnet/lnet/router_proc.c
@@ -244,9 +244,14 @@ proc_lnet_routes(struct ctl_table *table, int write, void __user *buffer,
 	if (len > *lenp) {    /* linux-supplied buffer is too small */
 		rc = -EINVAL;
 	} else if (len > 0) { /* wrote something */
+#ifdef PROC_HANDLER_USE_USER_ATTR
 		if (copy_to_user(buffer, tmpstr, len))
 			rc = -EFAULT;
 		else {
+#else
+		memcpy(buffer, tmpstr, len);
+		{
+#endif
 			off += 1;
 			*ppos = LNET_PROC_POS_MAKE(0, ver, 0, off);
 		}
@@ -381,9 +386,14 @@ proc_lnet_routers(struct ctl_table *table, int write, void __user *buffer,
 	if (len > *lenp) {    /* linux-supplied buffer is too small */
 		rc = -EINVAL;
 	} else if (len > 0) { /* wrote something */
+#ifdef PROC_HANDLER_USE_USER_ATTR
 		if (copy_to_user(buffer, tmpstr, len))
 			rc = -EFAULT;
 		else {
+#else
+		memcpy(buffer, tmpstr, len);
+		{
+#endif
 			off += 1;
 			*ppos = LNET_PROC_POS_MAKE(0, ver, 0, off);
 		}
@@ -577,9 +587,13 @@ proc_lnet_peers(struct ctl_table *table, int write, void __user *buffer,
 	if (len > *lenp) {    /* linux-supplied buffer is too small */
 		rc = -EINVAL;
 	} else if (len > 0) { /* wrote something */
+#ifdef PROC_HANDLER_USE_USER_ATTR
 		if (copy_to_user(buffer, tmpstr, len))
 			rc = -EFAULT;
 		else
+#else
+		memcpy(buffer, tmpstr, len);
+#endif
 			*ppos = LNET_PROC_POS_MAKE(cpt, ver, hash, hoff);
 	}
 
@@ -784,9 +798,14 @@ proc_lnet_nis(struct ctl_table *table, int write, void __user *buffer,
 	if (len > *lenp) {    /* linux-supplied buffer is too small */
 		rc = -EINVAL;
 	} else if (len > 0) { /* wrote something */
+
+#ifdef PROC_HANDLER_USE_USER_ATTR
 		if (copy_to_user(buffer, tmpstr, len))
 			rc = -EFAULT;
 		else
+#else
+		memcpy(buffer, tmpstr, len);
+#endif
 			*ppos += 1;
 	}
 
diff --git a/drivers/staging/lustrefsx/lnet/selftest/conctl.c b/drivers/staging/lustrefsx/lnet/selftest/conctl.c
index e7b9d05d8cd3..9e60d0d671df 100644
--- a/drivers/staging/lustrefsx/lnet/selftest/conctl.c
+++ b/drivers/staging/lustrefsx/lnet/selftest/conctl.c
@@ -38,7 +38,6 @@
 
 #include <libcfs/libcfs.h>
 #include <lnet/lib-lnet.h>
-#include <lnet/lnetst.h>
 #include "console.h"
 
 static int
diff --git a/drivers/staging/lustrefsx/lnet/selftest/conrpc.c b/drivers/staging/lustrefsx/lnet/selftest/conrpc.c
index 996acd87528e..a1ef9ada9680 100644
--- a/drivers/staging/lustrefsx/lnet/selftest/conrpc.c
+++ b/drivers/staging/lustrefsx/lnet/selftest/conrpc.c
@@ -476,7 +476,7 @@ lstcon_rpc_trans_interpreter(lstcon_rpc_trans_t *trans,
         srpc_msg_t           *msg;
         lstcon_node_t        *nd;
         cfs_duration_t        dur;
-        struct timespec64     ts;
+	struct timespec64 ts;
         int                   error;
 
 	LASSERT(head_up != NULL);
@@ -501,8 +501,8 @@ lstcon_rpc_trans_interpreter(lstcon_rpc_trans_t *trans,
 
                 nd = crpc->crp_node;
 
-                dur = (cfs_duration_t)cfs_time_sub(crpc->crp_stamp,
-                      (cfs_time_t)console_session.ses_id.ses_stamp);
+		dur = (cfs_duration_t)cfs_time_sub(crpc->crp_stamp,
+		       (cfs_time_t)console_session.ses_id.ses_stamp);
 		jiffies_to_timespec64(dur, &ts);
 
 		if (copy_to_user(&ent->rpe_peer,
diff --git a/drivers/staging/lustrefsx/lnet/selftest/conrpc.h b/drivers/staging/lustrefsx/lnet/selftest/conrpc.h
index 3ac70050b29a..fd56e648491c 100644
--- a/drivers/staging/lustrefsx/lnet/selftest/conrpc.h
+++ b/drivers/staging/lustrefsx/lnet/selftest/conrpc.h
@@ -42,7 +42,6 @@
 #include <libcfs/libcfs.h>
 #include <lnet/lnet.h>
 #include <lnet/lib-types.h>
-#include <lnet/lnetst.h>
 #include "rpc.h"
 #include "selftest.h"
 
diff --git a/drivers/staging/lustrefsx/lnet/selftest/console.h b/drivers/staging/lustrefsx/lnet/selftest/console.h
index 0d597c45cb46..ae76a50b4d17 100644
--- a/drivers/staging/lustrefsx/lnet/selftest/console.h
+++ b/drivers/staging/lustrefsx/lnet/selftest/console.h
@@ -43,7 +43,6 @@
 #include <libcfs/libcfs.h>
 #include <lnet/lnet.h>
 #include <lnet/lib-types.h>
-#include <lnet/lnetst.h>
 #include "selftest.h"
 #include "conrpc.h"
 
diff --git a/drivers/staging/lustrefsx/lustre/fid/fid_handler.c b/drivers/staging/lustrefsx/lustre/fid/fid_handler.c
index 18ac0209737c..ef61772f0dcb 100644
--- a/drivers/staging/lustrefsx/lustre/fid/fid_handler.c
+++ b/drivers/staging/lustrefsx/lustre/fid/fid_handler.c
@@ -458,7 +458,7 @@ LU_KEY_INIT_FINI(seq, struct seq_thread_info);
 /* context key: seq_thread_key */
 LU_CONTEXT_KEY_DEFINE(seq, LCT_MD_THREAD | LCT_DT_THREAD);
 
-extern const struct proc_ops seq_fld_proc_seq_fops;
+extern const struct file_operations seq_fld_proc_seq_fops;
 
 static int seq_server_proc_init(struct lu_server_seq *seq)
 {
diff --git a/drivers/staging/lustrefsx/lustre/fid/lproc_fid.c b/drivers/staging/lustrefsx/lustre/fid/lproc_fid.c
index 6e5df75b37c9..d95888f15cfc 100644
--- a/drivers/staging/lustrefsx/lustre/fid/lproc_fid.c
+++ b/drivers/staging/lustrefsx/lustre/fid/lproc_fid.c
@@ -496,11 +496,12 @@ static ssize_t fldb_seq_write(struct file *file, const char __user *buf,
 	RETURN(rc < 0 ? rc : len);
 }
 
-const struct proc_ops seq_fld_proc_seq_fops = {
-	.proc_open	 = fldb_seq_open,
-	.proc_read	 = seq_read,
-	.proc_write	 = fldb_seq_write,
-	.proc_release	= fldb_seq_release,
+const struct file_operations seq_fld_proc_seq_fops = {
+	.owner	 = THIS_MODULE,
+	.open	 = fldb_seq_open,
+	.read	 = seq_read,
+	.write	 = fldb_seq_write,
+	.release = fldb_seq_release,
 };
 
 #endif /* HAVE_SERVER_SUPPORT */
diff --git a/drivers/staging/lustrefsx/lustre/fld/fld_internal.h b/drivers/staging/lustrefsx/lustre/fld/fld_internal.h
index 0be28746d6ef..dcb24a3c2f22 100644
--- a/drivers/staging/lustrefsx/lustre/fld/fld_internal.h
+++ b/drivers/staging/lustrefsx/lustre/fld/fld_internal.h
@@ -179,7 +179,7 @@ void fld_server_mod_exit(void);
 int fld_server_read(const struct lu_env *env, struct lu_server_fld *fld,
 		    struct lu_seq_range *range, void *data, int data_len);
 #ifdef CONFIG_PROC_FS
-extern const struct proc_ops fld_proc_seq_fops;
+extern const struct file_operations fld_proc_seq_fops;
 extern struct lprocfs_vars fld_server_proc_list[];
 #endif
 
diff --git a/drivers/staging/lustrefsx/lustre/fld/lproc_fld.c b/drivers/staging/lustrefsx/lustre/fld/lproc_fld.c
index 269d8d397606..926ed5598052 100644
--- a/drivers/staging/lustrefsx/lustre/fld/lproc_fld.c
+++ b/drivers/staging/lustrefsx/lustre/fld/lproc_fld.c
@@ -356,9 +356,10 @@ static int fldb_seq_release(struct inode *inode, struct file *file)
 }
 
 const struct file_operations fld_proc_seq_fops = {
-	.proc_open    = fldb_seq_open,
-	.proc_read    = seq_read,
-	.proc_release = fldb_seq_release,
+	.owner   = THIS_MODULE,
+	.open    = fldb_seq_open,
+	.read    = seq_read,
+	.release = fldb_seq_release,
 };
 
 struct lprocfs_vars fld_server_proc_list[] = {
diff --git a/drivers/staging/lustrefsx/lustre/include/lprocfs_status.h b/drivers/staging/lustrefsx/lustre/include/lprocfs_status.h
index 6a58c7129b03..a9d6342f1b6c 100644
--- a/drivers/staging/lustrefsx/lustre/include/lprocfs_status.h
+++ b/drivers/staging/lustrefsx/lustre/include/lprocfs_status.h
@@ -46,10 +46,11 @@
 #include <linux/seq_file.h>
 
 #include <libcfs/libcfs.h>
+#include <libcfs/linux/linux-fs.h>
 #include <lustre/lustre_idl.h>
 
 /*
- * Linux 5.6 introduces proc_ops with v5.5-8862-gd56c0d45f0e2
+ * Liuux 5.6 introduces proc_ops with v5.5-8862-gd56c0d45f0e2
  * Now that proc and debugfs use separate operation vector types
  * separate containers are also needed.
  */
@@ -57,16 +58,15 @@ struct lprocfs_vars {
 	const char			*name;
 	const struct proc_ops		*fops;
 	void				*data;
-	/** /proc file mode. */
+	/* /proc file mode. */
 	mode_t				 proc_mode;
 };
 
-/** Provide a debugfs container */
 struct ldebugfs_vars {
 	const char			*name;
 	const struct file_operations	*fops;
 	void				*data;
-	/** debugfs file mode. */
+	/* debugfs file mode. */
 	mode_t				 proc_mode;
 };
 
@@ -490,7 +490,7 @@ static inline int lprocfs_exp_cleanup(struct obd_export *exp)
 #endif
 extern struct proc_dir_entry *
 lprocfs_add_simple(struct proc_dir_entry *root, char *name,
-		   void *data, const struct proc_ops *fops);
+		   void *data, const struct proc_ops *ops);
 extern struct proc_dir_entry *
 lprocfs_add_symlink(const char *name, struct proc_dir_entry *parent,
                     const char *format, ...);
@@ -549,7 +549,7 @@ static inline int LPROCFS_ENTRY_CHECK(struct inode *inode)
 extern int lprocfs_obd_setup(struct obd_device *dev);
 extern int lprocfs_obd_cleanup(struct obd_device *obd);
 #ifdef HAVE_SERVER_SUPPORT
-extern const struct proc_ops lprocfs_evict_client_fops;
+extern const struct file_operations lprocfs_evict_client_fops;
 #endif
 
 extern int ldebugfs_seq_create(struct dentry *parent, const char *name,
@@ -557,12 +557,10 @@ extern int ldebugfs_seq_create(struct dentry *parent, const char *name,
 			       const struct file_operations *seq_fops,
 			       void *data);
 extern int lprocfs_seq_create(struct proc_dir_entry *parent, const char *name,
-			      mode_t mode,
-			      const struct proc_ops *seq_fops,
+			      mode_t mode, const struct proc_ops *seq_fops,
 			      void *data);
 extern int lprocfs_obd_seq_create(struct obd_device *dev, const char *name,
-				  mode_t mode,
-				  const struct proc_ops *seq_fops,
+				  mode_t mode, const struct proc_ops *seq_fops,
 				  void *data);
 
 /* Generic callbacks */
@@ -691,12 +689,13 @@ static int name##_single_open(struct inode *inode, struct file *file)	\
 	return single_open(file, name##_seq_show,			\
 			   inode->i_private ? : PDE_DATA(inode));	\
 }									\
-static const struct proc_ops name##_fops = {			\
-	.proc_open	 = name##_single_open,				\
-	.proc_read	 = seq_read,					\
-	.proc_write	 = custom_seq_write,				\
-	.proc_lseek	 = seq_lseek,					\
-	.proc_release = lprocfs_single_release,				\
+static const struct proc_ops name##_fops = {				\
+	PROC_OWNER(THIS_MODULE)						\
+	.proc_open		= name##_single_open,			\
+	.proc_read		= seq_read,				\
+	.proc_write		= custom_seq_write,			\
+	.proc_lseek		= seq_lseek,				\
+	.proc_release		= lprocfs_single_release,		\
 }
 
 #define LPROC_SEQ_FOPS_RO(name)		__LPROC_SEQ_FOPS(name, NULL)
@@ -736,10 +735,10 @@ static const struct proc_ops name##_fops = {			\
 		return single_open(file, NULL,				\
 				   inode->i_private ? : PDE_DATA(inode));\
 	}								\
-	static const struct proc_ops name##_##type##_fops = {	\
-		.proc_open	 = name##_##type##_open,		\
-		.proc_write	 = name##_##type##_write,		\
-		.proc_release = lprocfs_single_release,			\
+	static const struct proc_ops name##_##type##_fops = {		\
+		.proc_open	= name##_##type##_open,			\
+		.proc_write	= name##_##type##_write,		\
+		.proc_release	= lprocfs_single_release,		\
 	};
 
 struct lustre_attr {
@@ -893,7 +892,7 @@ static inline int lprocfs_exp_cleanup(struct obd_export *exp)
 { return 0; }
 static inline struct proc_dir_entry *
 lprocfs_add_simple(struct proc_dir_entry *root, char *name,
-		   void *data, const struct proc_ops *fops)
+		   void *data, const struct file_operations *fops)
 {return 0; }
 static inline struct proc_dir_entry *
 lprocfs_add_symlink(const char *name, struct proc_dir_entry *parent,
diff --git a/drivers/staging/lustrefsx/lustre/include/lustre/ll_fiemap.h b/drivers/staging/lustrefsx/lustre/include/lustre/ll_fiemap.h
index 9ec06c7fb804..6f57a20a6a8a 100644
--- a/drivers/staging/lustrefsx/lustre/include/lustre/ll_fiemap.h
+++ b/drivers/staging/lustrefsx/lustre/include/lustre/ll_fiemap.h
@@ -41,9 +41,7 @@
 #ifndef _LUSTRE_FIEMAP_H
 #define _LUSTRE_FIEMAP_H
 
-#ifndef __KERNEL__
 #include <stddef.h>
-#endif
 #include <linux/fiemap.h>
 
 /* XXX: We use fiemap_extent::fe_reserved[0] */
diff --git a/drivers/staging/lustrefsx/lustre/include/lvfs.h b/drivers/staging/lustrefsx/lustre/include/lvfs.h
index 856ee1972aa0..f24aff819f66 100644
--- a/drivers/staging/lustrefsx/lustre/include/lvfs.h
+++ b/drivers/staging/lustrefsx/lustre/include/lvfs.h
@@ -52,7 +52,6 @@ struct dt_device;
 struct lvfs_run_ctxt {
 	struct vfsmount		*pwdmnt;
 	struct dentry		*pwd;
-	mm_segment_t		 fs;
 	int			 umask;
 	struct dt_device	*dt;
 #ifdef OBD_CTXT_DEBUG
diff --git a/drivers/staging/lustrefsx/lustre/include/obd_support.h b/drivers/staging/lustrefsx/lustre/include/obd_support.h
index f8abcb83f030..c22e08fe8cdb 100644
--- a/drivers/staging/lustrefsx/lustre/include/obd_support.h
+++ b/drivers/staging/lustrefsx/lustre/include/obd_support.h
@@ -762,7 +762,7 @@ do {									      \
 #define __OBD_VMALLOC_VERBOSE(ptr, cptab, cpt, size)			      \
 do {									      \
 	(ptr) = cptab == NULL ?						      \
-		__vmalloc(size, GFP_NOFS | __GFP_HIGHMEM | __GFP_ZERO) :      \
+		__ll_vmalloc(size, GFP_NOFS | __GFP_HIGHMEM | __GFP_ZERO):    \
 		cfs_cpt_vzalloc(cptab, cpt, size);			      \
 	if (unlikely((ptr) == NULL)) {                                        \
 		CERROR("vmalloc of '" #ptr "' (%d bytes) failed\n",           \
@@ -823,7 +823,7 @@ do {									      \
 do {									      \
 	if (is_vmalloc_addr(ptr)) {					      \
 		OBD_FREE_PRE(ptr, size, "vfreed");			      \
-		vfree(ptr);						      \
+		libcfs_vfree_atomic(ptr);						      \
 		POISON_PTR(ptr);					      \
 	} else {							      \
 		OBD_FREE(ptr, size);					      \
diff --git a/drivers/staging/lustrefsx/lustre/ldlm/ldlm_resource.c b/drivers/staging/lustrefsx/lustre/ldlm/ldlm_resource.c
index 6b8734adeb85..042633867837 100644
--- a/drivers/staging/lustrefsx/lustre/ldlm/ldlm_resource.c
+++ b/drivers/staging/lustrefsx/lustre/ldlm/ldlm_resource.c
@@ -147,12 +147,13 @@ static int seq_watermark_open(struct inode *inode, struct file *file)
 	return single_open(file, seq_watermark_show, PDE_DATA(inode));
 }
 
-static const struct proc_ops ldlm_watermark_fops = {
-	.proc_open		= seq_watermark_open,
-	.proc_read		= seq_read,
-	.proc_write		= seq_watermark_write,
-	.proc_lseek		= seq_lseek,
-	.proc_release		= lprocfs_single_release,
+static const struct file_operations ldlm_watermark_fops = {
+	.owner		= THIS_MODULE,
+	.open		= seq_watermark_open,
+	.read		= seq_read,
+	.write		= seq_watermark_write,
+	.llseek		= seq_lseek,
+	.release	= lprocfs_single_release,
 };
 
 static int seq_granted_show(struct seq_file *m, void *data)
@@ -167,11 +168,12 @@ static int seq_granted_open(struct inode *inode, struct file *file)
 	return single_open(file, seq_granted_show, PDE_DATA(inode));
 }
 
-static const struct proc_ops ldlm_granted_fops = {
-	.proc_open	= seq_granted_open,
-	.proc_read	= seq_read,
-	.proc_lseek	= seq_lseek,
-	.proc_release	= seq_release,
+static const struct file_operations ldlm_granted_fops = {
+	.owner	= THIS_MODULE,
+	.open	= seq_granted_open,
+	.read	= seq_read,
+	.llseek	= seq_lseek,
+	.release = seq_release,
 };
 
 #endif /* HAVE_SERVER_SUPPORT */
diff --git a/drivers/staging/lustrefsx/lustre/llite/llite_mmap.c b/drivers/staging/lustrefsx/lustre/llite/llite_mmap.c
index 7807f45396c9..2c6c54f47af6 100644
--- a/drivers/staging/lustrefsx/lustre/llite/llite_mmap.c
+++ b/drivers/staging/lustrefsx/lustre/llite/llite_mmap.c
@@ -54,21 +54,22 @@ void policy_from_vma(union ldlm_policy_data *policy, struct vm_area_struct *vma,
 struct vm_area_struct *our_vma(struct mm_struct *mm, unsigned long addr,
                                size_t count)
 {
-        struct vm_area_struct *vma, *ret = NULL;
-        ENTRY;
+	struct vm_area_struct *vma, *ret = NULL;
+	ENTRY;
 
-        /* mmap_lock must have been held by caller. */
-        LASSERT(!down_write_trylock(&mm->mmap_lock));
+	/* mmap_lock must have been held by caller. */
+	LASSERT(!mmap_write_trylock(mm));
 
-        for(vma = find_vma(mm, addr);
-            vma != NULL && vma->vm_start < (addr + count); vma = vma->vm_next) {
-                if (vma->vm_ops && vma->vm_ops == &ll_file_vm_ops &&
-                    vma->vm_flags & VM_SHARED) {
-                        ret = vma;
-                        break;
-                }
-        }
-        RETURN(ret);
+	for (vma = find_vma(mm, addr);
+	     vma != NULL && vma->vm_start < (addr + count);
+	     vma = vma->vm_next) {
+		if (vma->vm_ops && vma->vm_ops == &ll_file_vm_ops &&
+		    vma->vm_flags & VM_SHARED) {
+			ret = vma;
+			break;
+		}
+	}
+	RETURN(ret);
 }
 
 /**
diff --git a/drivers/staging/lustrefsx/lustre/llite/rw26.c b/drivers/staging/lustrefsx/lustre/llite/rw26.c
index 528f2892e3b4..9cba2d0b5e8e 100644
--- a/drivers/staging/lustrefsx/lustre/llite/rw26.c
+++ b/drivers/staging/lustrefsx/lustre/llite/rw26.c
@@ -453,11 +453,11 @@ static inline int ll_get_user_pages(int rw, unsigned long user_addr,
 
 	OBD_ALLOC_LARGE(*pages, *max_pages * sizeof(**pages));
 	if (*pages) {
-		down_read(&current->mm->mmap_sem);
+		mmap_read_lock(current->mm);
 		result = get_user_pages(current, current->mm, user_addr,
 					*max_pages, (rw == READ), 0, *pages,
 					NULL);
-		up_read(&current->mm->mmap_sem);
+		mmap_read_unlock(current->mm);
 		if (unlikely(result <= 0))
 			OBD_FREE_LARGE(*pages, *max_pages * sizeof(**pages));
 	}
diff --git a/drivers/staging/lustrefsx/lustre/llite/vvp_dev.c b/drivers/staging/lustrefsx/lustre/llite/vvp_dev.c
index 15eb72a35245..2f640635afea 100644
--- a/drivers/staging/lustrefsx/lustre/llite/vvp_dev.c
+++ b/drivers/staging/lustrefsx/lustre/llite/vvp_dev.c
@@ -647,6 +647,7 @@ static int vvp_dump_pgcache_seq_open(struct inode *inode, struct file *filp)
 }
 
 const struct proc_ops vvp_dump_pgcache_file_ops = {
+	PROC_OWNER(THIS_MODULE)
         .proc_open    = vvp_dump_pgcache_seq_open,
         .proc_read    = seq_read,
         .proc_lseek   = seq_lseek,
diff --git a/drivers/staging/lustrefsx/lustre/llite/vvp_io.c b/drivers/staging/lustrefsx/lustre/llite/vvp_io.c
index a71b7b60d90f..a1280f9bff13 100644
--- a/drivers/staging/lustrefsx/lustre/llite/vvp_io.c
+++ b/drivers/staging/lustrefsx/lustre/llite/vvp_io.c
@@ -452,17 +452,17 @@ static int vvp_mmap_locks(const struct lu_env *env, struct cl_io *io)
 		addr = (unsigned long)iov.iov_base;
 		count = iov.iov_len;
 
-                if (count == 0)
-                        continue;
+		if (count == 0)
+			continue;
 
 		count += addr & ~PAGE_MASK;
 		addr &= PAGE_MASK;
 
-                down_read(&mm->mmap_lock);
-                while((vma = our_vma(mm, addr, count)) != NULL) {
+		mmap_read_lock(mm);
+		while ((vma = our_vma(mm, addr, count)) != NULL) {
 			struct dentry *de = file_dentry(vma->vm_file);
 			struct inode *inode = de->d_inode;
-                        int flags = CEF_MUST;
+			int flags = CEF_MUST;
 
 			if (ll_file_nolock(vma->vm_file)) {
 				/*
@@ -472,24 +472,24 @@ static int vvp_mmap_locks(const struct lu_env *env, struct cl_io *io)
 				break;
 			}
 
-                        /*
-                         * XXX: Required lock mode can be weakened: CIT_WRITE
-                         * io only ever reads user level buffer, and CIT_READ
-                         * only writes on it.
-                         */
-                        policy_from_vma(&policy, vma, addr, count);
-                        descr->cld_mode = vvp_mode_from_vma(vma);
-                        descr->cld_obj = ll_i2info(inode)->lli_clob;
-                        descr->cld_start = cl_index(descr->cld_obj,
-                                                    policy.l_extent.start);
-                        descr->cld_end = cl_index(descr->cld_obj,
-                                                  policy.l_extent.end);
-                        descr->cld_enq_flags = flags;
-                        result = cl_io_lock_alloc_add(env, io, descr);
-
-                        CDEBUG(D_VFSTRACE, "lock: %d: [%lu, %lu]\n",
-                               descr->cld_mode, descr->cld_start,
-                               descr->cld_end);
+			/*
+			 * XXX: Required lock mode can be weakened: CIT_WRITE
+			 * io only ever reads user level buffer, and CIT_READ
+			 * only writes on it.
+			 */
+			policy_from_vma(&policy, vma, addr, count);
+			descr->cld_mode = vvp_mode_from_vma(vma);
+			descr->cld_obj = ll_i2info(inode)->lli_clob;
+			descr->cld_start = cl_index(descr->cld_obj,
+						    policy.l_extent.start);
+			descr->cld_end = cl_index(descr->cld_obj,
+						  policy.l_extent.end);
+			descr->cld_enq_flags = flags;
+			result = cl_io_lock_alloc_add(env, io, descr);
+
+			CDEBUG(D_VFSTRACE, "lock: %d: [%lu, %lu]\n",
+			       descr->cld_mode, descr->cld_start,
+			       descr->cld_end);
 
 			if (result < 0)
 				break;
@@ -500,7 +500,7 @@ static int vvp_mmap_locks(const struct lu_env *env, struct cl_io *io)
 			count -= vma->vm_end - addr;
 			addr = vma->vm_end;
 		}
-		up_read(&mm->mmap_lock);
+		mmap_read_unlock(mm);
 		if (result < 0)
 			break;
 	}
diff --git a/drivers/staging/lustrefsx/lustre/llite/xattr.c b/drivers/staging/lustrefsx/lustre/llite/xattr.c
index e76e0130d666..78c774ef738c 100644
--- a/drivers/staging/lustrefsx/lustre/llite/xattr.c
+++ b/drivers/staging/lustrefsx/lustre/llite/xattr.c
@@ -54,17 +54,6 @@ static inline const char *xattr_prefix(const struct xattr_handler *handler)
 }
 #endif
 
-#ifdef HAVE_LINUX_SELINUX_IS_ENABLED
-# define test_xattr_is_selinux_disabled(handler, name) \
-		((handler)->flags == XATTR_SECURITY_T && \
-		!selinux_is_enabled() && \
-		strcmp((name), "selinux") == 0)
-#else
-# define test_xattr_is_selinux_disabled(handler, name) \
-		((handler)->flags == XATTR_SECURITY_T && \
-		strcmp((name), "selinux") == 0)
-#endif
-
 const struct xattr_handler *get_xattr_type(const char *name)
 {
 	int i;
@@ -149,7 +138,8 @@ static int ll_xattr_set_common(const struct xattr_handler *handler,
 		RETURN(0);
 
 	/* LU-549:  Disable security.selinux when selinux is disabled */
-	if (test_xattr_is_selinux_disabled(handler, name))
+	if (handler->flags == XATTR_SECURITY_T && !selinux_is_enabled() &&
+	    strcmp(name, "selinux") == 0)
 		RETURN(-EOPNOTSUPP);
 
 	/*
@@ -443,7 +433,8 @@ static int ll_xattr_get_common(const struct xattr_handler *handler,
 		RETURN(rc);
 
 	/* LU-549:  Disable security.selinux when selinux is disabled */
-	if (test_xattr_is_selinux_disabled(handler, name))
+	if (handler->flags == XATTR_SECURITY_T && !selinux_is_enabled() &&
+	    !strcmp(name, "selinux"))
 		RETURN(-EOPNOTSUPP);
 
 #ifdef CONFIG_FS_POSIX_ACL
diff --git a/drivers/staging/lustrefsx/lustre/lmv/lmv_internal.h b/drivers/staging/lustrefsx/lustre/lmv/lmv_internal.h
index 2a0c324856fe..8ef0631f3301 100644
--- a/drivers/staging/lustrefsx/lustre/lmv/lmv_internal.h
+++ b/drivers/staging/lustrefsx/lustre/lmv/lmv_internal.h
@@ -156,6 +156,6 @@ struct lmv_tgt_desc
 #ifdef CONFIG_PROC_FS
 extern struct lprocfs_vars lprocfs_lmv_obd_vars[];
 #endif
-extern struct proc_ops lmv_proc_target_fops;
+extern const struct proc_ops lmv_proc_target_fops;
 
 #endif
diff --git a/drivers/staging/lustrefsx/lustre/lmv/lproc_lmv.c b/drivers/staging/lustrefsx/lustre/lmv/lproc_lmv.c
index e79781d444fb..37c22a92de71 100644
--- a/drivers/staging/lustrefsx/lustre/lmv/lproc_lmv.c
+++ b/drivers/staging/lustrefsx/lustre/lmv/lproc_lmv.c
@@ -162,10 +162,11 @@ struct lprocfs_vars lprocfs_lmv_obd_vars[] = {
 	{ NULL }
 };
 
-struct proc_ops lmv_proc_target_fops = {
-        .proc_open                 = lmv_target_seq_open,
-        .proc_read                 = seq_read,
-        .proc_lseek                = seq_lseek,
-        .proc_release              = seq_release,
+const struct proc_ops lmv_proc_target_fops = {
+	PROC_OWNER(THIS_MODULE)
+	.proc_open	= lmv_target_seq_open,
+	.proc_read	= seq_read,
+	.proc_lseek	= seq_lseek,
+	.proc_release	= seq_release,
 };
 #endif /* CONFIG_PROC_FS */
diff --git a/drivers/staging/lustrefsx/lustre/lov/lov_internal.h b/drivers/staging/lustrefsx/lustre/lov/lov_internal.h
index 7ff0ffe81026..524b0a4eac68 100644
--- a/drivers/staging/lustrefsx/lustre/lov/lov_internal.h
+++ b/drivers/staging/lustrefsx/lustre/lov/lov_internal.h
@@ -298,7 +298,7 @@ void lsm_free_plain(struct lov_stripe_md *lsm);
 void dump_lsm(unsigned int level, const struct lov_stripe_md *lsm);
 
 /* lproc_lov.c */
-extern struct proc_ops lov_proc_target_fops;
+extern const struct proc_ops lov_proc_target_fops;
 #ifdef CONFIG_PROC_FS
 extern struct lprocfs_vars lprocfs_lov_obd_vars[];
 #endif
diff --git a/drivers/staging/lustrefsx/lustre/lov/lov_pool.c b/drivers/staging/lustrefsx/lustre/lov/lov_pool.c
index 066b57df0948..02b8899cb1b6 100644
--- a/drivers/staging/lustrefsx/lustre/lov/lov_pool.c
+++ b/drivers/staging/lustrefsx/lustre/lov/lov_pool.c
@@ -41,6 +41,7 @@
 #define DEBUG_SUBSYSTEM S_LOV
 
 #include <libcfs/libcfs.h>
+#include <libcfs/linux/linux-fs.h>
 
 #include <obd.h>
 #include "lov_internal.h"
@@ -287,10 +288,10 @@ static int pool_proc_open(struct inode *inode, struct file *file)
 }
 
 static struct proc_ops pool_proc_operations = {
-        .proc_open           = pool_proc_open,
-        .proc_read           = seq_read,
-        .proc_lseek          = seq_lseek,
-        .proc_release        = seq_release,
+	.proc_open	= pool_proc_open,
+	.proc_read	= seq_read,
+	.proc_lseek	= seq_lseek,
+	.proc_release	= seq_release,
 };
 #endif /* CONFIG_PROC_FS */
 
diff --git a/drivers/staging/lustrefsx/lustre/lov/lproc_lov.c b/drivers/staging/lustrefsx/lustre/lov/lproc_lov.c
index e8b9b8830205..41215c11998e 100644
--- a/drivers/staging/lustrefsx/lustre/lov/lproc_lov.c
+++ b/drivers/staging/lustrefsx/lustre/lov/lproc_lov.c
@@ -322,10 +322,11 @@ struct lprocfs_vars lprocfs_lov_obd_vars[] = {
 	{ NULL }
 };
 
-struct proc_ops lov_proc_target_fops = {
-        .proc_open    = lov_target_seq_open,
-        .proc_read    = seq_read,
-        .proc_lseek   = seq_lseek,
-        .proc_release = lprocfs_seq_release,
+const struct proc_ops lov_proc_target_fops = {
+	PROC_OWNER(THIS_MODULE)
+	.proc_open	= lov_target_seq_open,
+	.proc_read	= seq_read,
+	.proc_lseek	= seq_lseek,
+	.proc_release	= lprocfs_seq_release,
 };
 #endif /* CONFIG_PROC_FS */
diff --git a/drivers/staging/lustrefsx/lustre/obdclass/lprocfs_jobstats.c b/drivers/staging/lustrefsx/lustre/obdclass/lprocfs_jobstats.c
index a78e4e7f6b31..00395af27359 100644
--- a/drivers/staging/lustrefsx/lustre/obdclass/lprocfs_jobstats.c
+++ b/drivers/staging/lustrefsx/lustre/obdclass/lprocfs_jobstats.c
@@ -565,11 +565,12 @@ static int lprocfs_jobstats_seq_release(struct inode *inode, struct file *file)
 }
 
 static const struct proc_ops lprocfs_jobstats_seq_fops = {
-	.proc_open    = lprocfs_jobstats_seq_open,
-	.proc_read    = seq_read,
-	.proc_write   = lprocfs_jobstats_seq_write,
-	.proc_lseek   = seq_lseek,
-	.proc_release = lprocfs_jobstats_seq_release,
+	PROC_OWNER(THIS_MODULE)
+	.proc_open	= lprocfs_jobstats_seq_open,
+	.proc_read	= seq_read,
+	.proc_write	= lprocfs_jobstats_seq_write,
+	.proc_lseek	= seq_lseek,
+	.proc_release	= lprocfs_jobstats_seq_release,
 };
 
 int lprocfs_job_stats_init(struct obd_device *obd, int cntr_num,
diff --git a/drivers/staging/lustrefsx/lustre/obdclass/lprocfs_status.c b/drivers/staging/lustrefsx/lustre/obdclass/lprocfs_status.c
index 0fcf859bdbb0..f3d2efc8403b 100644
--- a/drivers/staging/lustrefsx/lustre/obdclass/lprocfs_status.c
+++ b/drivers/staging/lustrefsx/lustre/obdclass/lprocfs_status.c
@@ -97,20 +97,29 @@ int lprocfs_seq_release(struct inode *inode, struct file *file)
 }
 EXPORT_SYMBOL(lprocfs_seq_release);
 
+static umode_t default_mode(const struct proc_ops *ops)
+{
+	umode_t mode = 0;
+
+	if (ops->proc_read)
+		mode = 0444;
+	if (ops->proc_write)
+		mode |= 0200;
+
+	return mode;
+}
+
 struct proc_dir_entry *
 lprocfs_add_simple(struct proc_dir_entry *root, char *name,
 		   void *data, const struct proc_ops *fops)
 {
 	struct proc_dir_entry *proc;
-	mode_t mode = 0;
+	umode_t mode;
 
 	if (root == NULL || name == NULL || fops == NULL)
                 return ERR_PTR(-EINVAL);
 
-	if (fops->proc_read)
-		mode = 0444;
-	if (fops->proc_write)
-		mode |= 0200;
+	mode = default_mode(fops);
 	proc = proc_create_data(name, mode, root, fops, data);
 	if (!proc) {
 		CERROR("LprocFS: No memory to create /proc entry %s\n",
@@ -202,16 +211,12 @@ lprocfs_add_vars(struct proc_dir_entry *root, struct lprocfs_vars *list,
 
 	while (list->name != NULL) {
 		struct proc_dir_entry *proc;
-		mode_t mode = 0;
+		umode_t mode = 0;
 
-		if (list->proc_mode != 0000) {
+		if (list->proc_mode)
 			mode = list->proc_mode;
-		} else if (list->fops) {
-			if (list->fops->proc_read)
-				mode = 0444;
-			if (list->fops->proc_write)
-				mode |= 0200;
-		}
+		else if (list->fops)
+			mode = default_mode(list->fops);
 		proc = proc_create_data(list->name, mode, root,
 					list->fops ?: &lprocfs_empty_ops,
 					list->data ?: data);
@@ -1537,20 +1542,21 @@ static int lprocfs_stats_seq_open(struct inode *inode, struct file *file)
 }
 
 static const struct proc_ops lprocfs_stats_seq_fops = {
-        .proc_open    = lprocfs_stats_seq_open,
-        .proc_read    = seq_read,
-        .proc_write   = lprocfs_stats_seq_write,
-        .proc_lseek   = seq_lseek,
-        .proc_release = lprocfs_seq_release,
+	PROC_OWNER(THIS_MODULE)
+	.proc_open	= lprocfs_stats_seq_open,
+	.proc_read	= seq_read,
+	.proc_write	= lprocfs_stats_seq_write,
+	.proc_lseek	= seq_lseek,
+	.proc_release	= lprocfs_seq_release,
 };
 
 static const struct file_operations ldebugfs_stats_seq_fops = {
-        .owner   = THIS_MODULE,
-        .open    = lprocfs_stats_seq_open,
-        .read    = seq_read,
-        .write   = lprocfs_stats_seq_write,
-        .llseek  = seq_lseek,
-        .release = lprocfs_seq_release,
+	.owner	 = THIS_MODULE,
+	.open	 = lprocfs_stats_seq_open,
+	.read	 = seq_read,
+	.write	 = lprocfs_stats_seq_write,
+	.llseek	 = seq_lseek,
+	.release = lprocfs_seq_release,
 };
 
 int ldebugfs_register_stats(struct dentry *parent, const char *name,
@@ -2265,7 +2271,7 @@ int lprocfs_seq_create(struct proc_dir_entry *parent,
 	ENTRY;
 
 	/* Disallow secretly (un)writable entries. */
-	LASSERT((seq_fops->proc_write == NULL) == ((mode & 0222) == 0));
+	LASSERT(!seq_fops->proc_write == !(mode & 0222));
 
 	entry = proc_create_data(name, mode, parent, seq_fops, data);
 
diff --git a/drivers/staging/lustrefsx/lustre/obdclass/lu_ref.c b/drivers/staging/lustrefsx/lustre/obdclass/lu_ref.c
index 80d644f1092e..bef29033f30e 100644
--- a/drivers/staging/lustrefsx/lustre/obdclass/lu_ref.c
+++ b/drivers/staging/lustrefsx/lustre/obdclass/lu_ref.c
@@ -402,11 +402,12 @@ static int lu_ref_seq_release(struct inode *inode, struct file *file)
 	return seq_release(inode, file);
 }
 
-static struct proc_ops lu_ref_dump_fops = {
-        .proc_open    = lu_ref_seq_open,
-        .proc_read    = seq_read,
-        .proc_lseek   = seq_lseek,
-        .proc_release = lu_ref_seq_release
+static struct file_operations lu_ref_dump_fops = {
+        .owner   = THIS_MODULE,
+        .open    = lu_ref_seq_open,
+        .read    = seq_read,
+        .llseek  = seq_lseek,
+        .release = lu_ref_seq_release
 };
 
 #endif /* CONFIG_PROC_FS */
diff --git a/drivers/staging/lustrefsx/lustre/obdclass/obd_config.c b/drivers/staging/lustrefsx/lustre/obdclass/obd_config.c
index dbd4fdcbd996..8068de9ebea6 100644
--- a/drivers/staging/lustrefsx/lustre/obdclass/obd_config.c
+++ b/drivers/staging/lustrefsx/lustre/obdclass/obd_config.c
@@ -1341,8 +1341,9 @@ int class_process_proc_param(char *prefix, struct lprocfs_vars *lvars,
 
 				if (var->fops && var->fops->proc_write) {
 					rc = (var->fops->proc_write)(&fakefile,
-								sval, vallen,
-								NULL);
+								     sval,
+								     vallen,
+								     NULL);
 				}
 				break;
 			}
diff --git a/drivers/staging/lustrefsx/lustre/ptlrpc/lproc_ptlrpc.c b/drivers/staging/lustrefsx/lustre/ptlrpc/lproc_ptlrpc.c
index 5b5412e50631..933183a83dbb 100644
--- a/drivers/staging/lustrefsx/lustre/ptlrpc/lproc_ptlrpc.c
+++ b/drivers/staging/lustrefsx/lustre/ptlrpc/lproc_ptlrpc.c
@@ -1130,10 +1130,11 @@ void ptlrpc_lprocfs_register_service(struct proc_dir_entry *entry,
 		{ NULL }
         };
         static struct proc_ops req_history_fops = {
-                .proc_open        = ptlrpc_lprocfs_svc_req_history_open,
-                .proc_read        = seq_read,
-                .proc_lseek       = seq_lseek,
-                .proc_release     = lprocfs_seq_release,
+		PROC_OWNER(THIS_MODULE)
+                .proc_open    = ptlrpc_lprocfs_svc_req_history_open,
+                .proc_read    = seq_read,
+                .proc_lseek   = seq_lseek,
+                .proc_release = lprocfs_seq_release,
         };
 
         int rc;
diff --git a/drivers/staging/lustrefsx/lustre/ptlrpc/sec_ctx.c b/drivers/staging/lustrefsx/lustre/ptlrpc/sec_ctx.c
index a703b0e5b456..766b21d10c20 100644
--- a/drivers/staging/lustrefsx/lustre/ptlrpc/sec_ctx.c
+++ b/drivers/staging/lustrefsx/lustre/ptlrpc/sec_ctx.c
@@ -37,12 +37,8 @@
 /* Debugging check only needed during development */
 #ifdef OBD_CTXT_DEBUG
 # define ASSERT_CTXT_MAGIC(magic) LASSERT((magic) == OBD_RUN_CTXT_MAGIC)
-# define ASSERT_NOT_KERNEL_CTXT(msg) LASSERTF(!uaccess_kernel(), msg)
-# define ASSERT_KERNEL_CTXT(msg) LASSERTF(uaccess_kernel(), msg)
 #else
 # define ASSERT_CTXT_MAGIC(magic) do {} while(0)
-# define ASSERT_NOT_KERNEL_CTXT(msg) do {} while(0)
-# define ASSERT_KERNEL_CTXT(msg) do {} while(0)
 #endif
 
 /* push / pop to root of obd store */
@@ -52,11 +48,9 @@ void push_ctxt(struct lvfs_run_ctxt *save, struct lvfs_run_ctxt *new_ctx)
 	if (new_ctx->dt != NULL)
 		return;
 
-	//ASSERT_NOT_KERNEL_CTXT("already in kernel context!\n");
 	ASSERT_CTXT_MAGIC(new_ctx->magic);
 	OBD_SET_CTXT_MAGIC(save);
 
-	save->fs = get_fs();
 	LASSERT(ll_d_count(current->fs->pwd.dentry));
 	LASSERT(ll_d_count(new_ctx->pwd));
 	save->pwd = dget(current->fs->pwd.dentry);
@@ -69,7 +63,6 @@ void push_ctxt(struct lvfs_run_ctxt *save, struct lvfs_run_ctxt *new_ctx)
 	LASSERT(new_ctx->pwdmnt);
 
 	current->fs->umask = 0; /* umask already applied on client */
-	set_fs(new_ctx->fs);
 	ll_set_fs_pwd(current->fs, new_ctx->pwdmnt, new_ctx->pwd);
 }
 EXPORT_SYMBOL(push_ctxt);
@@ -81,14 +74,12 @@ void pop_ctxt(struct lvfs_run_ctxt *saved, struct lvfs_run_ctxt *new_ctx)
 		return;
 
 	ASSERT_CTXT_MAGIC(saved->magic);
-	ASSERT_KERNEL_CTXT("popping non-kernel context!\n");
 
 	LASSERTF(current->fs->pwd.dentry == new_ctx->pwd, "%p != %p\n",
 		 current->fs->pwd.dentry, new_ctx->pwd);
 	LASSERTF(current->fs->pwd.mnt == new_ctx->pwdmnt, "%p != %p\n",
 		 current->fs->pwd.mnt, new_ctx->pwdmnt);
 
-	set_fs(saved->fs);
 	ll_set_fs_pwd(current->fs, saved->pwdmnt, saved->pwd);
 
 	dput(saved->pwd);
diff --git a/drivers/staging/lustrefsx/undef.h b/drivers/staging/lustrefsx/undef.h
index 64189a1ac260..b1ea346eb8f4 100644
--- a/drivers/staging/lustrefsx/undef.h
+++ b/drivers/staging/lustrefsx/undef.h
@@ -290,6 +290,9 @@
 /* filldir_t needs struct dir_context as argument */
 #undef HAVE_FILLDIR_USE_CTX
 
+/* FMR pool API is available */
+#undef HAVE_FMR_POOL_API
+
 /* fpu/api.h is present */
 #undef HAVE_FPU_API_HEADER
 
@@ -464,9 +467,15 @@
 /* i_uid_read is present */
 #undef HAVE_I_UID_READ
 
+/* jiffies_to_timespec64() is available */
+#undef HAVE_JIFFIES_TO_TIMESPEC64
+
 /* kernel_locked is defined */
 #undef HAVE_KERNEL_LOCKED
 
+/* kernel_setsockopt still in use */
+#undef HAVE_KERNEL_SETSOCKOPT
+
 /* 'struct sock' accept function requires bool argument */
 #undef HAVE_KERN_SOCK_ACCEPT_FLAG_ARG
 
@@ -616,6 +625,9 @@
 /* kernel has include/linux/migrate_mode.h */
 #undef HAVE_MIGRATE_MODE_H
 
+/* mmap_lock API is available. */
+#undef HAVE_MMAP_LOCK
+
 /* kernel module loading is possible */
 #undef HAVE_MODULE_LOADING_SUPPORT
 
@@ -631,6 +643,9 @@
 /* 'kernel_write' aligns with read/write helpers */
 #undef HAVE_NEW_KERNEL_WRITE
 
+/* NR_UNSTABLE_NFS is still in use. */
+#undef HAVE_NR_UNSTABLE_NFS
+
 /* with oldsize */
 #undef HAVE_OLDSIZE_TRUNCATE_PAGECACHE
 
@@ -658,6 +673,9 @@
 /* posix_acl_valid takes struct user_namespace */
 #undef HAVE_POSIX_ACL_VALID_USER_NS
 
+/* struct proc_ops exists */
+#undef HAVE_PROC_OPS
+
 /* proc_remove is defined */
 #undef HAVE_PROC_REMOVE
 
@@ -679,6 +697,9 @@
 /* rdma_create_id wants 5 args */
 #undef HAVE_RDMA_CREATE_ID_5ARG
 
+/* rdma_reject has 4 arguments */
+#undef HAVE_RDMA_REJECT_4ARGS
+
 /* reinit_completion is exist */
 #undef HAVE_REINIT_COMPLETION
 
@@ -746,12 +767,6 @@
 /* kernel has sk_sleep */
 #undef HAVE_SK_SLEEP
 
-/* sock_alloc_file is exported */
-#undef HAVE_SOCK_ALLOC_FILE
-
-/* sock_alloc_file takes 3 arguments */
-#undef HAVE_SOCK_ALLOC_FILE_3ARGS
-
 /* sock_create_kern use net as first parameter */
 #undef HAVE_SOCK_CREATE_KERN_USE_NET
 
@@ -842,6 +857,9 @@
 /* 'timespec64_to_ktime' is available */
 #undef HAVE_TIMESPEC64_TO_KTIME
 
+/* have_time_t */
+#undef HAVE_TIME_T
+
 /* topology_sibling_cpumask is available */
 #undef HAVE_TOPOLOGY_SIBLING_CPUMASK
 
@@ -875,6 +893,9 @@
 /* kernel has vfs_unlink with 3 args */
 #undef HAVE_VFS_UNLINK_3ARGS
 
+/* __vmalloc only takes 2 args. */
+#undef HAVE_VMALLOC_2ARGS
+
 /* virtual_address has been replaced by address field */
 #undef HAVE_VM_FAULT_ADDRESS
 
@@ -993,6 +1014,9 @@
 /* name of parallel fsck program */
 #undef PFSCK
 
+/* proc handler methods use __user */
+#undef PROC_HANDLER_USE_USER_ATTR
+
 /* enable randomly alloc failure */
 #undef RANDOM_FAIL_ALLOC
 
-- 
2.32.0

