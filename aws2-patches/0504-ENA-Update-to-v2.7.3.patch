From 526aad1a2f3c2d7c600e2731a674220311d243fa Mon Sep 17 00:00:00 2001
From: Suraj Jitindar Singh <surajjs@amazon.com>
Date: Mon, 27 Jun 2022 16:53:28 -0700
Subject: ENA: Update to v2.7.3

Source: https://github.com/amzn/amzn-drivers/

Change Log:

## r2.7.3 release notes
**Changes**
* Make AF XDP native support experimental
* Update supported distributions documentation

## r2.7.2 release notes
**Bug Fixes**
* Fix compilation for SLES 15 SP3
* Fix compilation for RHEL 8.6
* Fix wrong value check in copybreak sysfs code

**Minor Changes**
* Provide more information on TX timeouts
* Use the same interrupt moderation value for both TX and RX
  In XDP TX/REDIRECT channels

Signed-off-by: Suraj Jitindar Singh <surajjs@amazon.com>
---
 drivers/amazon/net/ena/Makefile        |   4 +
 drivers/amazon/net/ena/ena_com.c       |   5 -
 drivers/amazon/net/ena/ena_com.h       |   5 +-
 drivers/amazon/net/ena/ena_eth_com.h   |  25 -----
 drivers/amazon/net/ena/ena_ethtool.c   |   2 +-
 drivers/amazon/net/ena/ena_netdev.c    | 134 ++++++++++++++++++++-----
 drivers/amazon/net/ena/ena_netdev.h    |   2 +-
 drivers/amazon/net/ena/ena_regs_defs.h |   1 +
 drivers/amazon/net/ena/ena_sysfs.c     |   7 +-
 drivers/amazon/net/ena/ena_xdp.c       |   5 +-
 drivers/amazon/net/ena/kcompat.h       |  31 ++++--
 11 files changed, 149 insertions(+), 72 deletions(-)

diff --git a/drivers/amazon/net/ena/Makefile b/drivers/amazon/net/ena/Makefile
index aa212758c796..37106200d6c1 100644
--- a/drivers/amazon/net/ena/Makefile
+++ b/drivers/amazon/net/ena/Makefile
@@ -10,3 +10,7 @@ ena-y := ena_netdev.o ena_ethtool.o ena_lpc.o ena_xdp.o dim.o ena_devlink.o \
          net_dim.o ena_com.o ena_eth_com.o
 
 ena-$(CONFIG_SYSFS) += ena_sysfs.o
+
+ifdef TEST_AF_XDP
+	ccflags-y += -DENA_TEST_AF_XDP
+endif
diff --git a/drivers/amazon/net/ena/ena_com.c b/drivers/amazon/net/ena/ena_com.c
index f9dbcf24a753..07d5d5eb5676 100644
--- a/drivers/amazon/net/ena/ena_com.c
+++ b/drivers/amazon/net/ena/ena_com.c
@@ -1426,11 +1426,6 @@ int ena_com_create_io_cq(struct ena_com_dev *ena_dev,
 	io_cq->unmask_reg = (u32 __iomem *)((uintptr_t)ena_dev->reg_bar +
 		cmd_completion.cq_interrupt_unmask_register_offset);
 
-	if (cmd_completion.cq_head_db_register_offset)
-		io_cq->cq_head_db_reg =
-			(u32 __iomem *)((uintptr_t)ena_dev->reg_bar +
-			cmd_completion.cq_head_db_register_offset);
-
 	if (cmd_completion.numa_node_register_offset)
 		io_cq->numa_node_cfg_reg =
 			(u32 __iomem *)((uintptr_t)ena_dev->reg_bar +
diff --git a/drivers/amazon/net/ena/ena_com.h b/drivers/amazon/net/ena/ena_com.h
index 6b085c54685f..555cb822bbb1 100644
--- a/drivers/amazon/net/ena/ena_com.h
+++ b/drivers/amazon/net/ena/ena_com.h
@@ -110,8 +110,6 @@ struct ena_com_io_cq {
 	/* Interrupt unmask register */
 	u32 __iomem *unmask_reg;
 
-	/* The completion queue head doorbell register */
-	u32 __iomem *cq_head_db_reg;
 
 	/* numa configuration register (for TPH) */
 	u32 __iomem *numa_node_cfg_reg;
@@ -119,7 +117,7 @@ struct ena_com_io_cq {
 	/* The value to write to the above register to unmask
 	 * the interrupt of this queue
 	 */
-	u32 msix_vector;
+	u32 msix_vector ____cacheline_aligned;
 
 	enum queue_direction direction;
 
@@ -135,7 +133,6 @@ struct ena_com_io_cq {
 	/* Device queue index */
 	u16 idx;
 	u16 head;
-	u16 last_head_update;
 	u8 phase;
 	u8 cdesc_entry_size_in_bytes;
 
diff --git a/drivers/amazon/net/ena/ena_eth_com.h b/drivers/amazon/net/ena/ena_eth_com.h
index 689313ee25a8..91207c657b73 100644
--- a/drivers/amazon/net/ena/ena_eth_com.h
+++ b/drivers/amazon/net/ena/ena_eth_com.h
@@ -8,9 +8,6 @@
 
 #include "ena_com.h"
 
-/* head update threshold in units of (queue size / ENA_COMP_HEAD_THRESH) */
-#define ENA_COMP_HEAD_THRESH 4
-
 struct ena_com_tx_ctx {
 	struct ena_com_tx_meta ena_meta;
 	struct ena_com_buf *ena_bufs;
@@ -168,28 +165,6 @@ static inline int ena_com_write_sq_doorbell(struct ena_com_io_sq *io_sq)
 	return 0;
 }
 
-static inline int ena_com_update_dev_comp_head(struct ena_com_io_cq *io_cq)
-{
-	u16 unreported_comp, head;
-	bool need_update;
-
-	if (unlikely(io_cq->cq_head_db_reg)) {
-		head = io_cq->head;
-		unreported_comp = head - io_cq->last_head_update;
-		need_update = unreported_comp > (io_cq->q_depth / ENA_COMP_HEAD_THRESH);
-
-		if (unlikely(need_update)) {
-			netdev_dbg(ena_com_io_cq_to_ena_dev(io_cq)->net_device,
-				   "Write completion queue doorbell for queue %d: head: %d\n",
-				   io_cq->qid, head);
-			writel(head, io_cq->cq_head_db_reg);
-			io_cq->last_head_update = head;
-		}
-	}
-
-	return 0;
-}
-
 static inline void ena_com_update_numa_node(struct ena_com_io_cq *io_cq,
 					    u8 numa_node)
 {
diff --git a/drivers/amazon/net/ena/ena_ethtool.c b/drivers/amazon/net/ena/ena_ethtool.c
index 4c387d0b6be3..b3bf0836a2c5 100644
--- a/drivers/amazon/net/ena/ena_ethtool.c
+++ b/drivers/amazon/net/ena/ena_ethtool.c
@@ -1060,7 +1060,7 @@ static int ena_set_tunable(struct net_device *netdev,
 	switch (tuna->id) {
 	case ETHTOOL_RX_COPYBREAK:
 		len = *(u32 *)data;
-		if (len > adapter->netdev->mtu) {
+		if (len > min_t(u16, adapter->netdev->mtu, ENA_PAGE_SIZE)) {
 			ret = -EINVAL;
 			break;
 		}
diff --git a/drivers/amazon/net/ena/ena_netdev.c b/drivers/amazon/net/ena/ena_netdev.c
index 36421b2684d3..096677a2e8bf 100644
--- a/drivers/amazon/net/ena/ena_netdev.c
+++ b/drivers/amazon/net/ena/ena_netdev.c
@@ -89,27 +89,85 @@ static void ena_calc_io_queue_size(struct ena_adapter *adapter,
 static void ena_set_dev_offloads(struct ena_com_dev_get_features_ctx *feat,
 				 struct net_device *netdev);
 
-#ifdef HAVE_NDO_TX_TIMEOUT_STUCK_QUEUE_PARAMETER
 static void ena_tx_timeout(struct net_device *dev, unsigned int txqueue)
-#else
-static void ena_tx_timeout(struct net_device *dev)
-#endif
 {
+	enum ena_regs_reset_reason_types reset_reason = ENA_REGS_RESET_OS_NETDEV_WD;
 	struct ena_adapter *adapter = netdev_priv(dev);
+	unsigned int time_since_last_napi, threshold;
+	struct ena_ring *tx_ring;
+	int napi_scheduled;
+
+	if (txqueue >= adapter->num_io_queues) {
+		netdev_err(dev, "TX timeout on invalid queue %u\n", txqueue);
+		goto schedule_reset;
+	}
+
+	threshold = jiffies_to_usecs(dev->watchdog_timeo);
+	tx_ring = &adapter->tx_ring[txqueue];
 
+	time_since_last_napi = jiffies_to_usecs(jiffies - tx_ring->tx_stats.last_napi_jiffies);
+	napi_scheduled = !!(tx_ring->napi->state & NAPIF_STATE_SCHED);
+
+	netdev_err(dev,
+		  "TX q %d is paused for too long (threshold %u). Time since last napi %u usec. napi scheduled: %d\n",
+		  txqueue,
+		  threshold,
+		  time_since_last_napi,
+		  napi_scheduled);
+
+	if (threshold < time_since_last_napi && napi_scheduled) {
+		netdev_err(dev,
+			"napi handler hasn't been called for a long time but is scheduled\n");
+			reset_reason = ENA_REGS_RESET_SUSPECTED_POLL_STARVATION;
+	}
+schedule_reset:
 	/* Change the state of the device to trigger reset
 	 * Check that we are not in the middle or a trigger already
 	 */
+	if (test_and_set_bit(ENA_FLAG_TRIGGER_RESET, &adapter->flags))
+		return;
+
+	ena_reset_device(adapter, reset_reason);
+	ena_increase_stat(&adapter->dev_stats.tx_timeout, 1, &adapter->syncp);
+}
 
+#ifndef HAVE_NDO_TX_TIMEOUT_STUCK_QUEUE_PARAMETER
+/* This function is called by the kernel's watchdog and indicates that the queue
+ * has been closed longer than dev->watchdog_timeo value allows.
+ * In older kernels the called function doesn't contain the id of the queue
+ * that's been closed for too long. This helper function retrieves this
+ * information
+ */
+static void ena_find_and_timeout_queue(struct net_device *dev)
+{
+	struct ena_adapter *adapter = netdev_priv(dev);
+	unsigned long trans_start;
+	struct netdev_queue *txq;
+	unsigned int i;
+
+	for (i = 0; i < dev->num_tx_queues; i++) {
+		txq = netdev_get_tx_queue(dev, i);
+		trans_start = txq->trans_start;
+		if (netif_xmit_stopped(txq) &&
+			time_after(jiffies, (trans_start + dev->watchdog_timeo))) {
+			ena_tx_timeout(dev, i);
+			return;
+		}
+	}
+
+	netdev_warn(dev, "timeout was called, but no offending queue was found\n");
+
+	/* Change the state of the device to trigger reset
+	 * Check that we are not in the middle or a trigger already
+	 */
 	if (test_and_set_bit(ENA_FLAG_TRIGGER_RESET, &adapter->flags))
 		return;
 
 	ena_reset_device(adapter, ENA_REGS_RESET_OS_NETDEV_WD);
 	ena_increase_stat(&adapter->dev_stats.tx_timeout, 1, &adapter->syncp);
-
-	netif_err(adapter, tx_err, dev, "Transmit time out\n");
 }
 
+#endif
 static void update_rx_ring_mtu(struct ena_adapter *adapter, int mtu)
 {
 	int i;
@@ -955,7 +1013,6 @@ static int ena_clean_tx_irq(struct ena_ring *tx_ring, u32 budget)
 
 	tx_ring->next_to_clean = next_to_clean;
 	ena_com_comp_ack(tx_ring->ena_com_io_sq, total_done);
-	ena_com_update_dev_comp_head(tx_ring->ena_com_io_cq);
 
 	if (tx_ring->enable_bql)
 		netdev_tx_completed_queue(txq, tx_pkts, tx_bytes);
@@ -1450,10 +1507,8 @@ static int ena_clean_rx_irq(struct ena_ring *rx_ring, struct napi_struct *napi,
 		      ENA_RX_REFILL_THRESH_PACKET);
 
 	/* Optimization, try to batch new rx buffers */
-	if (refill_required > refill_threshold) {
-		ena_com_update_dev_comp_head(rx_ring->ena_com_io_cq);
+	if (refill_required > refill_threshold)
 		ena_refill_rx_bufs(rx_ring, refill_required);
-	}
 
 #ifdef ENA_XDP_SUPPORT
 	if (xdp_flags & ENA_XDP_REDIRECT)
@@ -1512,7 +1567,11 @@ void ena_unmask_interrupt(struct ena_ring *tx_ring,
 			  struct ena_ring *rx_ring)
 {
 	struct ena_eth_io_intr_reg intr_reg;
+#ifdef ENA_XDP_SUPPORT
+	u32 rx_interval = tx_ring->smoothed_interval;
+#else
 	u32 rx_interval = 0;
+#endif
 	/* Rx ring can be NULL when for XDP tx queues which don't have an
 	 * accompanying rx_ring pair.
 	 */
@@ -3271,7 +3330,11 @@ static const struct net_device_ops ena_netdev_ops = {
 #else
 	.ndo_get_stats		= ena_get_stats,
 #endif
+#ifdef HAVE_NDO_TX_TIMEOUT_STUCK_QUEUE_PARAMETER
 	.ndo_tx_timeout		= ena_tx_timeout,
+#else
+	.ndo_tx_timeout		= ena_find_and_timeout_queue,
+#endif
 	.ndo_change_mtu		= ena_change_mtu,
 	.ndo_set_mac_address	= NULL,
 #ifdef	HAVE_SET_RX_MODE
@@ -3284,9 +3347,9 @@ static const struct net_device_ops ena_netdev_ops = {
 #ifdef ENA_XDP_SUPPORT
 	.ndo_bpf		= ena_xdp,
 	.ndo_xdp_xmit		= ena_xdp_xmit,
-#ifdef ENA_AF_XDP_SUPPORT
+#if defined(ENA_TEST_AF_XDP) && defined(ENA_AF_XDP_SUPPORT)
 	.ndo_xsk_wakeup         = ena_xdp_xsk_wakeup,
-#endif /* ENA_AF_XDP_SUPPORT */
+#endif /* defined(ENA_TEST_AF_XDP) && defined(ENA_AF_XDP_SUPPORT) */
 #endif /* ENA_XDP_SUPPORT */
 };
 
@@ -3395,6 +3458,7 @@ static int ena_device_init(struct ena_adapter *adapter, struct pci_dev *pdev,
 			   bool *wd_state)
 {
 	struct ena_com_dev *ena_dev = adapter->ena_dev;
+	struct net_device *netdev = adapter->netdev;
 	struct ena_llq_configurations llq_config;
 	netdev_features_t prev_netdev_features;
 	struct device *dev = &pdev->dev;
@@ -3502,7 +3566,7 @@ static int ena_device_init(struct ena_adapter *adapter, struct pci_dev *pdev,
 	rc = ena_set_queues_placement_policy(pdev, ena_dev, &get_feat_ctx->llq,
 					     &llq_config);
 	if (rc) {
-		dev_err(dev, "ENA device init failed\n");
+		netdev_err(netdev, "Cannot set queues placement policy rc= %d\n", rc);
 		goto err_admin_init;
 	}
 
@@ -3721,14 +3785,18 @@ static int check_missing_comp_in_tx_queue(struct ena_adapter *adapter,
 					  struct ena_ring *tx_ring)
 {
 	struct ena_napi *ena_napi = container_of(tx_ring->napi, struct ena_napi, napi);
+	enum ena_regs_reset_reason_types reset_reason = ENA_REGS_RESET_MISS_TX_CMPL;
 	unsigned int time_since_last_napi;
 	unsigned int missing_tx_comp_to;
 	bool is_tx_comp_time_expired;
 	struct ena_tx_buffer *tx_buf;
 	unsigned long last_jiffies;
+	int napi_scheduled;
 	u32 missed_tx = 0;
 	int i, rc = 0;
 
+	missing_tx_comp_to = jiffies_to_msecs(adapter->missing_tx_completion_to);
+
 	for (i = 0; i < tx_ring->ring_size; i++) {
 		tx_buf = &tx_ring->tx_buffer_info[i];
 		last_jiffies = tx_buf->last_jiffies;
@@ -3755,25 +3823,45 @@ static int check_missing_comp_in_tx_queue(struct ena_adapter *adapter,
 			adapter->missing_tx_completion_to);
 
 		if (unlikely(is_tx_comp_time_expired)) {
-			if (!tx_buf->print_once) {
-				time_since_last_napi = jiffies_to_usecs(jiffies - tx_ring->tx_stats.last_napi_jiffies);
-				missing_tx_comp_to = jiffies_to_msecs(adapter->missing_tx_completion_to);
-				netif_notice(adapter, tx_err, adapter->netdev,
-					     "Found a Tx that wasn't completed on time, qid %d, index %d. %u usecs have passed since last napi execution. Missing Tx timeout value %u msecs\n",
-					     tx_ring->qid, i, time_since_last_napi, missing_tx_comp_to);
+
+			time_since_last_napi = jiffies_to_usecs(jiffies - tx_ring->tx_stats.last_napi_jiffies);
+			napi_scheduled = !!(ena_napi->napi.state & NAPIF_STATE_SCHED);
+
+			if (missing_tx_comp_to < time_since_last_napi && napi_scheduled) {
+				/* We suspect napi isn't called because the
+				 * bottom half is not run. Require a bigger
+				 * timeout for these cases
+				 */
+				if (!time_is_before_jiffies(last_jiffies +
+					2 * adapter->missing_tx_completion_to))
+					continue;
+
+				reset_reason = ENA_REGS_RESET_SUSPECTED_POLL_STARVATION;
 			}
 
-			tx_buf->print_once = 1;
 			missed_tx++;
+
+			if (tx_buf->print_once)
+				continue;
+
+			netif_notice(adapter, tx_err, adapter->netdev,
+				     "TX hasn't completed, qid %d, index %d. %u usecs from last napi execution, napi scheduled: %d\n",
+				     tx_ring->qid, i, time_since_last_napi, napi_scheduled);
+
+			tx_buf->print_once = 1;
 		}
 	}
 
 	if (unlikely(missed_tx > adapter->missing_tx_completion_threshold)) {
 		netif_err(adapter, tx_err, adapter->netdev,
-			  "The number of lost tx completions is above the threshold (%d > %d). Reset the device\n",
+			  "Lost TX completions are above the threshold (%d > %d). Completion transmission timeout: %u.\n",
 			  missed_tx,
-			  adapter->missing_tx_completion_threshold);
-		ena_reset_device(adapter, ENA_REGS_RESET_MISS_TX_CMPL);
+			  adapter->missing_tx_completion_threshold,
+			  missing_tx_comp_to);
+		netif_err(adapter, tx_err, adapter->netdev,
+			  "Resetting the device\n");
+
+		ena_reset_device(adapter, reset_reason);
 		rc = -EIO;
 	}
 
diff --git a/drivers/amazon/net/ena/ena_netdev.h b/drivers/amazon/net/ena/ena_netdev.h
index b6a2332d986b..be7e50da737a 100644
--- a/drivers/amazon/net/ena/ena_netdev.h
+++ b/drivers/amazon/net/ena/ena_netdev.h
@@ -26,7 +26,7 @@
 
 #define DRV_MODULE_GEN_MAJOR	2
 #define DRV_MODULE_GEN_MINOR	7
-#define DRV_MODULE_GEN_SUBMINOR 1
+#define DRV_MODULE_GEN_SUBMINOR 3
 
 #define DRV_MODULE_NAME		"ena"
 #ifndef DRV_MODULE_GENERATION
diff --git a/drivers/amazon/net/ena/ena_regs_defs.h b/drivers/amazon/net/ena/ena_regs_defs.h
index 568b26185fe9..8ca6f795a0fd 100755
--- a/drivers/amazon/net/ena/ena_regs_defs.h
+++ b/drivers/amazon/net/ena/ena_regs_defs.h
@@ -21,6 +21,7 @@ enum ena_regs_reset_reason_types {
 	ENA_REGS_RESET_USER_TRIGGER                 = 12,
 	ENA_REGS_RESET_GENERIC                      = 13,
 	ENA_REGS_RESET_MISS_INTERRUPT               = 14,
+	ENA_REGS_RESET_SUSPECTED_POLL_STARVATION    = 15,
 	ENA_REGS_RESET_LAST,
 };
 
diff --git a/drivers/amazon/net/ena/ena_sysfs.c b/drivers/amazon/net/ena/ena_sysfs.c
index 53b8d84ddcc3..0c3451b60a2f 100755
--- a/drivers/amazon/net/ena/ena_sysfs.c
+++ b/drivers/amazon/net/ena/ena_sysfs.c
@@ -26,7 +26,7 @@ static ssize_t ena_store_rx_copybreak(struct device *dev,
 	if (err < 0)
 		return err;
 
-	if (len > adapter->netdev->mtu)
+	if (rx_copybreak > min_t(u16, adapter->netdev->mtu, ENA_PAGE_SIZE))
 		return -EINVAL;
 
 	rtnl_lock();
@@ -41,12 +41,15 @@ static ssize_t ena_store_rx_copybreak(struct device *dev,
 	return len;
 }
 
+#define ENA_RX_COPYBREAK_STR_MAX_LEN 7
+
 static ssize_t ena_show_rx_copybreak(struct device *dev,
 				     struct device_attribute *attr, char *buf)
 {
 	struct ena_adapter *adapter = dev_get_drvdata(dev);
 
-	return sprintf(buf, "%d\n", adapter->rx_copybreak);
+	return snprintf(buf, ENA_RX_COPYBREAK_STR_MAX_LEN, "%d\n",
+			adapter->rx_copybreak);
 }
 
 static DEVICE_ATTR(rx_copybreak, S_IRUGO | S_IWUSR, ena_show_rx_copybreak,
diff --git a/drivers/amazon/net/ena/ena_xdp.c b/drivers/amazon/net/ena/ena_xdp.c
index d06c0f50998a..9296be230fd3 100644
--- a/drivers/amazon/net/ena/ena_xdp.c
+++ b/drivers/amazon/net/ena/ena_xdp.c
@@ -611,7 +611,6 @@ static bool ena_clean_xdp_irq(struct ena_ring *tx_ring, u32 budget)
 
 	tx_ring->next_to_clean = next_to_clean;
 	ena_com_comp_ack(tx_ring->ena_com_io_sq, total_done);
-	ena_com_update_dev_comp_head(tx_ring->ena_com_io_cq);
 
 	netif_dbg(tx_ring->adapter, tx_done, tx_ring->netdev,
 		  "tx_poll: q %d done. total pkts: %d\n",
@@ -877,10 +876,8 @@ static int ena_xdp_clean_rx_irq_zc(struct ena_ring *rx_ring,
 		min_t(int, rx_ring->ring_size / ENA_RX_REFILL_THRESH_DIVIDER,
 		      ENA_RX_REFILL_THRESH_PACKET);
 	/* Optimization, try to batch new rx buffers */
-	if (refill_required > refill_threshold) {
-		ena_com_update_dev_comp_head(rx_ring->ena_com_io_cq);
+	if (refill_required > refill_threshold)
 		ena_refill_rx_bufs(rx_ring, refill_required);
-	}
 
 	if (xsk_uses_need_wakeup(rx_ring->xsk_pool)) {
 		if (likely(rc || work_done < budget)) {
diff --git a/drivers/amazon/net/ena/kcompat.h b/drivers/amazon/net/ena/kcompat.h
index f6f930e2bf19..38af7b173de1 100644
--- a/drivers/amazon/net/ena/kcompat.h
+++ b/drivers/amazon/net/ena/kcompat.h
@@ -680,7 +680,8 @@ do {									\
 
 #if defined(CONFIG_BPF) && LINUX_VERSION_CODE >= KERNEL_VERSION(5,0,0)
 #define ENA_XDP_SUPPORT
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,8,0)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5,8,0)) || \
+	(SUSE_VERSION == 15 && SUSE_PATCHLEVEL >= 3)
 #define XDP_HAS_FRAME_SZ
 #define XDP_CONVERT_TO_FRAME_NAME_CHANGED
 #endif
@@ -692,7 +693,9 @@ do {									\
 #endif
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5,6,0) || \
-    (defined(RHEL_RELEASE_CODE) && (RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(8, 3)))
+	(defined(RHEL_RELEASE_CODE) && (RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(8, 3))) || \
+	(SUSE_VERSION == 15 && SUSE_PATCHLEVEL >= 3)
+
 #define HAVE_NDO_TX_TIMEOUT_STUCK_QUEUE_PARAMETER
 #endif
 
@@ -884,16 +887,16 @@ xdp_prepare_buff(struct xdp_buff *xdp, unsigned char *hard_start,
 #define ENA_XDP_XMIT_FREES_FAILED_DESCS_INTERNALLY
 #endif
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 0)
-
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 0) && \
+	!(defined(RHEL_RELEASE_CODE) && RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(8, 6))
 static inline void eth_hw_addr_set(struct net_device *dev, const u8 *addr)
 {
 	memcpy(dev->dev_addr, addr, ETH_ALEN);
 }
+#endif
 
-#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 0) */
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0) || \
+	(defined(RHEL_RELEASE_CODE) && RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(8, 6))
 #define ENA_EXTENDED_COALESCE_UAPI_WITH_CQE_SUPPORTED
 #endif
 
@@ -904,4 +907,18 @@ static inline void eth_hw_addr_set(struct net_device *dev, const u8 *addr)
 #if defined(ENA_XDP_SUPPORT) && LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0)
 #define ENA_AF_XDP_SUPPORT
 #endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 3, 0)
+/* kernels older than 3.3.0 didn't have this function and
+ * used netif_tx_queue_stopped() for the same purpose
+ */
+static inline int netif_xmit_stopped(const struct netdev_queue *dev_queue)
+{
+	return netif_tx_queue_stopped(dev_queue);
+}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 10, 0)
+#define NAPIF_STATE_SCHED BIT(NAPI_STATE_SCHED)
+#endif
 #endif /* _KCOMPAT_H_ */
-- 
2.32.0

