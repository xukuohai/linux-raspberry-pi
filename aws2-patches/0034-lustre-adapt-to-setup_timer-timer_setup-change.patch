From 6622e1e3762cd8f017c851df6da83f02b470ebbc Mon Sep 17 00:00:00 2001
From: Frank van der Linden <fllinden@amazon.com>
Date: Mon, 4 Mar 2019 20:22:24 +0000
Subject: lustre: adapt to setup_timer -> timer_setup change

Upstream Linux changed all setup_timer calls to timer_setup, and then
deprecrated the setup_timer interface. Add a Lustre upstream commit
("LU-10805 libcfs: timer_setup() API changes.") to address this.
---
 .../libcfs/include/libcfs/linux/linux-time.h  | 19 +++++++++++++++++++
 .../lustrefsx/libcfs/libcfs/watchdog.c        |  6 +++---
 .../staging/lustrefsx/lnet/lnet/net_fault.c   |  9 ++++-----
 .../lustrefsx/lustre/obdclass/genops.c        |  1 -
 .../staging/lustrefsx/lustre/ptlrpc/service.c | 10 +++++-----
 5 files changed, 31 insertions(+), 14 deletions(-)

diff --git a/drivers/staging/lustrefsx/libcfs/include/libcfs/linux/linux-time.h b/drivers/staging/lustrefsx/libcfs/include/libcfs/linux/linux-time.h
index 3095626dea42..fa972ff9ca16 100644
--- a/drivers/staging/lustrefsx/libcfs/include/libcfs/linux/linux-time.h
+++ b/drivers/staging/lustrefsx/libcfs/include/libcfs/linux/linux-time.h
@@ -281,4 +281,23 @@ static inline int cfs_time_beforeq_64(__u64 t1, __u64 t2)
  */
 #define CFS_DURATION_T          "%ld"
 
+#ifdef HAVE_TIMER_SETUP
+#define cfs_timer_cb_arg_t struct timer_list *
+#define cfs_from_timer(var, callback_timer, timer_fieldname) \
+	from_timer(var, callback_timer, timer_fieldname)
+#define cfs_timer_setup(timer, callback, data, flags) \
+	timer_setup((timer), (callback), (flags))
+#define CFS_DEFINE_TIMER(_name, _function, _expires, _data) \
+	DEFINE_TIMER((_name), (_function))
+#define cfs_timer_cb_arg(var, timer_fieldname) (&(var)->timer_fieldname)
+#else
+#define cfs_timer_cb_arg_t unsigned long
+#define cfs_from_timer(var, data, timer_fieldname) (typeof(var))(data)
+#define cfs_timer_setup(timer, callback, data, flags) \
+	setup_timer((timer), (callback), (data))
+#define CFS_DEFINE_TIMER(_name, _function, _expires, _data) \
+	DEFINE_TIMER((_name), (_function), (_expires), (_data))
+#define cfs_timer_cb_arg(var, timer_fieldname) (cfs_timer_cb_arg_t)(var)
+#endif
+
 #endif /* __LIBCFS_LINUX_LINUX_TIME_H__ */
diff --git a/drivers/staging/lustrefsx/libcfs/libcfs/watchdog.c b/drivers/staging/lustrefsx/libcfs/libcfs/watchdog.c
index e432d86aae0a..f7170860f027 100644
--- a/drivers/staging/lustrefsx/libcfs/libcfs/watchdog.c
+++ b/drivers/staging/lustrefsx/libcfs/libcfs/watchdog.c
@@ -114,9 +114,9 @@ lcw_dump(struct lc_watchdog *lcw)
         EXIT;
 }
 
-static void lcw_cb(uintptr_t data)
+static void lcw_cb(cfs_timer_cb_arg_t data)
 {
-        struct lc_watchdog *lcw = (struct lc_watchdog *)data;
+	struct lc_watchdog *lcw = cfs_from_timer(lcw, data, lcw_timer);
         ENTRY;
 
         if (lcw->lcw_state != LC_WATCHDOG_ENABLED) {
@@ -359,7 +359,7 @@ struct lc_watchdog *lc_watchdog_add(int timeout,
 	lcw->lcw_state    = LC_WATCHDOG_DISABLED;
 
 	INIT_LIST_HEAD(&lcw->lcw_list);
-	setup_timer(&lcw->lcw_timer, lcw_cb, (unsigned long)lcw);
+	cfs_timer_setup(&lcw->lcw_timer, lcw_cb, (unsigned long)lcw, 0);
 
 	mutex_lock(&lcw_refcount_mutex);
 	if (++lcw_refcount == 1)
diff --git a/drivers/staging/lustrefsx/lnet/lnet/net_fault.c b/drivers/staging/lustrefsx/lnet/lnet/net_fault.c
index c43f8fe2c176..56e62423f21c 100644
--- a/drivers/staging/lustrefsx/lnet/lnet/net_fault.c
+++ b/drivers/staging/lustrefsx/lnet/lnet/net_fault.c
@@ -707,9 +707,9 @@ lnet_delay_rule_daemon(void *arg)
 }
 
 static void
-delay_timer_cb(unsigned long arg)
+delay_timer_cb(cfs_timer_cb_arg_t data)
 {
-	struct lnet_delay_rule *rule = (struct lnet_delay_rule *)arg;
+	struct lnet_delay_rule *rule = cfs_from_timer(rule, data, dl_timer);
 
 	spin_lock_bh(&delay_dd.dd_lock);
 	if (list_empty(&rule->dl_sched_link) && delay_dd.dd_running) {
@@ -772,9 +772,8 @@ lnet_delay_rule_add(struct lnet_fault_attr *attr)
 		wait_event(delay_dd.dd_ctl_waitq, delay_dd.dd_running);
 	}
 
-	init_timer(&rule->dl_timer);
-	rule->dl_timer.function = delay_timer_cb;
-	rule->dl_timer.data = (unsigned long)rule;
+	cfs_timer_setup(&rule->dl_timer, delay_timer_cb,
+			(unsigned long)rule, 0);
 
 	spin_lock_init(&rule->dl_lock);
 	INIT_LIST_HEAD(&rule->dl_msg_list);
diff --git a/drivers/staging/lustrefsx/lustre/obdclass/genops.c b/drivers/staging/lustrefsx/lustre/obdclass/genops.c
index 7fb129d88990..c2b1e35fe86e 100644
--- a/drivers/staging/lustrefsx/lustre/obdclass/genops.c
+++ b/drivers/staging/lustrefsx/lustre/obdclass/genops.c
@@ -349,7 +349,6 @@ struct obd_device *class_newdev(const char *type_name, const char *name,
 	/* XXX belongs in setup not attach  */
 	init_rwsem(&newdev->obd_observer_link_sem);
 	/* recovery data */
-	init_timer(&newdev->obd_recovery_timer);
 	spin_lock_init(&newdev->obd_recovery_task_lock);
 	init_waitqueue_head(&newdev->obd_next_transno_waitq);
 	init_waitqueue_head(&newdev->obd_evict_inprogress_waitq);
diff --git a/drivers/staging/lustrefsx/lustre/ptlrpc/service.c b/drivers/staging/lustrefsx/lustre/ptlrpc/service.c
index d304ec6c2416..6e3172cdeb5a 100644
--- a/drivers/staging/lustrefsx/lustre/ptlrpc/service.c
+++ b/drivers/staging/lustrefsx/lustre/ptlrpc/service.c
@@ -472,11 +472,11 @@ ptlrpc_server_post_idle_rqbds(struct ptlrpc_service_part *svcpt)
 	return -1;
 }
 
-static void ptlrpc_at_timer(unsigned long castmeharder)
+static void ptlrpc_at_timer(cfs_timer_cb_arg_t data)
 {
 	struct ptlrpc_service_part *svcpt;
 
-	svcpt = (struct ptlrpc_service_part *)castmeharder;
+	svcpt = cfs_from_timer(svcpt, data, scp_at_timer);
 
 	svcpt->scp_at_check = 1;
 	svcpt->scp_at_checktime = cfs_time_current();
@@ -643,8 +643,8 @@ ptlrpc_service_part_init(struct ptlrpc_service *svc,
 	if (array->paa_reqs_count == NULL)
 		goto failed;
 
-	setup_timer(&svcpt->scp_at_timer, ptlrpc_at_timer,
-		    (unsigned long)svcpt);
+	cfs_timer_setup(&svcpt->scp_at_timer, ptlrpc_at_timer,
+			(unsigned long)svcpt, 0);
 
 	/* At SOW, service time should be quick; 10s seems generous. If client
 	 * timeout is less than this, we'll be sending an early reply. */
@@ -1177,7 +1177,7 @@ static void ptlrpc_at_set_timer(struct ptlrpc_service_part *svcpt)
 	next = (__s32)(array->paa_deadline - ktime_get_real_seconds() -
 		       at_early_margin);
 	if (next <= 0) {
-		ptlrpc_at_timer((unsigned long)svcpt);
+		ptlrpc_at_timer(cfs_timer_cb_arg(svcpt, scp_at_timer));
 	} else {
 		mod_timer(&svcpt->scp_at_timer, cfs_time_shift(next));
 		CDEBUG(D_INFO, "armed %s at %+ds\n",
-- 
2.32.0

