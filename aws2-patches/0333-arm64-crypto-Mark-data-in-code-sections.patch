From d89ab996f64efdb6fc41df9b382802c72fd5a713 Mon Sep 17 00:00:00 2001
From: Julien Thierry <jthierry@redhat.com>
Date: Thu, 17 Sep 2020 10:03:29 +0100
Subject: arm64: crypto: Mark data in code sections

Use SYM_DATA_* macros to annotate data bytes in the middle of .text
sections.

For local symbols, ".L" prefix needs to be dropped as the assembler
exclude the symbols from the .o symbol table, making objtool unable
to see them.

Signed-off-by: Julien Thierry <jthierry@redhat.com>
---
 arch/arm64/crypto/aes-neonbs-core.S     | 14 +++++++-------
 arch/arm64/crypto/sha256-core.S_shipped | 24 ++++++++++++++----------
 arch/arm64/crypto/sha512-core.S_shipped | 15 ++++++++++-----
 3 files changed, 31 insertions(+), 22 deletions(-)

diff --git a/arch/arm64/crypto/aes-neonbs-core.S b/arch/arm64/crypto/aes-neonbs-core.S
index 63a52ad9a75c..d5bca3b7d0ea 100644
--- a/arch/arm64/crypto/aes-neonbs-core.S
+++ b/arch/arm64/crypto/aes-neonbs-core.S
@@ -367,15 +367,15 @@
 
 
 	.align		6
-M0:	.octa		0x0004080c0105090d02060a0e03070b0f
+SYM_DATA_LOCAL(M0,	.octa		0x0004080c0105090d02060a0e03070b0f)
 
-M0SR:	.octa		0x0004080c05090d010a0e02060f03070b
-SR:	.octa		0x0f0e0d0c0a09080b0504070600030201
-SRM0:	.octa		0x01060b0c0207080d0304090e00050a0f
+SYM_DATA_LOCAL(M0SR,	.octa		0x0004080c05090d010a0e02060f03070b)
+SYM_DATA_LOCAL(SR,	.octa		0x0f0e0d0c0a09080b0504070600030201)
+SYM_DATA_LOCAL(SRM0,	.octa		0x01060b0c0207080d0304090e00050a0f)
 
-M0ISR:	.octa		0x0004080c0d0105090a0e0206070b0f03
-ISR:	.octa		0x0f0e0d0c080b0a090504070602010003
-ISRM0:	.octa		0x0306090c00070a0d01040b0e0205080f
+SYM_DATA_LOCAL(M0ISR,	.octa		0x0004080c0d0105090a0e0206070b0f03)
+SYM_DATA_LOCAL(ISR,	.octa		0x0f0e0d0c080b0a090504070602010003)
+SYM_DATA_LOCAL(ISRM0,	.octa		0x0306090c00070a0d01040b0e0205080f)
 
 	/*
 	 * void aesbs_convert_key(u8 out[], u32 const rk[], int rounds)
diff --git a/arch/arm64/crypto/sha256-core.S_shipped b/arch/arm64/crypto/sha256-core.S_shipped
index 787a1fe466a7..571323f6cca3 100644
--- a/arch/arm64/crypto/sha256-core.S_shipped
+++ b/arch/arm64/crypto/sha256-core.S_shipped
@@ -59,6 +59,8 @@
 // deliver much less improvement, likely *negative* on Cortex-A5x.
 // Which is why NEON support is limited to SHA256.]
 
+#include <linux/linkage.h>
+
 #ifndef	__KERNEL__
 # include "arm_arch.h"
 #endif
@@ -72,11 +74,11 @@
 sha256_block_data_order:
 #ifndef	__KERNEL__
 # ifdef	__ILP32__
-	ldrsw	x16,.LOPENSSL_armcap_P
+	ldrsw	x16,OPENSSL_armcap_P_rel
 # else
-	ldr	x16,.LOPENSSL_armcap_P
+	ldr	x16,OPENSSL_armcap_P_rel
 # endif
-	adr	x17,.LOPENSSL_armcap_P
+	adr	x17,OPENSSL_armcap_P_rel
 	add	x16,x16,x17
 	ldr	w16,[x16]
 	tst	w16,#ARMV8_SHA256
@@ -99,7 +101,7 @@ sha256_block_data_order:
 	ldp	w24,w25,[x0,#4*4]
 	add	x2,x1,x2,lsl#6	// end of input
 	ldp	w26,w27,[x0,#6*4]
-	adr	x30,.LK256
+	adr	x30,K256
 	stp	x0,x2,[x29,#96]
 
 .Loop:
@@ -1047,8 +1049,7 @@ sha256_block_data_order:
 .size	sha256_block_data_order,.-sha256_block_data_order
 
 .align	6
-.type	.LK256,%object
-.LK256:
+SYM_DATA_START_LOCAL(K256)
 	.long	0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5
 	.long	0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5
 	.long	0xd807aa98,0x12835b01,0x243185be,0x550c7dc3
@@ -1066,17 +1067,20 @@ sha256_block_data_order:
 	.long	0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208
 	.long	0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2
 	.long	0	//terminator
-.size	.LK256,.-.LK256
+SYM_DATA_END(K256)
 #ifndef	__KERNEL__
 .align	3
-.LOPENSSL_armcap_P:
+SYM_DATA_START_LOCAL(OPENSSL_armcap_P_rel)
 # ifdef	__ILP32__
 	.long	OPENSSL_armcap_P-.
 # else
 	.quad	OPENSSL_armcap_P-.
 # endif
+SYM_DATA_END(OPENSSL_armcap_P_rel)
 #endif
+SYM_DATA_START_LOCAL(OPENSSL_str)
 .asciz	"SHA256 block transform for ARMv8, CRYPTOGAMS by <appro@openssl.org>"
+SYM_DATA_END(OPENSSL_str)
 .align	2
 #ifndef	__KERNEL__
 .type	sha256_block_armv8,%function
@@ -1087,7 +1091,7 @@ sha256_block_armv8:
 	add		x29,sp,#0
 
 	ld1		{v0.4s,v1.4s},[x0]
-	adr		x3,.LK256
+	adr		x3,K256
 
 .Loop_hw:
 	ld1		{v4.16b-v7.16b},[x1],#64
@@ -1227,7 +1231,7 @@ sha256_block_neon:
 .Lneon_entry:
 	sub	sp,sp,#16*4
 
-	adr	x16,.LK256
+	adr	x16,K256
 	add	x2,x1,x2,lsl#6	// len to point at the end of inp
 
 	ld1	{v0.16b},[x1], #16
diff --git a/arch/arm64/crypto/sha512-core.S_shipped b/arch/arm64/crypto/sha512-core.S_shipped
index e063a6106720..8477c90cf4ba 100644
--- a/arch/arm64/crypto/sha512-core.S_shipped
+++ b/arch/arm64/crypto/sha512-core.S_shipped
@@ -59,6 +59,8 @@
 // deliver much less improvement, likely *negative* on Cortex-A5x.
 // Which is why NEON support is limited to SHA256.]
 
+#include <linux/linkage.h>
+
 #ifndef	__KERNEL__
 # include "arm_arch.h"
 #endif
@@ -85,7 +87,7 @@ sha512_block_data_order:
 	ldp	x24,x25,[x0,#4*8]
 	add	x2,x1,x2,lsl#7	// end of input
 	ldp	x26,x27,[x0,#6*8]
-	adr	x30,.LK512
+	adr	x30,K512
 	stp	x0,x2,[x29,#96]
 
 .Loop:
@@ -1033,8 +1035,7 @@ sha512_block_data_order:
 .size	sha512_block_data_order,.-sha512_block_data_order
 
 .align	6
-.type	.LK512,%object
-.LK512:
+SYM_DATA_START_LOCAL(K512)
 	.quad	0x428a2f98d728ae22,0x7137449123ef65cd
 	.quad	0xb5c0fbcfec4d3b2f,0xe9b5dba58189dbbc
 	.quad	0x3956c25bf348b538,0x59f111f1b605d019
@@ -1076,17 +1077,21 @@ sha512_block_data_order:
 	.quad	0x4cc5d4becb3e42b6,0x597f299cfc657e2a
 	.quad	0x5fcb6fab3ad6faec,0x6c44198c4a475817
 	.quad	0	// terminator
-.size	.LK512,.-.LK512
+SYM_DATA_END(K512)
+
 #ifndef	__KERNEL__
 .align	3
-.LOPENSSL_armcap_P:
+SYM_DATA_START_LOCAL(OPENSSL_armcap_P_rel)
 # ifdef	__ILP32__
 	.long	OPENSSL_armcap_P-.
 # else
 	.quad	OPENSSL_armcap_P-.
 # endif
+SYM_DATA_END(OPENSSL_armcap_P_rel)
 #endif
+SYM_DATA_START_LOCAL(OPENSSL_str)
 .asciz	"SHA512 block transform for ARMv8, CRYPTOGAMS by <appro@openssl.org>"
+SYM_DATA_END(OPENSSL_str)
 .align	2
 #ifndef	__KERNEL__
 .comm	OPENSSL_armcap_P,4,4
-- 
2.32.0

