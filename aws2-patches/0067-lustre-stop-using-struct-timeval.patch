From c84894209d2fff9a172b93e625b01c0b53ab7ce1 Mon Sep 17 00:00:00 2001
From: Frank van der Linden <fllinden@amazon.com>
Date: Tue, 13 Oct 2020 22:04:24 +0000
Subject: lustre: stop using struct timeval

    LU-13344 lnet: stop using struct timeval

    The struct timeval is not 2038 safe so the Linux kernel is moving
    away from its use. The use of rpe_stamp hasn't been used since
    Lustre 2.2 so remove the userland use of this field. This frees
    use to change rpe_stamp to an equivalent struct timespec64 for
    future use. Greatly simplify lnet_sock_[read|write] by using
    jiffies values of sk_sndtimeo, sk_rcvtimeo cached in struct sock.

    Change-Id: Ib58193756ec4a526e55bc810c05abd3920b2b269
    Signed-off-by: James Simmons <jsimmons@infradead.org>
    Reviewed-on: https://review.whamcloud.com/38105
    Tested-by: jenkins <devops@whamcloud.com>
    Reviewed-by: Andreas Dilger <adilger@whamcloud.com>
    Reviewed-by: Shaun Tancheff <shaun.tancheff@hpe.com>
    Tested-by: Maloo <maloo@whamcloud.com>

Signed-off-by: Frank van der Linden <fllinden@amazon.com>
---
 drivers/staging/lustrefsx/config.h            |  3 +
 .../libcfs/include/libcfs/linux/linux-time.h  | 20 +++++
 .../lustrefsx/lnet/include/lnet/lnetst.h      |  8 +-
 .../staging/lustrefsx/lnet/lnet/lib-socket.c  | 76 ++++---------------
 .../staging/lustrefsx/lnet/selftest/conrpc.c  |  6 +-
 5 files changed, 48 insertions(+), 65 deletions(-)

diff --git a/drivers/staging/lustrefsx/config.h b/drivers/staging/lustrefsx/config.h
index d3295c5726e9..d040e2a78605 100644
--- a/drivers/staging/lustrefsx/config.h
+++ b/drivers/staging/lustrefsx/config.h
@@ -548,6 +548,9 @@
 /* 'ktime_to_timespec64' is available */
 #define HAVE_KTIME_TO_TIMESPEC64 1
 
+/* ns_to_timespec64 is available */
+#define HAVE_NS_TO_TIMESPEC64
+
 /* enable use of ldiskfsprogs package */
 /* #undef HAVE_LDISKFSPROGS */
 
diff --git a/drivers/staging/lustrefsx/libcfs/include/libcfs/linux/linux-time.h b/drivers/staging/lustrefsx/libcfs/include/libcfs/linux/linux-time.h
index cc0f42d6360d..d22bda9895fe 100644
--- a/drivers/staging/lustrefsx/libcfs/include/libcfs/linux/linux-time.h
+++ b/drivers/staging/lustrefsx/libcfs/include/libcfs/linux/linux-time.h
@@ -149,6 +149,26 @@ static inline struct timespec timespec64_to_timespec(const struct timespec64 ts6
 #error "lustre is not supported on 32bit"
 #endif
 
+#ifndef HAVE_NS_TO_TIMESPEC64
+static inline struct timespec64 ns_to_timespec64(const s64 nsec)
+{
+	struct timespec64 ts;
+	s32 rem;
+
+	if (!nsec)
+		return (struct timespec64) {0, 0};
+
+	ts.tv_sec = div_s64_rem(nsec, NSEC_PER_SEC, &rem);
+	if (unlikely(rem < 0)) {
+		ts.tv_sec--;
+		rem += NSEC_PER_SEC;
+	}
+	ts.tv_nsec = rem;
+
+	return ts;
+}
+#endif
+
 #ifndef HAVE_KTIME_ADD
 # define ktime_add(lhs, rhs) ({ (ktime_t){ .tv64 = (lhs).tv64 + (rhs).tv64 }; })
 #endif /* !HAVE_KTIME_ADD */
diff --git a/drivers/staging/lustrefsx/lnet/include/lnet/lnetst.h b/drivers/staging/lustrefsx/lnet/include/lnet/lnetst.h
index a43978ff592f..7071039d9aa3 100644
--- a/drivers/staging/lustrefsx/lnet/include/lnet/lnetst.h
+++ b/drivers/staging/lustrefsx/lnet/include/lnet/lnetst.h
@@ -120,7 +120,13 @@ struct lstcon_test_batch_ent {
 struct lstcon_rpc_ent {
 	struct list_head	rpe_link;		/* link chain */
 	struct lnet_process_id	rpe_peer;		/* peer's id */
-	struct timeval		rpe_stamp;		/* time stamp of RPC */
+	/* This has not been used since Lustre 2.2 so its safe to use.
+	 * Update to allow future use of timespec64
+	 */
+	struct {
+		__s64		tv_sec;
+		__s64		tv_nsec;
+	} rpe_stamp;					/* time stamp of RPC */
 	int			rpe_state;		/* peer's state */
 	int			rpe_rpc_errno;		/* RPC errno */
 
diff --git a/drivers/staging/lustrefsx/lnet/lnet/lib-socket.c b/drivers/staging/lustrefsx/lnet/lnet/lib-socket.c
index c46ab8471476..fa9610509773 100644
--- a/drivers/staging/lustrefsx/lnet/lnet/lib-socket.c
+++ b/drivers/staging/lustrefsx/lnet/lnet/lib-socket.c
@@ -43,27 +43,6 @@
 #include <libcfs/libcfs.h>
 #include <lnet/lib-lnet.h>
 
-/*
- * kernel 5.1: commit 7f1bc6e95d7840d4305595b3e4025cddda88cee5
- * Y2038 64-bit time.
- *  SO_TIMESTAMP, SO_TIMESTAMPNS and SO_TIMESTAMPING options, the
- *  way they are currently defined, are not y2038 safe.
- *  Subsequent patches in the series add new y2038 safe versions
- *  of these options which provide 64 bit timestamps on all
- *  architectures uniformly.
- *  Hence, rename existing options with OLD tag suffixes.
- *
- * NOTE: When updating to timespec64 change change these to '_NEW'.
- *
- */
-#ifndef SO_SNDTIMEO
-#define SO_SNDTIMEO SO_SNDTIMEO_OLD
-#endif
-
-#ifndef SO_RCVTIMEO
-#define SO_RCVTIMEO SO_RCVTIMEO_OLD
-#endif
-
 static int
 lnet_sock_create_kern(struct socket **sock, struct net *ns)
 {
@@ -318,10 +297,9 @@ EXPORT_SYMBOL(lnet_ipif_enumerate);
 int
 lnet_sock_write(struct socket *sock, void *buffer, int nob, int timeout)
 {
-	int		rc;
-	long		jiffies_left = timeout * msecs_to_jiffies(MSEC_PER_SEC);
-	unsigned long	then;
-	struct timeval	tv;
+	int rc;
+	long jiffies_left = cfs_time_seconds(timeout);
+	unsigned long then;
 
 	LASSERT(nob > 0);
 	/* Caller may pass a zero timeout if she thinks the socket buffer is
@@ -337,24 +315,11 @@ lnet_sock_write(struct socket *sock, void *buffer, int nob, int timeout)
 		};
 
 		if (timeout != 0) {
-			/* Set send timeout to remaining time */
-			tv = (struct timeval) {
-				.tv_sec = jiffies_left /
-					  msecs_to_jiffies(MSEC_PER_SEC),
-				.tv_usec = ((jiffies_left %
-					     msecs_to_jiffies(MSEC_PER_SEC)) *
-					     USEC_PER_SEC) /
-					     msecs_to_jiffies(MSEC_PER_SEC)
-			};
-
-			rc = kernel_setsockopt(sock, SOL_SOCKET, SO_SNDTIMEO,
-					       (char *)&tv, sizeof(tv));
-			if (rc != 0) {
-				CERROR("Can't set socket send timeout "
-				       "%ld.%06d: %d\n",
-				       (long)tv.tv_sec, (int)tv.tv_usec, rc);
-				return rc;
-			}
+			struct sock *sk = sock->sk;
+
+			lock_sock(sk);
+			sk->sk_sndtimeo = jiffies_left;
+			release_sock(sk);
 		}
 
 		then = jiffies;
@@ -385,10 +350,9 @@ EXPORT_SYMBOL(lnet_sock_write);
 int
 lnet_sock_read(struct socket *sock, void *buffer, int nob, int timeout)
 {
-	int		rc;
-	long		jiffies_left = timeout * msecs_to_jiffies(MSEC_PER_SEC);
-	unsigned long	then;
-	struct timeval	tv;
+	int rc;
+	long jiffies_left = cfs_time_seconds(timeout);
+	unsigned long then;
 
 	LASSERT(nob > 0);
 	LASSERT(jiffies_left > 0);
@@ -401,22 +365,12 @@ lnet_sock_read(struct socket *sock, void *buffer, int nob, int timeout)
 		struct msghdr msg = {
 			.msg_flags	= 0
 		};
+		struct sock *sk = sock->sk;
 
 		/* Set receive timeout to remaining time */
-		tv = (struct timeval) {
-			.tv_sec = jiffies_left / msecs_to_jiffies(MSEC_PER_SEC),
-			.tv_usec = ((jiffies_left %
-					msecs_to_jiffies(MSEC_PER_SEC)) *
-					USEC_PER_SEC) /
-					msecs_to_jiffies(MSEC_PER_SEC)
-		};
-		rc = kernel_setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO,
-				       (char *)&tv, sizeof(tv));
-		if (rc != 0) {
-			CERROR("Can't set socket recv timeout %ld.%06d: %d\n",
-			       (long)tv.tv_sec, (int)tv.tv_usec, rc);
-			return rc;
-		}
+		lock_sock(sk);
+		sk->sk_rcvtimeo = jiffies_left;
+		release_sock(sk);
 
 		then = jiffies;
 		rc = kernel_recvmsg(sock, &msg, &iov, 1, nob, 0);
diff --git a/drivers/staging/lustrefsx/lnet/selftest/conrpc.c b/drivers/staging/lustrefsx/lnet/selftest/conrpc.c
index f9f6c71db255..996acd87528e 100644
--- a/drivers/staging/lustrefsx/lnet/selftest/conrpc.c
+++ b/drivers/staging/lustrefsx/lnet/selftest/conrpc.c
@@ -476,7 +476,7 @@ lstcon_rpc_trans_interpreter(lstcon_rpc_trans_t *trans,
         srpc_msg_t           *msg;
         lstcon_node_t        *nd;
         cfs_duration_t        dur;
-        struct timeval        tv;
+        struct timespec64     ts;
         int                   error;
 
 	LASSERT(head_up != NULL);
@@ -503,11 +503,11 @@ lstcon_rpc_trans_interpreter(lstcon_rpc_trans_t *trans,
 
                 dur = (cfs_duration_t)cfs_time_sub(crpc->crp_stamp,
                       (cfs_time_t)console_session.ses_id.ses_stamp);
-		jiffies_to_timeval(dur, &tv);
+		jiffies_to_timespec64(dur, &ts);
 
 		if (copy_to_user(&ent->rpe_peer,
 				 &nd->nd_id, sizeof(struct lnet_process_id)) ||
-		    copy_to_user(&ent->rpe_stamp, &tv, sizeof(tv)) ||
+		    copy_to_user(&ent->rpe_stamp, &ts, sizeof(ts)) ||
 		    copy_to_user(&ent->rpe_state,
 				 &nd->nd_state, sizeof(nd->nd_state)) ||
 		    copy_to_user(&ent->rpe_rpc_errno, &error,
-- 
2.32.0

