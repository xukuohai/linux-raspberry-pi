From 2fd5c0757fa35068f04222638b13681f6720834c Mon Sep 17 00:00:00 2001
From: Andy Strohman <astroh@amazon.com>
Date: Mon, 22 Jun 2020 22:57:19 +0000
Subject: Update lustre to tag v2.10.8-5 in AmazonFSxLustreClient

Signed-off-by: Andy Strohman <astroh@amazon.com>
---
 drivers/staging/lustrefsx/config.h            | 122 +++---
 .../lustrefsx/libcfs/include/libcfs/libcfs.h  |  10 +
 .../libcfs/include/libcfs/libcfs_prim.h       |   4 +-
 .../libcfs/include/libcfs/libcfs_ptask.h      |  15 +-
 .../libcfs/include/libcfs/linux/linux-misc.h  |  18 +
 .../libcfs/include/libcfs/linux/linux-time.h  |   1 -
 .../lustrefsx/libcfs/libcfs/libcfs_ptask.c    |  33 +-
 .../libcfs/libcfs/linux/linux-curproc.c       |   4 +-
 .../libcfs/libcfs/linux/linux-debug.c         |  41 +-
 .../libcfs/libcfs/linux/linux-prim.c          |   2 +-
 .../libcfs/libcfs/linux/linux-tracefile.c     |   3 +-
 .../lustrefsx/libcfs/libcfs/util/l_ioctl.c    |   2 +-
 .../lustrefsx/libcfs/libcfs/watchdog.c        |  12 +-
 drivers/staging/lustrefsx/lnet/LICENSE        | 363 +++++++++++++++++
 .../lustrefsx/lnet/include/lnet/lib-lnet.h    |  24 +-
 .../lustrefsx/lnet/include/lnet/lnetctl.h     |   2 +-
 .../lustrefsx/lnet/klnds/o2iblnd/o2iblnd.c    |  77 ++--
 .../lustrefsx/lnet/klnds/o2iblnd/o2iblnd.h    |  36 +-
 .../lustrefsx/lnet/klnds/o2iblnd/o2iblnd_cb.c |  18 +-
 .../lustrefsx/lnet/klnds/socklnd/socklnd.c    |  13 +-
 .../lustrefsx/lnet/klnds/socklnd/socklnd_cb.c |   5 +-
 .../lnet/klnds/socklnd/socklnd_proto.c        |   2 +-
 .../staging/lustrefsx/lnet/lnet/acceptor.c    |  10 +-
 drivers/staging/lustrefsx/lnet/lnet/config.c  |  12 +-
 .../staging/lustrefsx/lnet/lnet/lib-socket.c  |  89 +++--
 drivers/staging/lustrefsx/lnet/lnet/router.c  |   2 +-
 .../staging/lustrefsx/lnet/lnet/router_proc.c |   2 +-
 drivers/staging/lustrefsx/lustre/LICENSE      | 372 ++++++++++++++++++
 .../lustrefsx/lustre/include/dt_object.h      |   2 -
 .../lustre/include/lustre/lustre_idl.h        |  15 +-
 .../lustre/include/lustre/lustre_user.h       |  62 ++-
 .../lustrefsx/lustre/include/lustre_compat.h  | 100 ++---
 .../lustrefsx/lustre/include/lustre_dlm.h     |  21 +-
 .../lustre/include/lustre_dlm_flags.h         |   8 -
 .../lustrefsx/lustre/include/lustre_fid.h     |   1 -
 .../lustrefsx/lustre/include/lustre_idmap.h   |   2 +
 .../staging/lustrefsx/lustre/include/obd.h    |   4 +-
 .../lustrefsx/lustre/include/obd_support.h    |   4 +
 .../lustre/include/uapi/linux/lustre_ioctl.h  |   1 +
 .../staging/lustrefsx/lustre/ldlm/ldlm_lib.c  |  40 +-
 .../staging/lustrefsx/lustre/ldlm/ldlm_lock.c |   4 +-
 .../lustrefsx/lustre/ldlm/ldlm_lockd.c        | 117 +++---
 .../lustrefsx/lustre/ldlm/ldlm_request.c      |  96 +++--
 .../lustrefsx/lustre/ldlm/ldlm_resource.c     |   1 +
 drivers/staging/lustrefsx/lustre/llite/file.c |  38 +-
 .../staging/lustrefsx/lustre/llite/glimpse.c  |  10 -
 .../lustrefsx/lustre/llite/lcommon_cl.c       |  69 ++--
 .../lustrefsx/lustre/llite/llite_lib.c        | 208 +++++-----
 .../lustrefsx/lustre/llite/llite_mmap.c       |  15 +-
 .../lustrefsx/lustre/llite/lproc_llite.c      |   8 +-
 .../staging/lustrefsx/lustre/llite/namei.c    |  63 +--
 .../staging/lustrefsx/lustre/llite/vvp_io.c   |  15 +-
 .../lustrefsx/lustre/llite/vvp_object.c       |   6 +-
 .../staging/lustrefsx/lustre/llite/xattr.c    |  19 +-
 .../lustrefsx/lustre/llite/xattr_security.c   |  20 +-
 .../staging/lustrefsx/lustre/lmv/lmv_intent.c |   6 +-
 .../staging/lustrefsx/lustre/lmv/lmv_obd.c    |  35 +-
 .../staging/lustrefsx/lustre/lov/lov_obd.c    |  46 ++-
 .../staging/lustrefsx/lustre/lov/lov_object.c |   7 +-
 .../staging/lustrefsx/lustre/lov/lov_pack.c   |  29 +-
 .../staging/lustrefsx/lustre/mdc/mdc_lib.c    |   6 +-
 .../staging/lustrefsx/lustre/mdc/mdc_locks.c  |   8 +-
 .../staging/lustrefsx/lustre/mdc/mdc_reint.c  |   7 +-
 .../lustrefsx/lustre/mdc/mdc_request.c        |  30 +-
 drivers/staging/lustrefsx/lustre/nodist       |   9 +
 .../lustrefsx/lustre/obdclass/class_obd.c     |   6 +-
 .../lustrefsx/lustre/obdclass/dt_object.c     |  18 -
 .../lustrefsx/lustre/obdclass/genops.c        |   8 +-
 .../lustre/obdclass/linux/linux-sysctl.c      |   2 +-
 .../lustrefsx/lustre/obdclass/llog_cat.c      |   3 +-
 .../lustrefsx/lustre/obdclass/lu_object.c     |   2 +-
 .../lustrefsx/lustre/obdclass/obd_config.c    |  70 +++-
 .../lustre/obdclass/obd_mount_server.c        |  19 +-
 .../staging/lustrefsx/lustre/obdclass/obdo.c  |  13 +-
 .../lustrefsx/lustre/obdecho/echo_client.c    |  45 +--
 .../staging/lustrefsx/lustre/osc/lproc_osc.c  |   2 +-
 .../lustrefsx/lustre/osc/osc_request.c        |  12 +-
 .../staging/lustrefsx/lustre/ptlrpc/client.c  |  10 +-
 .../staging/lustrefsx/lustre/ptlrpc/import.c  |  18 +-
 .../lustrefsx/lustre/ptlrpc/lproc_ptlrpc.c    |   2 +-
 .../staging/lustrefsx/lustre/ptlrpc/recover.c |   2 +
 .../lustrefsx/lustre/ptlrpc/sec_bulk.c        |   6 +-
 .../staging/lustrefsx/lustre/ptlrpc/wirehdr.c |  44 +++
 .../staging/lustrefsx/lustre/target/out_lib.c |   4 -
 .../lustrefsx/lustre/target/tgt_grant.c       |  15 +-
 .../lustrefsx/lustre/target/tgt_main.c        |   1 -
 drivers/staging/lustrefsx/undef.h             |  54 +++
 87 files changed, 1917 insertions(+), 865 deletions(-)
 create mode 100644 drivers/staging/lustrefsx/lnet/LICENSE
 create mode 100644 drivers/staging/lustrefsx/lustre/LICENSE
 create mode 100644 drivers/staging/lustrefsx/lustre/nodist
 create mode 100644 drivers/staging/lustrefsx/lustre/ptlrpc/wirehdr.c

diff --git a/drivers/staging/lustrefsx/config.h b/drivers/staging/lustrefsx/config.h
index 8925156518a4..d3295c5726e9 100644
--- a/drivers/staging/lustrefsx/config.h
+++ b/drivers/staging/lustrefsx/config.h
@@ -139,9 +139,6 @@
 /* current_time() has replaced CURRENT_TIME */
 #define HAVE_CURRENT_TIME 1
 
-/* inode times are timespec64 */
-#define HAVE_INODE_TIME_64BIT 1
-
 /* dcache_lock is exist */
 /* #undef HAVE_DCACHE_LOCK */
 
@@ -296,7 +293,7 @@
 #define HAVE_FILLDIR_USE_CTX 1
 
 /* fpu/api.h is present */
-#define HAVE_FPU_API_HEADER 1
+/* #undef HAVE_FPU_API_HEADER */
 
 /* struct file_system_type has mount field */
 #define HAVE_FSTYPE_MOUNT 1
@@ -328,6 +325,9 @@
 /* get_user_pages takes gup_flags in arguments */
 #define HAVE_GET_USER_PAGES_GUP_FLAGS 1
 
+/* get_user_pages takes gup_flags in arguments with 7 args */
+/* #undef HAVE_GET_USER_PAGES_GUP_FLAGS_7ARGS */
+
 /* struct group_info has member gid */
 #define HAVE_GROUP_INFO_GID 1
 
@@ -364,6 +364,9 @@
 /* struct ib_device.attrs is defined */
 #define HAVE_IB_DEVICE_ATTRS 1
 
+/* if struct ib_device_ops is defined */
+#define HAVE_IB_DEVICE_OPS 1
+
 /* ib_get_dma_mr is defined */
 /* #undef HAVE_IB_GET_DMA_MR */
 
@@ -376,9 +379,15 @@
 /* ib_map_mr_sg has 5 arguments */
 #define HAVE_IB_MAP_MR_SG_5ARGS 1
 
+/* ib_post_send and ib_post_recv have const parameters */
+#define HAVE_IB_POST_SEND_RECV_CONST 1
+
 /* struct ib_rdma_wr is defined */
 #define HAVE_IB_RDMA_WR 1
 
+/* if ib_sg_dma_address wrapper exists */
+/* #undef HAVE_IB_SG_DMA_ADDRESS */
+
 /* inode_operations .getattr member function can gather advance stats */
 #define HAVE_INODEOPS_ENHANCED_GETATTR 1
 
@@ -433,6 +442,9 @@
 /* inode_operations has {get,set,remove}xattr members */
 /* #undef HAVE_IOP_XATTR */
 
+/* if iov_iter has member type */
+#define HAVE_IOV_ITER_HAS_TYPE_MEMBER 1
+
 /* iov_iter_init handles directional tag */
 #define HAVE_IOV_ITER_INIT_DIRECTION 1
 
@@ -442,9 +454,15 @@
 /* iov_iter_truncate exists */
 #define HAVE_IOV_ITER_TRUNCATE 1
 
+/* if iov_iter_type exists */
+#define HAVE_IOV_ITER_TYPE 1
+
 /* is_sxid is defined */
 #define HAVE_IS_SXID 1
 
+/* struct address_space has i_pages */
+#define HAVE_I_PAGES 1
+
 /* i_uid_read is present */
 #define HAVE_I_UID_READ 1
 
@@ -454,6 +472,9 @@
 /* 'struct sock' accept function requires bool argument */
 #define HAVE_KERN_SOCK_ACCEPT_FLAG_ARG 1
 
+/* 'getname' has two args */
+#define HAVE_KERN_SOCK_GETNAME_2ARGS 1
+
 /* struct key_match_data exist */
 #define HAVE_KEY_MATCH_DATA 1
 
@@ -461,7 +482,7 @@
 #define HAVE_KEY_PAYLOAD_DATA_ARRAY 1
 
 /* key_type->instantiate has two args */
-/* #undef HAVE_KEY_TYPE_INSTANTIATE_2ARGS */
+#define HAVE_KEY_TYPE_INSTANTIATE_2ARGS 1
 
 /* ki_left exist */
 /* #undef HAVE_KIOCB_KI_LEFT */
@@ -494,6 +515,9 @@
 /* kernel has kstrtoul */
 #define HAVE_KSTRTOUL 1
 
+/* kernel has ksys_close */
+#define HAVE_KSYS_CLOSE 1
+
 /* kthread_worker found */
 /* #undef HAVE_KTHREAD_WORK */
 
@@ -551,6 +575,9 @@
 /* Define to 1 if you have the <linux/random.h> header file. */
 #define HAVE_LINUX_RANDOM_H 1
 
+/* if linux/selinux.h exists */
+#define HAVE_LINUX_SELINUX_IS_ENABLED 1
+
 /* Define to 1 if you have the <linux/types.h> header file. */
 #define HAVE_LINUX_TYPES_H 1
 
@@ -560,6 +587,9 @@
 /* Define to 1 if you have the <linux/version.h> header file. */
 #define HAVE_LINUX_VERSION_H 1
 
+/* lock_manager_operations has lm_compare_owner */
+/* #undef HAVE_LM_COMPARE_OWNER */
+
 /* lock-manager ops renamed to lm_xxx */
 #define HAVE_LM_XXX_LOCK_MANAGER_OPS 1
 
@@ -613,7 +643,7 @@
 #define HAVE_PAGEVEC_INIT_ONE_PARAM 1
 
 /* have PCLMULQDQ instruction */
-#define HAVE_PCLMULQDQ 1
+/* #undef HAVE_PCLMULQDQ */
 
 /* percpu_counter_init uses GFP_* flag */
 #define HAVE_PERCPU_COUNTER_INIT_GFP_FLAG 1
@@ -640,10 +670,10 @@
 #define HAVE_PROTECT_I_NLINK 1
 
 /* have quota64 */
-/* #undef HAVE_QUOTA64 */
+#define HAVE_QUOTA64 1
 
 /* radix_tree_exceptional_entry exist */
-#define HAVE_RADIX_EXCEPTION_ENTRY 1
+/* #undef HAVE_RADIX_EXCEPTION_ENTRY */
 
 /* rdma_create_id wants 4 args */
 /* #undef HAVE_RDMA_CREATE_ID_4ARG */
@@ -685,10 +715,10 @@
 /* #undef HAVE_SECURITY_IINITSEC_QSTR */
 
 /* support for selinux */
-#define HAVE_SELINUX 1
+/* #undef HAVE_SELINUX */
 
 /* Define to 1 if you have the <selinux/selinux.h> header file. */
-#define HAVE_SELINUX_SELINUX_H 1
+/* #undef HAVE_SELINUX_SELINUX_H */
 
 /* support server */
 /* #undef HAVE_SERVER_SUPPORT */
@@ -739,6 +769,9 @@
 /* stacktrace_ops.warning is exist */
 /* #undef HAVE_STACKTRACE_WARNING */
 
+/* stack_trace_print() exists */
+#define HAVE_STACK_TRACE_PRINT 1
+
 /* Define to 1 if you have the <stdint.h> header file. */
 #define HAVE_STDINT_H 1
 
@@ -800,7 +833,7 @@
 /* #undef HAVE_TCP_SENDPAGE_USE_SOCKET */
 
 /* timer_setup has replaced setup_timer */
-#define HAVE_TIMER_SETUP
+#define HAVE_TIMER_SETUP 1
 
 /* 'struct timespec64' is available */
 #define HAVE_TIMESPEC64 1
@@ -814,21 +847,24 @@
 /* topology_sibling_cpumask is available */
 #define HAVE_TOPOLOGY_SIBLING_CPUMASK 1
 
+/* if totalram_pages is a function */
+#define HAVE_TOTALRAM_PAGES_AS_FUNC 1
+
 /* kernel export truncate_complete_page */
 /* #undef HAVE_TRUNCATE_COMPLETE_PAGE */
 
 /* kernel has truncate_inode_pages_final */
 #define HAVE_TRUNCATE_INODE_PAGES_FINAL 1
 
+/* if MS_RDONLY was moved to uapi/linux/mount.h */
+#define HAVE_UAPI_LINUX_MOUNT_H 1
+
 /* uidgid.h is present */
 #define HAVE_UIDGID_HEADER 1
 
 /* Define to 1 if you have the <unistd.h> header file. */
 #define HAVE_UNISTD_H 1
 
-/* xattr_handler has a name member */
-#define HAVE_XATTR_HANDLER_NAME 1
-
 /* kernel has vfs_rename with 5 args */
 /* #undef HAVE_VFS_RENAME_5ARGS */
 
@@ -844,6 +880,9 @@
 /* virtual_address has been replaced by address field */
 #define HAVE_VM_FAULT_ADDRESS 1
 
+/* if vm_fault_t type exists */
+#define HAVE_VM_FAULT_T 1
+
 /* 'struct vm_operations' remove struct vm_area_struct argument */
 #define HAVE_VM_OPS_USE_VM_FAULT_ONLY 1
 
@@ -856,9 +895,15 @@
 /* needs inode parameter */
 #define HAVE_XATTR_HANDLER_INODE_PARAM 1
 
+/* xattr_handler has a name member */
+#define HAVE_XATTR_HANDLER_NAME 1
+
 /* handler pointer is parameter */
 /* #undef HAVE_XATTR_HANDLER_SIMPLIFIED */
 
+/* xa_is_value exist */
+#define HAVE_XA_IS_VALUE 1
+
 /* Have zap_add_by_dnode() in ZFS */
 /* #undef HAVE_ZAP_ADD_BY_DNODE */
 
@@ -874,39 +919,6 @@
 /* __add_wait_queue_exclusive exists */
 /* #undef HAVE___ADD_WAIT_QUEUE_EXCLUSIVE */
 
-/* struct address_space uses i_pages and xa_lock */
-/* #undef HAVE_ADDRESS_SPACE_IPAGES */
-
-/* struct address_space was converted to an Xarray */
-#define HAVE_ADDRESS_SPACE_XARRAY 1
-
-/* posix acl uses the refcount interface */
-#define HAVE_POSIX_ACL_REFCOUNT 1
-
-/* sys_close was converted to ksys_close for kernel use */
-#define HAVE_KSYS_CLOSE 1
-
-/* kernel_get{sock,peer}name was converted to return the sockaddr length */
-#define HAVE_KERNSOCK_RETURNSLEN 1
-
-/* the 'opened' argument to finish_open and atomic_open was removed */
-#define HAVE_ATOMIC_OPEN_NO_OPENED 1
-
-/* totalram_pages was turned in to a function */
-#define HAVE_TOTALRAM_PAGES_FUNC 1
-
-/* vm_fault_t exists */
-#define HAVE_VM_FAULT_T 1
-
-/* Common stacktrace infrastructure exists */
-#define HAVE_COMMON_STACKTRACE 1
-
-/* changed padata interface in 5.4 */
-#define HAVE_PADATA_INTERFACE_54
-
-/* changed padata interface in 5.6 (and the 5.4 -stable branch) */
-#define HAVE_PADATA_INTERFACE_56
-
 /* ext4_journal_start takes 3 arguments */
 /* #undef JOURNAL_START_HAS_3ARGS */
 
@@ -933,10 +945,10 @@
 #define LUSTRE_MINOR 10
 
 /* Third number in the Lustre version */
-#define LUSTRE_PATCH 5
+#define LUSTRE_PATCH 8
 
 /* A copy of PACKAGE_VERSION */
-#define LUSTRE_VERSION_STRING "2.10.5"
+#define LUSTRE_VERSION_STRING "2.10.8"
 
 /* maximum number of MDS threads */
 /* #undef MDS_MAX_THREADS */
@@ -948,10 +960,10 @@
 #define MKE2FS "mke2fs"
 
 /* need pclmulqdq based crc32c */
-/* #undef NEED_CRC32C_ACCEL */
+#define NEED_CRC32C_ACCEL 1
 
 /* need pclmulqdq based crc32 */
-/* #undef NEED_CRC32_ACCEL */
+#define NEED_CRC32_ACCEL 1
 
 /* 'ktime_get_real_ns' is not available */
 /* #undef NEED_KTIME_GET_REAL_NS */
@@ -963,13 +975,13 @@
 #define PACKAGE "lustre"
 
 /* Define to the address where bug reports for this package should be sent. */
-#define PACKAGE_BUGREPORT "https://jira.hpdd.intel.com/"
+#define PACKAGE_BUGREPORT "https://jira.whamcloud.com/"
 
 /* Define to the full name of this package. */
 #define PACKAGE_NAME "Lustre"
 
 /* Define to the full name and version of this package. */
-#define PACKAGE_STRING "Lustre 2.10.5"
+#define PACKAGE_STRING "Lustre 2.10.8"
 
 /* Define to the one symbol short name of this package. */
 #define PACKAGE_TARNAME "lustre"
@@ -978,7 +990,7 @@
 #define PACKAGE_URL ""
 
 /* Define to the version of this package. */
-#define PACKAGE_VERSION "2.10.5"
+#define PACKAGE_VERSION "2.10.8"
 
 /* name of parallel fsck program */
 #define PFSCK "fsck"
@@ -1019,7 +1031,7 @@
 /* #undef USE_LU_REF */
 
 /* Version number of package */
-#define VERSION "2.10.5"
+#define VERSION "2.10.8"
 
 /* zfs fix version */
 /* #undef ZFS_FIX */
diff --git a/drivers/staging/lustrefsx/libcfs/include/libcfs/libcfs.h b/drivers/staging/lustrefsx/libcfs/include/libcfs/libcfs.h
index 23f29d53224e..8055d3751092 100644
--- a/drivers/staging/lustrefsx/libcfs/include/libcfs/libcfs.h
+++ b/drivers/staging/lustrefsx/libcfs/include/libcfs/libcfs.h
@@ -72,6 +72,16 @@ void lc_watchdog_disable(struct lc_watchdog *lcw);
 /* Clean up the watchdog */
 void lc_watchdog_delete(struct lc_watchdog *lcw);
 
+#ifdef HAVE_TOTALRAM_PAGES_AS_FUNC
+ #ifndef cfs_totalram_pages
+  #define cfs_totalram_pages() totalram_pages()
+ #endif
+#else
+ #ifndef cfs_totalram_pages
+  #define cfs_totalram_pages() totalram_pages
+ #endif
+#endif
+
 /* need both kernel and user-land acceptor */
 #define LNET_ACCEPTOR_MIN_RESERVED_PORT    512
 #define LNET_ACCEPTOR_MAX_RESERVED_PORT    1023
diff --git a/drivers/staging/lustrefsx/libcfs/include/libcfs/libcfs_prim.h b/drivers/staging/lustrefsx/libcfs/include/libcfs/libcfs_prim.h
index 32a629e25eb7..16bda0c460eb 100644
--- a/drivers/staging/lustrefsx/libcfs/include/libcfs/libcfs_prim.h
+++ b/drivers/staging/lustrefsx/libcfs/include/libcfs/libcfs_prim.h
@@ -44,9 +44,9 @@
 #if BITS_PER_LONG == 32
 /* limit to lowmem on 32-bit systems */
 # define NUM_CACHEPAGES \
-	min(TOTALRAM_PAGES, 1UL << (30 - PAGE_SHIFT) * 3 / 4)
+	min(cfs_totalram_pages(), 1UL << (30 - PAGE_SHIFT) * 3 / 4)
 #else
-# define NUM_CACHEPAGES TOTALRAM_PAGES
+# define NUM_CACHEPAGES cfs_totalram_pages()
 #endif
 
 static inline unsigned int memory_pressure_get(void)
diff --git a/drivers/staging/lustrefsx/libcfs/include/libcfs/libcfs_ptask.h b/drivers/staging/lustrefsx/libcfs/include/libcfs/libcfs_ptask.h
index b7c791cdf1eb..85925492dd5d 100644
--- a/drivers/staging/lustrefsx/libcfs/include/libcfs/libcfs_ptask.h
+++ b/drivers/staging/lustrefsx/libcfs/include/libcfs/libcfs_ptask.h
@@ -9,6 +9,16 @@
 #include <linux/notifier.h>
 #include <linux/workqueue.h>
 #include <linux/completion.h>
+
+/*
+ * Unconditionaly disable PADATA.
+ *
+ * Padata is needed for PIO client feature. This feature is disabled by default
+ * and was removed from Lustre code during 2.13 development (2b0a34fe43bf).
+ * Instead of adapting the code to Linux 5.4+ change, just disable it.
+ */
+#undef CONFIG_PADATA
+
 #ifdef CONFIG_PADATA
 #include <linux/padata.h>
 #else
@@ -25,12 +35,7 @@ struct padata_instance {};
 
 struct cfs_ptask_engine {
 	struct padata_instance	*pte_pinst;
-#ifdef HAVE_PADATA_INTERFACE_56
-	struct padata_shell	*pte_pshell;
-#endif
-#ifndef HAVE_PADATA_INTERFACE_54
 	struct workqueue_struct	*pte_wq;
-#endif
 	struct notifier_block	 pte_notifier;
 	int			 pte_weight;
 };
diff --git a/drivers/staging/lustrefsx/libcfs/include/libcfs/linux/linux-misc.h b/drivers/staging/lustrefsx/libcfs/include/libcfs/linux/linux-misc.h
index 0ad585f913c9..8b3d398459c7 100644
--- a/drivers/staging/lustrefsx/libcfs/include/libcfs/linux/linux-misc.h
+++ b/drivers/staging/lustrefsx/libcfs/include/libcfs/linux/linux-misc.h
@@ -34,6 +34,8 @@
 #define __LIBCFS_LINUX_MISC_H__
 
 #include <linux/fs.h>
+#include <linux/uio.h>
+
 #ifdef HAVE_SYSCTL_CTLNAME
 #define INIT_CTL_NAME	.ctl_name = CTL_UNNUMBERED,
 #define INIT_STRATEGY	.strategy = &sysctl_intvec,
@@ -42,6 +44,22 @@
 #define INIT_STRATEGY
 #endif
 
+#ifndef HAVE_IOV_ITER_TYPE
+#ifdef HAVE_IOV_ITER_HAS_TYPE_MEMBER
+#define iter_is_iovec(iter)		((iter)->type & ITER_IOVEC)
+#define iov_iter_is_kvec(iter)		((iter)->type & ITER_KVEC)
+#define iov_iter_is_bvec(iter)		((iter)->type & ITER_BVEC)
+#define iov_iter_is_pipe(iter)		((iter)->type & ITER_PIPE)
+#define iov_iter_is_discard(iter)	((iter)->type & ITER_DISCARD)
+#else
+#define iter_is_iovec(iter)		1
+#define iov_iter_is_kvec(iter)		0
+#define iov_iter_is_bvec(iter)		0
+#define iov_iter_is_pipe(iter)		0
+#define iov_iter_is_discard(iter)	0
+#endif
+#endif /* HAVE_IOV_ITER_TYPE */
+
 #ifndef HAVE_UIDGID_HEADER
 
 #ifndef _LINUX_UIDGID_H
diff --git a/drivers/staging/lustrefsx/libcfs/include/libcfs/linux/linux-time.h b/drivers/staging/lustrefsx/libcfs/include/libcfs/linux/linux-time.h
index fa972ff9ca16..64613de7bd6a 100644
--- a/drivers/staging/lustrefsx/libcfs/include/libcfs/linux/linux-time.h
+++ b/drivers/staging/lustrefsx/libcfs/include/libcfs/linux/linux-time.h
@@ -280,7 +280,6 @@ static inline int cfs_time_beforeq_64(__u64 t1, __u64 t2)
  * One jiffy
  */
 #define CFS_DURATION_T          "%ld"
-
 #ifdef HAVE_TIMER_SETUP
 #define cfs_timer_cb_arg_t struct timer_list *
 #define cfs_from_timer(var, callback_timer, timer_fieldname) \
diff --git a/drivers/staging/lustrefsx/libcfs/libcfs/libcfs_ptask.c b/drivers/staging/lustrefsx/libcfs/libcfs/libcfs_ptask.c
index 636a93f02e68..275c01b74ad4 100644
--- a/drivers/staging/lustrefsx/libcfs/libcfs/libcfs_ptask.c
+++ b/drivers/staging/lustrefsx/libcfs/libcfs/libcfs_ptask.c
@@ -137,13 +137,7 @@ static int cfs_do_parallel(struct cfs_ptask_engine *engine,
 	ptask->pt_result = -EINPROGRESS;
 
 retry:
-#ifdef HAVE_PADATA_INTERFACE_56
-	rc = padata_do_parallel(engine->pte_pshell, padata, &ptask->pt_cbcpu);
-#elif HAVE_PADATA_INTERFACE_54
-	rc = padata_do_parallel(engine->pte_pinst, padata, &ptask->pt_cbcpu);
-#else
 	rc = padata_do_parallel(engine->pte_pinst, padata, ptask->pt_cbcpu);
-#endif
 	if (rc == -EBUSY && cfs_ptask_is_retry(ptask)) {
 		/* too many tasks already in queue */
 		schedule_timeout_uninterruptible(1);
@@ -332,18 +326,14 @@ static int cfs_ptengine_padata_init(struct cfs_ptask_engine *engine,
 {
 	cpumask_var_t all_mask;
 	cpumask_var_t par_mask;
-#ifndef HAVE_PADATA_INTERFACE_54
 	unsigned int wq_flags = WQ_MEM_RECLAIM | WQ_CPU_INTENSIVE;
-#endif
 	int rc;
 
 	get_online_cpus();
 
-#ifndef HAVE_PADATA_INTERFACE_54
 	engine->pte_wq = alloc_workqueue(name, wq_flags, 1);
 	if (engine->pte_wq == NULL)
 		GOTO(err, rc = -ENOMEM);
-#endif
 
 	if (!alloc_cpumask_var(&all_mask, GFP_KERNEL))
 		GOTO(err_destroy_workqueue, rc = -ENOMEM);
@@ -394,25 +384,15 @@ static int cfs_ptengine_padata_init(struct cfs_ptask_engine *engine,
 	}
 
 	engine->pte_weight = cpumask_weight(par_mask);
-#ifdef HAVE_PADATA_INTERFACE_54
-	engine->pte_pinst  = padata_alloc_possible(name);
-#else
 	engine->pte_pinst  = padata_alloc_possible(engine->pte_wq);
-#endif
 	if (engine->pte_pinst == NULL)
 		GOTO(err_free_par_mask, rc = -ENOMEM);
 
-#ifdef HAVE_PADATA_INTERFACE_56
-	engine->pte_pshell = padata_alloc_shell(engine->pte_pinst);
-	if (engine->pte_pshell == NULL)
-		GOTO(err_free_padata, rc = -ENOMEM);
-#endif
-
 	engine->pte_notifier.notifier_call = cfs_ptask_cpumask_change_notify;
 	rc = padata_register_cpumask_notifier(engine->pte_pinst,
 					      &engine->pte_notifier);
 	if (rc)
-		GOTO(err_free_pashell, rc);
+		GOTO(err_free_padata, rc);
 
 	rc = cfs_ptengine_set_cpumask(engine, par_mask);
 	if (rc)
@@ -431,10 +411,6 @@ static int cfs_ptengine_padata_init(struct cfs_ptask_engine *engine,
 err_unregister:
 	padata_unregister_cpumask_notifier(engine->pte_pinst,
 					   &engine->pte_notifier);
-err_free_pashell:
-#ifdef HAVE_PADATA_INTERFACE_56
-	padata_free_shell(engine->pte_pshell);
-#endif
 err_free_padata:
 	padata_free(engine->pte_pinst);
 err_free_par_mask:
@@ -442,10 +418,8 @@ static int cfs_ptengine_padata_init(struct cfs_ptask_engine *engine,
 err_free_all_mask:
 	free_cpumask_var(all_mask);
 err_destroy_workqueue:
-#ifndef HAVE_PADATA_INTERFACE_54
 	destroy_workqueue(engine->pte_wq);
 err:
-#endif
 	put_online_cpus();
 	return rc;
 }
@@ -455,13 +429,8 @@ static void cfs_ptengine_padata_fini(struct cfs_ptask_engine *engine)
 	padata_stop(engine->pte_pinst);
 	padata_unregister_cpumask_notifier(engine->pte_pinst,
 					   &engine->pte_notifier);
-#ifdef HAVE_PADATA_INTERFACE_56
-	padata_free_shell(engine->pte_pshell);
-#endif
 	padata_free(engine->pte_pinst);
-#ifndef HAVE_PADATA_INTERFACE_54
 	destroy_workqueue(engine->pte_wq);
-#endif
 }
 
 #else  /* !CONFIG_PADATA */
diff --git a/drivers/staging/lustrefsx/libcfs/libcfs/linux/linux-curproc.c b/drivers/staging/lustrefsx/libcfs/libcfs/linux/linux-curproc.c
index 7b2e46e61b1b..38ca4bc97be9 100644
--- a/drivers/staging/lustrefsx/libcfs/libcfs/linux/linux-curproc.c
+++ b/drivers/staging/lustrefsx/libcfs/libcfs/linux/linux-curproc.c
@@ -149,7 +149,9 @@ static int cfs_access_process_vm(struct task_struct *tsk,
 		int bytes, rc, offset;
 		void *maddr;
 
-#if defined(HAVE_GET_USER_PAGES_GUP_FLAGS)
+#if defined(HAVE_GET_USER_PAGES_GUP_FLAGS_7ARGS)
+		rc = get_user_pages(tsk, mm, addr, 1, write ? FOLL_WRITE : 0, &page, &vma);
+#elif defined(HAVE_GET_USER_PAGES_GUP_FLAGS)
 		rc = get_user_pages(addr, 1, write ? FOLL_WRITE : 0, &page, &vma);
 #elif defined(HAVE_GET_USER_PAGES_6ARG)
 		rc = get_user_pages(addr, 1, write, 1, &page, &vma);
diff --git a/drivers/staging/lustrefsx/libcfs/libcfs/linux/linux-debug.c b/drivers/staging/lustrefsx/libcfs/libcfs/linux/linux-debug.c
index cbd2187a9f63..048b2f34df5b 100644
--- a/drivers/staging/lustrefsx/libcfs/libcfs/linux/linux-debug.c
+++ b/drivers/staging/lustrefsx/libcfs/libcfs/linux/linux-debug.c
@@ -118,32 +118,59 @@ EXPORT_SYMBOL(lbug_with_loc);
 #define MAX_ST_ENTRIES	100
 static DEFINE_SPINLOCK(st_lock);
 
+/*
+ * Linux v5.1-rc5 214d8ca6ee ("stacktrace: Provide common infrastructure")
+ * CONFIG_ARCH_STACKWALK indicates that save_stack_trace_tsk symbol is not
+ * exported. Use symbol_get() to find if save_stack_trace_tsk is available.
+ */
+#ifdef CONFIG_ARCH_STACKWALK
+typedef unsigned int (stack_trace_save_tsk_t)(struct task_struct *task,
+		unsigned long *store, unsigned int size,
+		unsigned int skipnr);
+static stack_trace_save_tsk_t *task_dump_stack;
+#endif
+
 static void libcfs_call_trace(struct task_struct *tsk)
 {
+#ifdef CONFIG_ARCH_STACKWALK
 	static unsigned long entries[MAX_ST_ENTRIES];
-#ifdef HAVE_COMMON_STACKTRACE
-	unsigned int len;
+	unsigned int i, nr_entries;
+
+	if (!task_dump_stack)
+		task_dump_stack = (stack_trace_save_tsk_t *)
+			symbol_get("stack_trace_save_tsk");
+
+	spin_lock(&st_lock);
+	pr_info("Pid: %d, comm: %.20s %s %s\n", tsk->pid, tsk->comm,
+	       init_utsname()->release, init_utsname()->version);
+	pr_info("Call Trace TBD:\n");
+	if (task_dump_stack) {
+		nr_entries = task_dump_stack(tsk, entries, MAX_ST_ENTRIES, 0);
+		for (i = 0; i < nr_entries; i++)
+			pr_info("[<0>] %pB\n", (void *)entries[i]);
+	}
+	spin_unlock(&st_lock);
 #else
 	struct stack_trace trace;
+	static unsigned long entries[MAX_ST_ENTRIES];
 
 	trace.nr_entries = 0;
 	trace.max_entries = MAX_ST_ENTRIES;
 	trace.entries = entries;
 	trace.skip = 0;
-#endif
 
 	spin_lock(&st_lock);
 	pr_info("Pid: %d, comm: %.20s %s %s\n", tsk->pid, tsk->comm,
 	       init_utsname()->release, init_utsname()->version);
 	pr_info("Call Trace:\n");
-#ifdef HAVE_COMMON_STACKTRACE
-	len = stack_trace_save(entries, MAX_ST_ENTRIES, 2);
-	stack_trace_print(entries, len, 1);
-#else
 	save_stack_trace_tsk(tsk, &trace);
+#ifdef HAVE_STACK_TRACE_PRINT
+	stack_trace_print(trace.entries, trace.nr_entries, 0);
+#else
 	print_stack_trace(&trace, 0);
 #endif
 	spin_unlock(&st_lock);
+#endif
 }
 
 #else /* !CONFIG_STACKTRACE */
diff --git a/drivers/staging/lustrefsx/libcfs/libcfs/linux/linux-prim.c b/drivers/staging/lustrefsx/libcfs/libcfs/linux/linux-prim.c
index a7d5679412f6..e63f7317485d 100644
--- a/drivers/staging/lustrefsx/libcfs/libcfs/linux/linux-prim.c
+++ b/drivers/staging/lustrefsx/libcfs/libcfs/linux/linux-prim.c
@@ -106,7 +106,7 @@ int cfs_kernel_write(struct file *filp, const void *buf, size_t count,
 	mm_segment_t __old_fs = get_fs();
 	int rc;
 
-	set_fs(get_ds());
+	set_fs(KERNEL_DS);
 	rc = vfs_write(filp, (__force const char __user *)buf, count, pos);
 	set_fs(__old_fs);
 
diff --git a/drivers/staging/lustrefsx/libcfs/libcfs/linux/linux-tracefile.c b/drivers/staging/lustrefsx/libcfs/libcfs/linux/linux-tracefile.c
index 274179dd54fe..e0fd4c0de04f 100644
--- a/drivers/staging/lustrefsx/libcfs/libcfs/linux/linux-tracefile.c
+++ b/drivers/staging/lustrefsx/libcfs/libcfs/linux/linux-tracefile.c
@@ -34,7 +34,6 @@
 #define LUSTRE_TRACEFILE_PRIVATE
 
 #include <libcfs/libcfs.h>
-#include <lustre_compat.h>
 #include "tracefile.h"
 
 /* percents to share the total debug memory for each type */
@@ -267,7 +266,7 @@ void cfs_print_to_console(struct ptldebug_header *hdr, int mask,
 
 int cfs_trace_max_debug_mb(void)
 {
-	int  total_mb = (TOTALRAM_PAGES >> (20 - PAGE_SHIFT));
+	int  total_mb = (cfs_totalram_pages() >> (20 - PAGE_SHIFT));
 
 	return MAX(512, (total_mb * 80)/100);
 }
diff --git a/drivers/staging/lustrefsx/libcfs/libcfs/util/l_ioctl.c b/drivers/staging/lustrefsx/libcfs/libcfs/util/l_ioctl.c
index ceec8703a829..c3d5556ab155 100644
--- a/drivers/staging/lustrefsx/libcfs/libcfs/util/l_ioctl.c
+++ b/drivers/staging/lustrefsx/libcfs/libcfs/util/l_ioctl.c
@@ -3,7 +3,7 @@
  *
  * Copyright (c) 2014, Intel Corporation.
  *
- *   This file is part of Lustre, https://wiki.hpdd.intel.com/
+ *   This file is part of Lustre, https://wiki.whamcloud.com/
  *
  *   Portals is free software; you can redistribute it and/or
  *   modify it under the terms of version 2 of the GNU General Public
diff --git a/drivers/staging/lustrefsx/libcfs/libcfs/watchdog.c b/drivers/staging/lustrefsx/libcfs/libcfs/watchdog.c
index f7170860f027..f9e4de58b8ed 100644
--- a/drivers/staging/lustrefsx/libcfs/libcfs/watchdog.c
+++ b/drivers/staging/lustrefsx/libcfs/libcfs/watchdog.c
@@ -172,9 +172,9 @@ static void lcw_dump_stack(struct lc_watchdog *lcw)
 	delta_time = current_time - lcw_last_watchdog_time;
 	if (delta_time < libcfs_watchdog_ratelimit &&
 	    lcw_recent_watchdog_count > 3) {
-		LCONSOLE_WARN("Service thread pid %u was inactive for %lu.%.02lus. Watchdog stack traces are limited to 3 per %d seconds, skipping this one.\n",
+		LCONSOLE_WARN("Service thread pid %u was inactive for %llu.%.02lus. Watchdog stack traces are limited to 3 per %d seconds, skipping this one.\n",
 			      (int)lcw->lcw_pid,
-			      (unsigned long)timediff.tv_sec,
+			      (unsigned long long)timediff.tv_sec,
 			      timediff.tv_nsec / (NSEC_PER_SEC / 100),
 			      libcfs_watchdog_ratelimit);
 	} else {
@@ -186,9 +186,9 @@ static void lcw_dump_stack(struct lc_watchdog *lcw)
 			lcw_recent_watchdog_count = 0;
 		}
 
-		LCONSOLE_WARN("Service thread pid %u was inactive for %lu.%.02lus. The thread might be hung, or it might only be slow and will resume later. Dumping the stack trace for debugging purposes:\n",
+		LCONSOLE_WARN("Service thread pid %u was inactive for %llu.%.02lus. The thread might be hung, or it might only be slow and will resume later. Dumping the stack trace for debugging purposes:\n",
 			      (int)lcw->lcw_pid,
-			      (unsigned long)timediff.tv_sec,
+			      (unsigned long long)timediff.tv_sec,
 			      timediff.tv_nsec / (NSEC_PER_SEC / 100));
 		lcw_dump(lcw);
 	}
@@ -386,9 +386,9 @@ static void lcw_update_time(struct lc_watchdog *lcw, const char *message)
 		struct timespec64 timediff;
 
 		timediff = ktime_to_timespec64(lapse);
-		LCONSOLE_WARN("Service thread pid %u %s after %lu.%.02lus. This indicates the system was overloaded (too many service threads, or there were not enough hardware resources).\n",
+		LCONSOLE_WARN("Service thread pid %u %s after %llu.%.02lus. This indicates the system was overloaded (too many service threads, or there were not enough hardware resources).\n",
 			      lcw->lcw_pid, message,
-			      (unsigned long)timediff.tv_sec,
+			      (unsigned long long)timediff.tv_sec,
 			      timediff.tv_nsec / (NSEC_PER_SEC / 100));
 	}
 	lcw->lcw_last_touched = newtime;
diff --git a/drivers/staging/lustrefsx/lnet/LICENSE b/drivers/staging/lustrefsx/lnet/LICENSE
new file mode 100644
index 000000000000..92728f4d300d
--- /dev/null
+++ b/drivers/staging/lustrefsx/lnet/LICENSE
@@ -0,0 +1,363 @@
+Each file in this distribution should contain a header stating the
+copyright owner(s), and the licensing terms for that module.  Some
+files are not eligible for copyright protection, and contain neither.
+
+All files in this subtree are licensed under the terms and conditions
+of the GNU General Public License version 2.
+
+Reproduced below is the GPL v2, and Linus's clarifying statement from
+the Linux kernel source code:
+
+----------------------------------------
+
+   NOTE! This copyright does *not* cover user programs that use kernel
+ services by normal system calls - this is merely considered normal use
+ of the kernel, and does *not* fall under the heading of "derived work".
+ Also note that the GPL below is copyrighted by the Free Software
+ Foundation, but the instance of code that it refers to (the Linux
+ kernel) is copyrighted by me and others who actually wrote it.
+
+			Linus Torvalds
+
+----------------------------------------
+
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+                       59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) 19yy  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) 19yy name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
diff --git a/drivers/staging/lustrefsx/lnet/include/lnet/lib-lnet.h b/drivers/staging/lustrefsx/lnet/include/lnet/lib-lnet.h
index 48db6dd08a2a..59386c0fdee2 100644
--- a/drivers/staging/lustrefsx/lnet/include/lnet/lib-lnet.h
+++ b/drivers/staging/lustrefsx/lnet/include/lnet/lib-lnet.h
@@ -71,6 +71,18 @@ extern struct lnet the_lnet;			/* THE network */
 /** exclusive lock */
 #define LNET_LOCK_EX		CFS_PERCPT_LOCK_EX
 
+#ifdef HAVE_KERN_SOCK_GETNAME_2ARGS
+#define lnet_kernel_getpeername(sock, addr, addrlen) \
+		kernel_getpeername(sock, addr)
+#define lnet_kernel_getsockname(sock, addr, addrlen) \
+		kernel_getsockname(sock, addr)
+#else
+#define lnet_kernel_getpeername(sock, addr, addrlen) \
+		kernel_getpeername(sock, addr, addrlen)
+#define lnet_kernel_getsockname(sock, addr, addrlen) \
+		kernel_getsockname(sock, addr, addrlen)
+#endif
+
 static inline int lnet_is_route_alive(struct lnet_route *route)
 {
 	if (!route->lr_gateway->lpni_alive)
@@ -757,7 +769,7 @@ void lnet_register_lnd(struct lnet_lnd *lnd);
 void lnet_unregister_lnd(struct lnet_lnd *lnd);
 
 int lnet_connect(struct socket **sockp, lnet_nid_t peer_nid,
-		 __u32 local_ip, __u32 peer_ip, int peer_port);
+		 __u32 local_ip, __u32 peer_ip, int peer_port, struct net *ns);
 void lnet_connect_console_error(int rc, lnet_nid_t peer_nid,
                                 __u32 peer_ip, int port);
 int lnet_count_acceptor_nets(void);
@@ -766,8 +778,9 @@ int lnet_acceptor_port(void);
 int lnet_acceptor_start(void);
 void lnet_acceptor_stop(void);
 
-int lnet_ipif_query(char *name, int *up, __u32 *ip, __u32 *mask);
-int lnet_ipif_enumerate(char ***names);
+int lnet_ipif_query(char *name, int *up, __u32 *ip, __u32 *mask,
+		    struct net *ns);
+int lnet_ipif_enumerate(char ***names, struct net *ns);
 void lnet_ipif_free_enumeration(char **names, int n);
 int lnet_sock_setbuf(struct socket *socket, int txbufsize, int rxbufsize);
 int lnet_sock_getbuf(struct socket *socket, int *txbufsize, int *rxbufsize);
@@ -775,11 +788,12 @@ int lnet_sock_getaddr(struct socket *socket, bool remote, __u32 *ip, int *port);
 int lnet_sock_write(struct socket *sock, void *buffer, int nob, int timeout);
 int lnet_sock_read(struct socket *sock, void *buffer, int nob, int timeout);
 
-int lnet_sock_listen(struct socket **sockp, __u32 ip, int port, int backlog);
+int lnet_sock_listen(struct socket **sockp, __u32 ip, int port, int backlog,
+		     struct net *ns);
 int lnet_sock_accept(struct socket **newsockp, struct socket *sock);
 int lnet_sock_connect(struct socket **sockp, int *fatal,
 			__u32 local_ip, int local_port,
-			__u32 peer_ip, int peer_port);
+			__u32 peer_ip, int peer_port, struct net *ns);
 
 int lnet_peers_start_down(void);
 int lnet_peer_buffer_credits(struct lnet_net *net);
diff --git a/drivers/staging/lustrefsx/lnet/include/lnet/lnetctl.h b/drivers/staging/lustrefsx/lnet/include/lnet/lnetctl.h
index bdd0cb4f8408..4328135c5ec7 100644
--- a/drivers/staging/lustrefsx/lnet/include/lnet/lnetctl.h
+++ b/drivers/staging/lustrefsx/lnet/include/lnet/lnetctl.h
@@ -1,5 +1,5 @@
 /*
- *   This file is part of Lustre, https://wiki.hpdd.intel.com/
+ *   This file is part of Lustre, https://wiki.whamcloud.com/
  *
  *   Portals is free software; you can redistribute it and/or
  *   modify it under the terms of version 2 of the GNU General Public
diff --git a/drivers/staging/lustrefsx/lnet/klnds/o2iblnd/o2iblnd.c b/drivers/staging/lustrefsx/lnet/klnds/o2iblnd/o2iblnd.c
index 110b6e699f09..ba4090556550 100644
--- a/drivers/staging/lustrefsx/lnet/klnds/o2iblnd/o2iblnd.c
+++ b/drivers/staging/lustrefsx/lnet/klnds/o2iblnd/o2iblnd.c
@@ -728,6 +728,19 @@ kiblnd_get_scheduler(int cpt)
 	return NULL;
 }
 
+static unsigned int kiblnd_send_wrs(struct kib_conn *conn)
+{
+	/*
+	 * One WR for the LNet message
+	 * And ibc_max_frags for the transfer WRs
+	 */
+	unsigned int ret = 1 + conn->ibc_max_frags;
+
+	/* account for a maximum of ibc_queue_depth in-flight transfers */
+	ret *= conn->ibc_queue_depth;
+	return ret;
+}
+
 kib_conn_t *
 kiblnd_create_conn(kib_peer_ni_t *peer_ni, struct rdma_cm_id *cmid,
 		   int state, int version)
@@ -881,8 +894,6 @@ kiblnd_create_conn(kib_peer_ni_t *peer_ni, struct rdma_cm_id *cmid,
 
 	init_qp_attr->event_handler = kiblnd_qp_event;
 	init_qp_attr->qp_context = conn;
-	init_qp_attr->cap.max_send_wr = IBLND_SEND_WRS(conn);
-	init_qp_attr->cap.max_recv_wr = IBLND_RECV_WRS(conn);
 	init_qp_attr->cap.max_send_sge = *kiblnd_tunables.kib_wrq_sge;
 	init_qp_attr->cap.max_recv_sge = 1;
 	init_qp_attr->sq_sig_type = IB_SIGNAL_REQ_WR;
@@ -893,11 +904,14 @@ kiblnd_create_conn(kib_peer_ni_t *peer_ni, struct rdma_cm_id *cmid,
 	conn->ibc_sched = sched;
 
 	do {
+		init_qp_attr->cap.max_send_wr = kiblnd_send_wrs(conn);
+		init_qp_attr->cap.max_recv_wr = IBLND_RECV_WRS(conn);
+
 		rc = rdma_create_qp(cmid, conn->ibc_hdev->ibh_pd, init_qp_attr);
-		if (!rc || init_qp_attr->cap.max_send_wr < 16)
+		if (!rc || conn->ibc_queue_depth < 2)
 			break;
 
-		init_qp_attr->cap.max_send_wr -= init_qp_attr->cap.max_send_wr / 4;
+		conn->ibc_queue_depth--;
 	} while (rc);
 
 	if (rc) {
@@ -910,9 +924,12 @@ kiblnd_create_conn(kib_peer_ni_t *peer_ni, struct rdma_cm_id *cmid,
 		goto failed_2;
 	}
 
-	if (init_qp_attr->cap.max_send_wr != IBLND_SEND_WRS(conn))
-		CDEBUG(D_NET, "original send wr %d, created with %d\n",
-			IBLND_SEND_WRS(conn), init_qp_attr->cap.max_send_wr);
+	if (conn->ibc_queue_depth != peer_ni->ibp_queue_depth)
+		CWARN("peer %s - queue depth reduced from %u to %u"
+		      "  to allow for qp creation\n",
+		      libcfs_nid2str(peer_ni->ibp_nid),
+		      peer_ni->ibp_queue_depth,
+		      conn->ibc_queue_depth);
 
 	LIBCFS_FREE(init_qp_attr, sizeof(*init_qp_attr));
 
@@ -971,7 +988,6 @@ kiblnd_destroy_conn(kib_conn_t *conn, bool free_conn)
 {
 	struct rdma_cm_id *cmid = conn->ibc_cmid;
 	kib_peer_ni_t        *peer_ni = conn->ibc_peer;
-	int                rc;
 
 	LASSERT (!in_interrupt());
 	LASSERT (atomic_read(&conn->ibc_refcount) == 0);
@@ -1002,11 +1018,8 @@ kiblnd_destroy_conn(kib_conn_t *conn, bool free_conn)
 	if (cmid != NULL && cmid->qp != NULL)
 		rdma_destroy_qp(cmid);
 
-	if (conn->ibc_cq != NULL) {
-		rc = ib_destroy_cq(conn->ibc_cq);
-		if (rc != 0)
-			CWARN("Error destroying CQ: %d\n", rc);
-	}
+	if (conn->ibc_cq)
+		ib_destroy_cq(conn->ibc_cq);
 
 	if (conn->ibc_rx_pages != NULL)
 		kiblnd_unmap_rx_descs(conn);
@@ -1656,10 +1669,17 @@ kiblnd_create_fmr_pool(kib_fmr_poolset_t *fps, kib_fmr_pool_t **pp_fpo)
 
 	/* Check for FMR or FastReg support */
 	fpo->fpo_is_fmr = 0;
+#ifdef HAVE_IB_DEVICE_OPS
+	if (fpo->fpo_hdev->ibh_ibdev->ops.alloc_fmr &&
+	    fpo->fpo_hdev->ibh_ibdev->ops.dealloc_fmr &&
+	    fpo->fpo_hdev->ibh_ibdev->ops.map_phys_fmr &&
+	    fpo->fpo_hdev->ibh_ibdev->ops.unmap_fmr) {
+#else
 	if (fpo->fpo_hdev->ibh_ibdev->alloc_fmr &&
 	    fpo->fpo_hdev->ibh_ibdev->dealloc_fmr &&
 	    fpo->fpo_hdev->ibh_ibdev->map_phys_fmr &&
 	    fpo->fpo_hdev->ibh_ibdev->unmap_fmr) {
+#endif
 		LCONSOLE_INFO("Using FMR for registration\n");
 		fpo->fpo_is_fmr = 1;
 	} else if (dev_attr->device_cap_flags & IB_DEVICE_MEM_MGT_EXTENSIONS) {
@@ -1805,8 +1825,7 @@ kiblnd_fmr_pool_unmap(kib_fmr_t *fmr, int status)
 	fps = fpo->fpo_owner;
 	if (fpo->fpo_is_fmr) {
 		if (fmr->fmr_pfmr) {
-			rc = ib_fmr_pool_unmap(fmr->fmr_pfmr);
-			LASSERT(!rc);
+			ib_fmr_pool_unmap(fmr->fmr_pfmr);
 			fmr->fmr_pfmr = NULL;
 		}
 
@@ -2644,7 +2663,7 @@ kiblnd_dummy_callback(struct rdma_cm_id *cmid, struct rdma_cm_event *event)
 }
 
 static int
-kiblnd_dev_need_failover(kib_dev_t *dev)
+kiblnd_dev_need_failover(kib_dev_t *dev, struct net *ns)
 {
         struct rdma_cm_id  *cmid;
         struct sockaddr_in  srcaddr;
@@ -2666,8 +2685,8 @@ kiblnd_dev_need_failover(kib_dev_t *dev)
          *
          * a. rdma_bind_addr(), it will conflict with listener cmid
          * b. rdma_resolve_addr() to zero addr */
-        cmid = kiblnd_rdma_create_id(kiblnd_dummy_callback, dev, RDMA_PS_TCP,
-                                     IB_QPT_RC);
+	cmid = kiblnd_rdma_create_id(ns, kiblnd_dummy_callback, dev,
+				     RDMA_PS_TCP, IB_QPT_RC);
         if (IS_ERR(cmid)) {
                 rc = PTR_ERR(cmid);
                 CERROR("Failed to create cmid for failover: %d\n", rc);
@@ -2696,7 +2715,7 @@ kiblnd_dev_need_failover(kib_dev_t *dev)
 }
 
 int
-kiblnd_dev_failover(kib_dev_t *dev)
+kiblnd_dev_failover(kib_dev_t *dev, struct net *ns)
 {
 	struct list_head    zombie_tpo = LIST_HEAD_INIT(zombie_tpo);
 	struct list_head    zombie_ppo = LIST_HEAD_INIT(zombie_ppo);
@@ -2715,7 +2734,7 @@ kiblnd_dev_failover(kib_dev_t *dev)
                  dev->ibd_can_failover ||
                  dev->ibd_hdev == NULL);
 
-        rc = kiblnd_dev_need_failover(dev);
+	rc = kiblnd_dev_need_failover(dev, ns);
         if (rc <= 0)
                 goto out;
 
@@ -2736,7 +2755,7 @@ kiblnd_dev_failover(kib_dev_t *dev)
                 rdma_destroy_id(cmid);
         }
 
-        cmid = kiblnd_rdma_create_id(kiblnd_cm_callback, dev, RDMA_PS_TCP,
+	cmid = kiblnd_rdma_create_id(ns, kiblnd_cm_callback, dev, RDMA_PS_TCP,
                                      IB_QPT_RC);
         if (IS_ERR(cmid)) {
                 rc = PTR_ERR(cmid);
@@ -2857,7 +2876,7 @@ kiblnd_destroy_dev (kib_dev_t *dev)
 }
 
 static kib_dev_t *
-kiblnd_create_dev(char *ifname)
+kiblnd_create_dev(char *ifname, struct net *ns)
 {
         struct net_device *netdev;
         kib_dev_t         *dev;
@@ -2866,7 +2885,7 @@ kiblnd_create_dev(char *ifname)
         int                up;
         int                rc;
 
-	rc = lnet_ipif_query(ifname, &up, &ip, &netmask);
+	rc = lnet_ipif_query(ifname, &up, &ip, &netmask, ns);
         if (rc != 0) {
                 CERROR("Can't query IPoIB interface %s: %d\n",
                        ifname, rc);
@@ -2882,7 +2901,7 @@ kiblnd_create_dev(char *ifname)
         if (dev == NULL)
                 return NULL;
 
-        netdev = dev_get_by_name(&init_net, ifname);
+	netdev = dev_get_by_name(ns, ifname);
         if (netdev == NULL) {
                 dev->ibd_can_failover = 0;
         } else {
@@ -2897,7 +2916,7 @@ kiblnd_create_dev(char *ifname)
         strcpy(&dev->ibd_ifname[0], ifname);
 
         /* initialize the device */
-        rc = kiblnd_dev_failover(dev);
+	rc = kiblnd_dev_failover(dev, ns);
         if (rc != 0) {
                 CERROR("Can't initialize device: %d\n", rc);
                 LIBCFS_FREE(dev, sizeof(*dev));
@@ -3056,7 +3075,7 @@ kiblnd_shutdown(struct lnet_ni *ni)
 }
 
 static int
-kiblnd_base_startup(void)
+kiblnd_base_startup(struct net *ns)
 {
 	struct kib_sched_info	*sched;
 	int			rc;
@@ -3129,7 +3148,7 @@ kiblnd_base_startup(void)
         }
 
 	if (*kiblnd_tunables.kib_dev_failover != 0)
-		rc = kiblnd_thread_start(kiblnd_failover_thread, NULL,
+		rc = kiblnd_thread_start(kiblnd_failover_thread, ns,
 					 "kiblnd_failover");
 
         if (rc != 0) {
@@ -3262,7 +3281,7 @@ kiblnd_startup(struct lnet_ni *ni)
         LASSERT (ni->ni_net->net_lnd == &the_o2iblnd);
 
         if (kiblnd_data.kib_init == IBLND_INIT_NOTHING) {
-                rc = kiblnd_base_startup();
+		rc = kiblnd_base_startup(ni->ni_net_ns);
                 if (rc != 0)
                         return rc;
         }
@@ -3300,7 +3319,7 @@ kiblnd_startup(struct lnet_ni *ni)
 	newdev = ibdev == NULL;
 	/* hmm...create kib_dev even for alias */
 	if (ibdev == NULL || strcmp(&ibdev->ibd_ifname[0], ifname) != 0)
-		ibdev = kiblnd_create_dev(ifname);
+		ibdev = kiblnd_create_dev(ifname, ni->ni_net_ns);
 
 	if (ibdev == NULL)
 		goto failed;
diff --git a/drivers/staging/lustrefsx/lnet/klnds/o2iblnd/o2iblnd.h b/drivers/staging/lustrefsx/lnet/klnds/o2iblnd/o2iblnd.h
index d8ad1421092d..c7dabdf6b98b 100644
--- a/drivers/staging/lustrefsx/lnet/klnds/o2iblnd/o2iblnd.h
+++ b/drivers/staging/lustrefsx/lnet/klnds/o2iblnd/o2iblnd.h
@@ -43,7 +43,6 @@
 
 #endif
 
-#include <linux/version.h>
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/kthread.h>
@@ -65,9 +64,6 @@
 #include <linux/kmod.h>
 #include <linux/sysctl.h>
 #include <linux/pci.h>
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,32)
-#include <linux/pci-dma.h>
-#endif
 
 #include <net/sock.h>
 #include <linux/in.h>
@@ -125,15 +121,16 @@ extern kib_tunables_t  kiblnd_tunables;
 					t->lnd_peercredits_hiw)
 
 #ifdef HAVE_RDMA_CREATE_ID_5ARG
-# define kiblnd_rdma_create_id(cb, dev, ps, qpt) rdma_create_id(current->nsproxy->net_ns, \
-								cb, dev, \
-								ps, qpt)
+# define kiblnd_rdma_create_id(ns, cb, dev, ps, qpt) rdma_create_id(ns, cb, \
+								    dev, ps, \
+								    qpt)
 #else
 # ifdef HAVE_RDMA_CREATE_ID_4ARG
-#  define kiblnd_rdma_create_id(cb, dev, ps, qpt) rdma_create_id(cb, dev, \
-								 ps, qpt)
+#  define kiblnd_rdma_create_id(ns, cb, dev, ps, qpt) rdma_create_id(cb, dev, \
+								     ps, qpt)
 # else
-#  define kiblnd_rdma_create_id(cb, dev, ps, qpt) rdma_create_id(cb, dev, ps)
+#  define kiblnd_rdma_create_id(ns, cb, dev, ps, qpt) rdma_create_id(cb, dev, \
+								     ps)
 # endif
 #endif
 
@@ -161,10 +158,9 @@ extern kib_tunables_t  kiblnd_tunables;
 
 /* WRs and CQEs (per connection) */
 #define IBLND_RECV_WRS(c)            IBLND_RX_MSGS(c)
-#define IBLND_SEND_WRS(c)	\
-	((c->ibc_max_frags + 1) * kiblnd_concurrent_sends(c->ibc_version, \
-							  c->ibc_peer->ibp_ni))
-#define IBLND_CQ_ENTRIES(c)         (IBLND_RECV_WRS(c) + IBLND_SEND_WRS(c))
+
+/* 2 = LNet msg + Transfer chain */
+#define IBLND_CQ_ENTRIES(c)	(IBLND_RECV_WRS(c) + kiblnd_send_wrs(c))
 
 struct kib_hca_dev;
 
@@ -578,7 +574,7 @@ typedef struct kib_rx                           /* receive message */
 	/* message buffer (I/O addr) */
 	__u64			rx_msgaddr;
 	/* for dma_unmap_single() */
-	DECLARE_PCI_UNMAP_ADDR(rx_msgunmap);
+	DEFINE_DMA_UNMAP_ADDR(rx_msgunmap);
 	/* receive work item... */
 	struct ib_recv_wr	rx_wrq;
 	/* ...and its memory */
@@ -617,7 +613,7 @@ typedef struct kib_tx                           /* transmit message */
 	/* message buffer (I/O addr) */
 	__u64			tx_msgaddr;
 	/* for dma_unmap_single() */
-	DECLARE_PCI_UNMAP_ADDR(tx_msgunmap);
+	DEFINE_DMA_UNMAP_ADDR(tx_msgunmap);
 	/** sge for tx_msgaddr */
 	struct ib_sge		tx_msgsge;
 	/* # send work items */
@@ -1157,6 +1153,12 @@ static inline void kiblnd_dma_unmap_sg(struct ib_device *dev,
         ib_dma_unmap_sg(dev, sg, nents, direction);
 }
 
+#ifndef HAVE_IB_SG_DMA_ADDRESS
+#include <linux/scatterlist.h>
+#define ib_sg_dma_address(dev, sg)	sg_dma_address(sg)
+#define ib_sg_dma_len(dev, sg)		sg_dma_len(sg)
+#endif
+
 static inline __u64 kiblnd_sg_dma_address(struct ib_device *dev,
                                           struct scatterlist *sg)
 {
@@ -1204,7 +1206,7 @@ int  kiblnd_cm_callback(struct rdma_cm_id *cmid,
                         struct rdma_cm_event *event);
 int  kiblnd_translate_mtu(int value);
 
-int  kiblnd_dev_failover(kib_dev_t *dev);
+int  kiblnd_dev_failover(kib_dev_t *dev, struct net *ns);
 int kiblnd_create_peer(struct lnet_ni *ni, kib_peer_ni_t **peerp,
 		       lnet_nid_t nid);
 void kiblnd_destroy_peer (kib_peer_ni_t *peer);
diff --git a/drivers/staging/lustrefsx/lnet/klnds/o2iblnd/o2iblnd_cb.c b/drivers/staging/lustrefsx/lnet/klnds/o2iblnd/o2iblnd_cb.c
index 42147c7b01e6..751a4211c835 100644
--- a/drivers/staging/lustrefsx/lnet/klnds/o2iblnd/o2iblnd_cb.c
+++ b/drivers/staging/lustrefsx/lnet/klnds/o2iblnd/o2iblnd_cb.c
@@ -192,7 +192,12 @@ kiblnd_post_rx (kib_rx_t *rx, int credit)
 	 * own this rx (and rx::rx_conn) anymore, LU-5678.
 	 */
 	kiblnd_conn_addref(conn);
+#ifdef HAVE_IB_POST_SEND_RECV_CONST
+	rc = ib_post_recv(conn->ibc_cmid->qp, &rx->rx_wrq,
+			  (const struct ib_recv_wr **)&bad_wrq);
+#else
 	rc = ib_post_recv(conn->ibc_cmid->qp, &rx->rx_wrq, &bad_wrq);
+#endif
 	if (unlikely(rc != 0)) {
 		CERROR("Can't post rx for %s: %d, bad_wrq: %p\n",
 		       libcfs_nid2str(conn->ibc_peer->ibp_nid), rc, bad_wrq);
@@ -841,7 +846,12 @@ __must_hold(&conn->ibc_lock)
 			 libcfs_nid2str(conn->ibc_peer->ibp_nid));
 
 		bad = NULL;
+#ifdef HAVE_IB_POST_SEND_RECV_CONST
+		rc = ib_post_send(conn->ibc_cmid->qp, wr,
+				  (const struct ib_send_wr **)&bad);
+#else
 		rc = ib_post_send(conn->ibc_cmid->qp, wr, &bad);
+#endif
 	}
 
         conn->ibc_last_send = jiffies;
@@ -1252,8 +1262,9 @@ kiblnd_connect_peer (kib_peer_ni_t *peer_ni)
         LASSERT (net != NULL);
         LASSERT (peer_ni->ibp_connecting > 0);
 
-        cmid = kiblnd_rdma_create_id(kiblnd_cm_callback, peer_ni, RDMA_PS_TCP,
-                                     IB_QPT_RC);
+	cmid = kiblnd_rdma_create_id(peer_ni->ibp_ni->ni_net_ns,
+				     kiblnd_cm_callback, peer_ni,
+				     RDMA_PS_TCP, IB_QPT_RC);
 
         if (IS_ERR(cmid)) {
                 CERROR("Can't create CMID for %s: %ld\n",
@@ -3680,6 +3691,7 @@ kiblnd_failover_thread(void *arg)
 {
 	rwlock_t	*glock = &kiblnd_data.kib_global_lock;
 	kib_dev_t	*dev;
+	struct net *ns = arg;
 	wait_queue_entry_t wait;
 	unsigned long	 flags;
 	int		 rc;
@@ -3709,7 +3721,7 @@ kiblnd_failover_thread(void *arg)
                         dev->ibd_failover = 1;
 			write_unlock_irqrestore(glock, flags);
 
-			rc = kiblnd_dev_failover(dev);
+			rc = kiblnd_dev_failover(dev, ns);
 
 			write_lock_irqsave(glock, flags);
 
diff --git a/drivers/staging/lustrefsx/lnet/klnds/socklnd/socklnd.c b/drivers/staging/lustrefsx/lnet/klnds/socklnd/socklnd.c
index c66870631aa9..541504ba88d1 100644
--- a/drivers/staging/lustrefsx/lnet/klnds/socklnd/socklnd.c
+++ b/drivers/staging/lustrefsx/lnet/klnds/socklnd/socklnd.c
@@ -2621,7 +2621,7 @@ ksocknal_shutdown(struct lnet_ni *ni)
 }
 
 static int
-ksocknal_enumerate_interfaces(ksock_net_t *net)
+ksocknal_enumerate_interfaces(ksock_net_t *net, struct net *ns)
 {
         char      **names;
         int         i;
@@ -2629,7 +2629,7 @@ ksocknal_enumerate_interfaces(ksock_net_t *net)
         int         rc;
         int         n;
 
-	n = lnet_ipif_enumerate(&names);
+	n = lnet_ipif_enumerate(&names, ns);
         if (n <= 0) {
                 CERROR("Can't enumerate interfaces: %d\n", n);
                 return n;
@@ -2643,7 +2643,7 @@ ksocknal_enumerate_interfaces(ksock_net_t *net)
                 if (!strcmp(names[i], "lo")) /* skip the loopback IF */
                         continue;
 
-		rc = lnet_ipif_query(names[i], &up, &ip, &mask);
+		rc = lnet_ipif_query(names[i], &up, &ip, &mask, ns);
                 if (rc != 0) {
                         CWARN("Can't get interface %s info: %d\n",
                               names[i], rc);
@@ -2830,7 +2830,7 @@ ksocknal_startup(struct lnet_ni *ni)
 
 
 	if (ni->ni_interfaces[0] == NULL) {
-		rc = ksocknal_enumerate_interfaces(net);
+		rc = ksocknal_enumerate_interfaces(net, ni->ni_net_ns);
 		if (rc <= 0)
 			goto fail_1;
 
@@ -2844,7 +2844,8 @@ ksocknal_startup(struct lnet_ni *ni)
 
 			rc = lnet_ipif_query(ni->ni_interfaces[i], &up,
 				&net->ksnn_interfaces[i].ksni_ipaddr,
-				&net->ksnn_interfaces[i].ksni_netmask);
+				&net->ksnn_interfaces[i].ksni_netmask,
+				ni->ni_net_ns);
 
 			if (rc != 0) {
 				CERROR("Can't get interface %s info: %d\n",
@@ -2866,7 +2867,7 @@ ksocknal_startup(struct lnet_ni *ni)
 		net->ksnn_ninterfaces = i;
 	}
 
-	net_dev = dev_get_by_name(&init_net,
+	net_dev = dev_get_by_name(ni->ni_net_ns,
 				  net->ksnn_interfaces[0].ksni_name);
 	if (net_dev != NULL) {
 		node_id = dev_to_node(&net_dev->dev);
diff --git a/drivers/staging/lustrefsx/lnet/klnds/socklnd/socklnd_cb.c b/drivers/staging/lustrefsx/lnet/klnds/socklnd/socklnd_cb.c
index 8892aad0403d..83c6a2da2f4a 100644
--- a/drivers/staging/lustrefsx/lnet/klnds/socklnd/socklnd_cb.c
+++ b/drivers/staging/lustrefsx/lnet/klnds/socklnd/socklnd_cb.c
@@ -8,7 +8,7 @@
  *   Author: Phil Schwan <phil@clusterfs.com>
  *   Author: Eric Barton <eric@bartonsoftware.com>
  *
- *   This file is part of Lustre, https://wiki.hpdd.intel.com/
+ *   This file is part of Lustre, https://wiki.whamcloud.com/
  *
  *   Portals is free software; you can redistribute it and/or
  *   modify it under the terms of version 2 of the GNU General Public
@@ -1913,7 +1913,8 @@ ksocknal_connect (ksock_route_t *route)
 
                 rc = lnet_connect(&sock, peer_ni->ksnp_id.nid,
                                   route->ksnr_myipaddr,
-                                  route->ksnr_ipaddr, route->ksnr_port);
+				  route->ksnr_ipaddr, route->ksnr_port,
+				  peer_ni->ksnp_ni->ni_net_ns);
                 if (rc != 0)
                         goto failed;
 
diff --git a/drivers/staging/lustrefsx/lnet/klnds/socklnd/socklnd_proto.c b/drivers/staging/lustrefsx/lnet/klnds/socklnd/socklnd_proto.c
index 98109ec2ff7b..42dff10fdb56 100644
--- a/drivers/staging/lustrefsx/lnet/klnds/socklnd/socklnd_proto.c
+++ b/drivers/staging/lustrefsx/lnet/klnds/socklnd/socklnd_proto.c
@@ -8,7 +8,7 @@
  *   Author: Phil Schwan <phil@clusterfs.com>
  *   Author: Eric Barton <eric@bartonsoftware.com>
  *
- *   This file is part of Lustre, https://wiki.hpdd.intel.com/
+ *   This file is part of Lustre, https://wiki.whamcloud.com/
  *
  *   Portals is free software; you can redistribute it and/or
  *   modify it under the terms of version 2 of the GNU General Public
diff --git a/drivers/staging/lustrefsx/lnet/lnet/acceptor.c b/drivers/staging/lustrefsx/lnet/lnet/acceptor.c
index 885cd85a8c20..8d3d6030d7d3 100644
--- a/drivers/staging/lustrefsx/lnet/lnet/acceptor.c
+++ b/drivers/staging/lustrefsx/lnet/lnet/acceptor.c
@@ -32,6 +32,7 @@
 
 #define DEBUG_SUBSYSTEM S_LNET
 
+#include <linux/nsproxy.h>
 #include <linux/completion.h>
 #include <net/sock.h>
 #include <lnet/lib-lnet.h>
@@ -44,6 +45,7 @@ static struct {
 	int			pta_shutdown;
 	struct socket		*pta_sock;
 	struct completion	pta_signal;
+	struct net		*pta_ns;
 } lnet_acceptor_state = {
 	.pta_shutdown = 1
 };
@@ -150,7 +152,7 @@ EXPORT_SYMBOL(lnet_connect_console_error);
 
 int
 lnet_connect(struct socket **sockp, lnet_nid_t peer_nid,
-	    __u32 local_ip, __u32 peer_ip, int peer_port)
+	    __u32 local_ip, __u32 peer_ip, int peer_port, struct net *ns)
 {
 	struct lnet_acceptor_connreq cr;
 	struct socket		*sock;
@@ -167,7 +169,7 @@ lnet_connect(struct socket **sockp, lnet_nid_t peer_nid,
 
 		rc = lnet_sock_connect(&sock, &fatal,
 					 local_ip, port,
-					 peer_ip, peer_port);
+					 peer_ip, peer_port, ns);
 		if (rc != 0) {
 			if (fatal)
 				goto failed;
@@ -354,7 +356,8 @@ lnet_acceptor(void *arg)
 	cfs_block_allsigs();
 
 	rc = lnet_sock_listen(&lnet_acceptor_state.pta_sock,
-				0, accept_port, accept_backlog);
+			      0, accept_port, accept_backlog,
+			      lnet_acceptor_state.pta_ns);
 	if (rc != 0) {
 		if (rc == -EADDRINUSE)
 			LCONSOLE_ERROR_MSG(0x122, "Can't start acceptor on port"
@@ -479,6 +482,7 @@ lnet_acceptor_start(void)
 	if (lnet_count_acceptor_nets() == 0)  /* not required */
 		return 0;
 
+	lnet_acceptor_state.pta_ns = current->nsproxy->net_ns;
 	task = kthread_run(lnet_acceptor, (void *)(uintptr_t)secure,
 			   "acceptor_%03ld", secure);
 	if (IS_ERR(task)) {
diff --git a/drivers/staging/lustrefsx/lnet/lnet/config.c b/drivers/staging/lustrefsx/lnet/lnet/config.c
index 2c15e1f5f79a..8b790353c60a 100644
--- a/drivers/staging/lustrefsx/lnet/lnet/config.c
+++ b/drivers/staging/lustrefsx/lnet/lnet/config.c
@@ -173,7 +173,7 @@ lnet_net_append_cpts(__u32 *cpts, __u32 ncpts, struct lnet_net *net)
 		LIBCFS_ALLOC(net->net_cpts, sizeof(*net->net_cpts) * ncpts);
 		if (net->net_cpts == NULL)
 			return -ENOMEM;
-		memcpy(net->net_cpts, cpts, ncpts);
+		memcpy(net->net_cpts, cpts, ncpts * sizeof(*net->net_cpts));
 		net->net_ncpts = ncpts;
 		return 0;
 	}
@@ -1607,7 +1607,7 @@ lnet_ipaddr_free_enumeration(__u32 *ipaddrs, int nip)
 }
 
 static int
-lnet_ipaddr_enumerate (__u32 **ipaddrsp)
+lnet_ipaddr_enumerate(__u32 **ipaddrsp, struct net *ns)
 {
 	int	   up;
 	__u32	   netmask;
@@ -1615,7 +1615,7 @@ lnet_ipaddr_enumerate (__u32 **ipaddrsp)
 	__u32	  *ipaddrs2;
 	int	   nip;
 	char	 **ifnames;
-	int	   nif = lnet_ipif_enumerate(&ifnames);
+	int	   nif = lnet_ipif_enumerate(&ifnames, ns);
 	int	   i;
 	int	   rc;
 
@@ -1634,7 +1634,7 @@ lnet_ipaddr_enumerate (__u32 **ipaddrsp)
 			continue;
 
 		rc = lnet_ipif_query(ifnames[i], &up,
-				       &ipaddrs[nip], &netmask);
+				       &ipaddrs[nip], &netmask, ns);
 		if (rc != 0) {
 			CWARN("Can't query interface %s: %d\n",
 			      ifnames[i], rc);
@@ -1676,9 +1676,11 @@ int
 lnet_parse_ip2nets (char **networksp, char *ip2nets)
 {
 	__u32	  *ipaddrs = NULL;
-	int	   nip = lnet_ipaddr_enumerate(&ipaddrs);
+	int	   nip;
 	int	   rc;
 
+	nip = lnet_ipaddr_enumerate(&ipaddrs, current->nsproxy->net_ns);
+
 	if (nip < 0) {
 		LCONSOLE_ERROR_MSG(0x117, "Error %d enumerating local IP "
 				   "interfaces for ip2nets to match\n", nip);
diff --git a/drivers/staging/lustrefsx/lnet/lnet/lib-socket.c b/drivers/staging/lustrefsx/lnet/lnet/lib-socket.c
index faa8fc3a0110..c46ab8471476 100644
--- a/drivers/staging/lustrefsx/lnet/lnet/lib-socket.c
+++ b/drivers/staging/lustrefsx/lnet/lnet/lib-socket.c
@@ -44,16 +44,39 @@
 #include <lnet/lib-lnet.h>
 
 /*
- * Deal with the post-5.0 rename of these in-kernel values.
+ * kernel 5.1: commit 7f1bc6e95d7840d4305595b3e4025cddda88cee5
+ * Y2038 64-bit time.
+ *  SO_TIMESTAMP, SO_TIMESTAMPNS and SO_TIMESTAMPING options, the
+ *  way they are currently defined, are not y2038 safe.
+ *  Subsequent patches in the series add new y2038 safe versions
+ *  of these options which provide 64 bit timestamps on all
+ *  architectures uniformly.
+ *  Hence, rename existing options with OLD tag suffixes.
+ *
+ * NOTE: When updating to timespec64 change change these to '_NEW'.
+ *
  */
-#if !defined(SO_RCVTIMEO) && defined(SO_RCVTIMEO_OLD)
+#ifndef SO_SNDTIMEO
+#define SO_SNDTIMEO SO_SNDTIMEO_OLD
+#endif
+
+#ifndef SO_RCVTIMEO
 #define SO_RCVTIMEO SO_RCVTIMEO_OLD
 #endif
 
-#if !defined(SO_SNDTIMEO) && defined(SO_SNDTIMEO_OLD)
-#define SO_SNDTIMEO SO_SNDTIMEO_OLD
+static int
+lnet_sock_create_kern(struct socket **sock, struct net *ns)
+{
+	int rc;
+
+#ifdef HAVE_SOCK_CREATE_KERN_USE_NET
+	rc = sock_create_kern(ns, PF_INET, SOCK_STREAM, 0, sock);
+#else
+	rc = sock_create_kern(PF_INET, SOCK_STREAM, 0, sock);
 #endif
 
+	return rc;
+}
 
 static int
 kernel_sock_unlocked_ioctl(struct file *filp, int cmd, unsigned long arg)
@@ -69,18 +92,14 @@ kernel_sock_unlocked_ioctl(struct file *filp, int cmd, unsigned long arg)
 }
 
 static int
-lnet_sock_ioctl(int cmd, unsigned long arg)
+lnet_sock_ioctl(int cmd, unsigned long arg, struct net *ns)
 {
 	struct file    *sock_filp;
 	struct socket  *sock;
 	int		fd = -1;
 	int		rc;
 
-#ifdef HAVE_SOCK_CREATE_KERN_USE_NET
-	rc = sock_create_kern(&init_net, PF_INET, SOCK_STREAM, 0, &sock);
-#else
-	rc = sock_create_kern(PF_INET, SOCK_STREAM, 0, &sock);
-#endif
+	rc = lnet_sock_create_kern(&sock, ns);
 	if (rc != 0) {
 		CERROR("Can't create socket: %d\n", rc);
 		return rc;
@@ -121,7 +140,7 @@ lnet_sock_ioctl(int cmd, unsigned long arg)
 }
 
 int
-lnet_ipif_query(char *name, int *up, __u32 *ip, __u32 *mask)
+lnet_ipif_query(char *name, int *up, __u32 *ip, __u32 *mask, struct net *ns)
 {
 	struct ifreq	ifr;
 	int		nob;
@@ -140,7 +159,7 @@ lnet_ipif_query(char *name, int *up, __u32 *ip, __u32 *mask)
 		return -E2BIG;
 	strncpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
 
-	rc = lnet_sock_ioctl(SIOCGIFFLAGS, (unsigned long)&ifr);
+	rc = lnet_sock_ioctl(SIOCGIFFLAGS, (unsigned long)&ifr, ns);
 	if (rc != 0) {
 		CERROR("Can't get flags for interface %s\n", name);
 		return rc;
@@ -159,7 +178,7 @@ lnet_ipif_query(char *name, int *up, __u32 *ip, __u32 *mask)
 	strncpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
 
 	ifr.ifr_addr.sa_family = AF_INET;
-	rc = lnet_sock_ioctl(SIOCGIFADDR, (unsigned long)&ifr);
+	rc = lnet_sock_ioctl(SIOCGIFADDR, (unsigned long)&ifr, ns);
 
 	if (rc != 0) {
 		CERROR("Can't get IP address for interface %s\n", name);
@@ -174,7 +193,7 @@ lnet_ipif_query(char *name, int *up, __u32 *ip, __u32 *mask)
 	strncpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
 
 	ifr.ifr_addr.sa_family = AF_INET;
-	rc = lnet_sock_ioctl(SIOCGIFNETMASK, (unsigned long)&ifr);
+	rc = lnet_sock_ioctl(SIOCGIFNETMASK, (unsigned long)&ifr, ns);
 	if (rc != 0) {
 		CERROR("Can't get netmask for interface %s\n", name);
 		return rc;
@@ -202,7 +221,7 @@ lnet_ipif_free_enumeration(char **names, int n)
 EXPORT_SYMBOL(lnet_ipif_free_enumeration);
 
 int
-lnet_ipif_enumerate(char ***namesp)
+lnet_ipif_enumerate(char ***namesp, struct net *ns)
 {
 	/* Allocate and fill in 'names', returning # interfaces/error */
 	char	      **names;
@@ -236,7 +255,7 @@ lnet_ipif_enumerate(char ***namesp)
 		ifc.ifc_buf = (char *)ifr;
 		ifc.ifc_len = nalloc * sizeof(*ifr);
 
-		rc = lnet_sock_ioctl(SIOCGIFCONF, (unsigned long)&ifc);
+		rc = lnet_sock_ioctl(SIOCGIFCONF, (unsigned long)&ifc, ns);
 		if (rc < 0) {
 			CERROR("Error %d enumerating interfaces\n", rc);
 			goto out1;
@@ -423,7 +442,7 @@ EXPORT_SYMBOL(lnet_sock_read);
 
 static int
 lnet_sock_create(struct socket **sockp, int *fatal,
-		 __u32 local_ip, int local_port)
+		 __u32 local_ip, int local_port, struct net *ns)
 {
 	struct sockaddr_in  locaddr;
 	struct socket	   *sock;
@@ -433,11 +452,7 @@ lnet_sock_create(struct socket **sockp, int *fatal,
 	/* All errors are fatal except bind failure if the port is in use */
 	*fatal = 1;
 
-#ifdef HAVE_SOCK_CREATE_KERN_USE_NET
-	rc = sock_create_kern(&init_net, PF_INET, SOCK_STREAM, 0, &sock);
-#else
-	rc = sock_create_kern(PF_INET, SOCK_STREAM, 0, &sock);
-#endif
+	rc = lnet_sock_create_kern(&sock, ns);
 	*sockp = sock;
 	if (rc != 0) {
 		CERROR("Can't create socket: %d\n", rc);
@@ -514,23 +529,18 @@ int
 lnet_sock_getaddr(struct socket *sock, bool remote, __u32 *ip, int *port)
 {
 	struct sockaddr_in sin;
-	int		   rc;
+	int rc;
+#ifndef HAVE_KERN_SOCK_GETNAME_2ARGS
+	int len = sizeof(sin);
+#endif
 
-#ifdef HAVE_KERNSOCK_RETURNSLEN
 	if (remote)
-		rc = kernel_getpeername(sock, (struct sockaddr *)&sin);
+		rc = lnet_kernel_getpeername(sock,
+					     (struct sockaddr *)&sin, &len);
 	else
-		rc = kernel_getsockname(sock, (struct sockaddr *)&sin);
+		rc = lnet_kernel_getsockname(sock,
+					     (struct sockaddr *)&sin, &len);
 	if (rc < 0) {
-#else
-	int		   len = sizeof(sin);
-
-	if (remote)
-		rc = kernel_getpeername(sock, (struct sockaddr *)&sin, &len);
-	else
-		rc = kernel_getsockname(sock, (struct sockaddr *)&sin, &len);
-	if (rc != 0) {
-#endif
 		CERROR("Error %d getting sock %s IP/port\n",
 			rc, remote ? "peer" : "local");
 		return rc;
@@ -561,12 +571,12 @@ EXPORT_SYMBOL(lnet_sock_getbuf);
 
 int
 lnet_sock_listen(struct socket **sockp,
-		   __u32 local_ip, int local_port, int backlog)
+		   __u32 local_ip, int local_port, int backlog, struct net *ns)
 {
 	int	 fatal;
 	int	 rc;
 
-	rc = lnet_sock_create(sockp, &fatal, local_ip, local_port);
+	rc = lnet_sock_create(sockp, &fatal, local_ip, local_port, ns);
 	if (rc != 0) {
 		if (!fatal)
 			CERROR("Can't create socket: port %d already in use\n",
@@ -640,12 +650,13 @@ lnet_sock_accept(struct socket **newsockp, struct socket *sock)
 int
 lnet_sock_connect(struct socket **sockp, int *fatal,
 		  __u32 local_ip, int local_port,
-		  __u32 peer_ip, int peer_port)
+		  __u32 peer_ip, int peer_port,
+		  struct net *ns)
 {
 	struct sockaddr_in  srvaddr;
 	int		    rc;
 
-	rc = lnet_sock_create(sockp, fatal, local_ip, local_port);
+	rc = lnet_sock_create(sockp, fatal, local_ip, local_port, ns);
 	if (rc != 0)
 		return rc;
 
diff --git a/drivers/staging/lustrefsx/lnet/lnet/router.c b/drivers/staging/lustrefsx/lnet/lnet/router.c
index f35b67e2d7bb..bd30963a960d 100644
--- a/drivers/staging/lustrefsx/lnet/lnet/router.c
+++ b/drivers/staging/lustrefsx/lnet/lnet/router.c
@@ -3,7 +3,7 @@
  *
  * Copyright (c) 2011, 2016, Intel Corporation.
  *
- *   This file is part of Lustre, https://wiki.hpdd.intel.com/
+ *   This file is part of Lustre, https://wiki.whamcloud.com/
  *
  *   Portals is free software; you can redistribute it and/or
  *   modify it under the terms of version 2 of the GNU General Public
diff --git a/drivers/staging/lustrefsx/lnet/lnet/router_proc.c b/drivers/staging/lustrefsx/lnet/lnet/router_proc.c
index 2f6b0c76d7b7..da73b32ea937 100644
--- a/drivers/staging/lustrefsx/lnet/lnet/router_proc.c
+++ b/drivers/staging/lustrefsx/lnet/lnet/router_proc.c
@@ -3,7 +3,7 @@
  *
  * Copyright (c) 2011, 2015, Intel Corporation.
  *
- *   This file is part of Lustre, https://wiki.hpdd.intel.com/
+ *   This file is part of Lustre, https://wiki.whamcloud.com/
  *
  *   Portals is free software; you can redistribute it and/or
  *   modify it under the terms of version 2 of the GNU General Public
diff --git a/drivers/staging/lustrefsx/lustre/LICENSE b/drivers/staging/lustrefsx/lustre/LICENSE
new file mode 100644
index 000000000000..edb73cdedca6
--- /dev/null
+++ b/drivers/staging/lustrefsx/lustre/LICENSE
@@ -0,0 +1,372 @@
+Each file in this distribution contains a header stating the copyright
+owner(s), and the licensing terms for that file.  Some files are not
+eligible for copyright protection, and contain neither.
+
+There are many files which may be covered by a separate license that
+you signed or otherwise agreed to before downloading this software.
+If you did not agree to such an agreement, or if the file does not
+mention that license, then you can redistribute and/or modify it under
+the terms of version 2 of the GNU General Public License.  Each file
+is very clear about which license is applicable.
+
+In any case, Lustre is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the license
+text for more details.
+
+Reproduced below is the GNU General Public License version 2, and
+Linus's clarifying statement from the Linux kernel source code:
+
+----------------------------------------
+
+   NOTE! This copyright does *not* cover user programs that use kernel
+ services by normal system calls - this is merely considered normal use
+ of the kernel, and does *not* fall under the heading of "derived work".
+ Also note that the GPL below is copyrighted by the Free Software
+ Foundation, but the instance of code that it refers to (the Linux
+ kernel) is copyrighted by me and others who actually wrote it.
+
+			Linus Torvalds
+
+----------------------------------------
+
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+                       59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) 19yy  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) 19yy name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
diff --git a/drivers/staging/lustrefsx/lustre/include/dt_object.h b/drivers/staging/lustrefsx/lustre/include/dt_object.h
index 7d8e702d76d7..e872981b5284 100644
--- a/drivers/staging/lustrefsx/lustre/include/dt_object.h
+++ b/drivers/staging/lustrefsx/lustre/include/dt_object.h
@@ -1919,7 +1919,6 @@ struct dt_txn_callback {
                              struct thandle *txn, void *cookie);
         int (*dtc_txn_stop)(const struct lu_env *env,
                             struct thandle *txn, void *cookie);
-        void (*dtc_txn_commit)(struct thandle *txn, void *cookie);
 	void			*dtc_cookie;
 	__u32			dtc_tag;
 	struct list_head	dtc_linkage;
@@ -1931,7 +1930,6 @@ void dt_txn_callback_del(struct dt_device *dev, struct dt_txn_callback *cb);
 int dt_txn_hook_start(const struct lu_env *env,
                       struct dt_device *dev, struct thandle *txn);
 int dt_txn_hook_stop(const struct lu_env *env, struct thandle *txn);
-void dt_txn_hook_commit(struct thandle *txn);
 
 int dt_try_as_dir(const struct lu_env *env, struct dt_object *obj);
 
diff --git a/drivers/staging/lustrefsx/lustre/include/lustre/lustre_idl.h b/drivers/staging/lustrefsx/lustre/include/lustre/lustre_idl.h
index e40b90ec65a2..f2c850c0f184 100644
--- a/drivers/staging/lustrefsx/lustre/include/lustre/lustre_idl.h
+++ b/drivers/staging/lustrefsx/lustre/include/lustre/lustre_idl.h
@@ -722,7 +722,7 @@ struct ptlrpc_body_v2 {
 #define OBD_CONNECT_LARGE_ACL		0x200ULL /* more than 32 ACL entries */
 #define OBD_CONNECT_TRUNCLOCK           0x400ULL /*locks on server for punch */
 #define OBD_CONNECT_TRANSNO             0x800ULL /*replay sends init transno */
-#define OBD_CONNECT_IBITS              0x1000ULL /*support for inodebits locks*/
+#define OBD_CONNECT_IBITS	       0x1000ULL /* not checked in 2.11+ */
 #define OBD_CONNECT_BARRIER	       0x2000ULL /* write barrier */
 #define OBD_CONNECT_ATTRFID            0x4000ULL /*Server can GetAttr By Fid*/
 #define OBD_CONNECT_NODEVOH            0x8000ULL /*No open hndl on specl nodes*/
@@ -870,8 +870,8 @@ struct ptlrpc_body_v2 {
 #define MGS_CONNECT_SUPPORTED2 0
 
 /* Features required for this version of the client to work with server */
-#define CLIENT_CONNECT_MDT_REQD (OBD_CONNECT_IBITS | OBD_CONNECT_FID | \
-                                 OBD_CONNECT_FULL20)
+#define CLIENT_CONNECT_MDT_REQD (OBD_CONNECT_FID |	\
+				 OBD_CONNECT_FULL20)
 
 /* This structure is used for both request and reply.
  *
@@ -1062,7 +1062,11 @@ struct lov_mds_md_v1 {            /* LOV EA mds/wire data (little-endian) */
 	struct lov_ost_data_v1 lmm_objects[0]; /* per-stripe data */
 };
 
-#define MAX_MD_SIZE (sizeof(struct lov_mds_md) + 4 * sizeof(struct lov_ost_data))
+#define MAX_MD_SIZE_OLD (sizeof(struct lov_mds_md) +			\
+			 4 * sizeof(struct lov_ost_data))
+#define MAX_MD_SIZE (sizeof(struct lov_comp_md_v1) +			\
+		     4 * (sizeof(struct lov_comp_md_entry_v1) +		\
+			  MAX_MD_SIZE_OLD))
 #define MIN_MD_SIZE (sizeof(struct lov_mds_md) + 1 * sizeof(struct lov_ost_data))
 
 /* This is the default MDT reply size allocated, should the striping be bigger,
@@ -1267,6 +1271,8 @@ struct hsm_state_set {
 
 #define OBD_BRW_LOCALS (OBD_BRW_LOCAL1)
 
+#define OBD_MAX_GRANT 0x7fffffffUL /* Max grant allowed to one client: 2 GiB */
+
 #define OBD_OBJECT_EOF LUSTRE_EOF
 
 #define OST_MIN_PRECREATE 32
@@ -1639,7 +1645,6 @@ enum {
 	 * 2. If these flags needs to be stored into inode, they will be
 	 * stored in LMA. see LMAI_XXXX */
 	LUSTRE_ORPHAN_FL = 0x00002000,
-	LUSTRE_SET_SYNC_FL = 0x00040000, /* Synchronous setattr on OSTs */
 
 	LUSTRE_LMA_FL_MASKS = LUSTRE_ORPHAN_FL,
 };
diff --git a/drivers/staging/lustrefsx/lustre/include/lustre/lustre_user.h b/drivers/staging/lustrefsx/lustre/include/lustre/lustre_user.h
index c014ed714919..67ed9768fcb2 100644
--- a/drivers/staging/lustrefsx/lustre/include/lustre/lustre_user.h
+++ b/drivers/staging/lustrefsx/lustre/include/lustre/lustre_user.h
@@ -50,12 +50,12 @@
 # include <linux/string.h> /* snprintf() */
 # include <linux/version.h>
 #else /* !__KERNEL__ */
-# define NEED_QUOTA_DEFS
 # include <limits.h>
 # include <stdbool.h>
 # include <stdio.h> /* snprintf() */
 # include <string.h>
-# include <sys/quota.h>
+# define NEED_QUOTA_DEFS
+/* # include <sys/quota.h> - this causes complaints about caddr_t */
 # include <sys/stat.h>
 #endif /* __KERNEL__ */
 #include <lustre/ll_fiemap.h>
@@ -73,7 +73,15 @@
     "project",	/* PRJQUOTA */ \
     "undefined", \
 };
+#ifndef USRQUOTA
+#define USRQUOTA 0
+#endif
+#ifndef GRPQUOTA
+#define GRPQUOTA 1
+#endif
+#ifndef PRJQUOTA
 #define PRJQUOTA 2
+#endif
 
 #if defined(__x86_64__) || defined(__ia64__) || defined(__ppc64__) || \
     defined(__craynv) || defined(__mips64__) || defined(__powerpc64__) || \
@@ -183,16 +191,51 @@ struct ost_layout {
 	__u32	ol_comp_id;
 } __attribute__((packed));
 
-/* keep this one for compatibility */
-struct filter_fid_old {
-	struct lu_fid	ff_parent;
-	__u64		ff_objid;
-	__u64		ff_seq;
+/* The filter_fid structure has changed several times over its lifetime.
+ * For a long time "trusted.fid" held the MDT inode parent FID/IGIF and
+ * stripe_index and the "self FID" (objid/seq) to be able to recover the
+ * OST objects in case of corruption.  With the move to 2.4 and OSD-API for
+ * the OST, the "trusted.lma" xattr was added to the OST objects to store
+ * the "self FID" to be consistent with the MDT on-disk format, and the
+ * filter_fid only stored the MDT inode parent FID and stripe index.
+ *
+ * In 2.10, the addition of PFL composite layouts required more information
+ * to be stored into the filter_fid in order to be able to identify which
+ * component the OST object belonged.  As well, the stripe size may vary
+ * between components, so it was no longer safe to assume the stripe size
+ * or stripe_count of a file.  This is also more robust for plain layouts.
+ *
+ * For ldiskfs OSTs that were formatted with 256-byte inodes, there is not
+ * enough space to store both the filter_fid and LMA in the inode, so they
+ * are packed into struct lustre_ost_attrs on disk in trusted.lma to avoid
+ * an extra seek for every OST object access.
+ *
+ * In 2.11, FLR mirror layouts also need to store the layout version and
+ * range so that writes to old versions of the layout are not allowed.
+ * That ensures that mirrored objects are not modified by evicted clients,
+ * and ensures that the components are correctly marked stale on the MDT.
+ */
+struct filter_fid_18_23 {
+	struct lu_fid		ff_parent;	/* stripe_idx in f_ver */
+	__u64			ff_objid;
+	__u64			ff_seq;
+};
+
+struct filter_fid_24_29 {
+	struct lu_fid		ff_parent;	/* stripe_idx in f_ver */
+};
+
+struct filter_fid_210 {
+	struct lu_fid		ff_parent;	/* stripe_idx in f_ver */
+	struct ost_layout	ff_layout;
 };
 
 struct filter_fid {
-	struct lu_fid		ff_parent;
+	struct lu_fid		ff_parent;	/* stripe_idx in f_ver */
 	struct ost_layout	ff_layout;
+	__u32			ff_layout_version;
+	__u32			ff_range; /* range of layout version that
+					   * write are allowed */
 } __attribute__((packed));
 
 /* Userspace should treat lu_fid as opaque, and only use the following methods
@@ -410,6 +453,9 @@ enum ll_lease_type {
 /* To be compatible with old statically linked binary we keep the check for
  * the older 0100000000 flag.  This is already removed upstream.  LU-812. */
 #define O_LOV_DELAY_CREATE_1_8	0100000000 /* FMODE_NONOTIFY masked in 2.6.36 */
+#ifndef FASYNC
+#define FASYNC			00020000   /* fcntl, for BSD compatibility */
+#endif
 #define O_LOV_DELAY_CREATE_MASK	(O_NOCTTY | FASYNC)
 #define O_LOV_DELAY_CREATE		(O_LOV_DELAY_CREATE_1_8 | \
 					 O_LOV_DELAY_CREATE_MASK)
diff --git a/drivers/staging/lustrefsx/lustre/include/lustre_compat.h b/drivers/staging/lustrefsx/lustre/include/lustre_compat.h
index 2fb308a998ac..408efb8953cb 100644
--- a/drivers/staging/lustrefsx/lustre/include/lustre_compat.h
+++ b/drivers/staging/lustrefsx/lustre/include/lustre_compat.h
@@ -38,6 +38,7 @@
 #include <linux/pagemap.h>
 #include <linux/bio.h>
 #include <linux/xattr.h>
+#include <linux/slab.h>
 
 #include <libcfs/libcfs.h>
 #include <lustre_patchless_compat.h>
@@ -111,14 +112,6 @@ static inline void ll_set_fs_pwd(struct fs_struct *fs, struct vfsmount *mnt,
 #define MODULE_ALIAS_FS(name)
 #endif
 
-#define LTIME_S(time)                   (time.tv_sec)
-
-#ifdef HAVE_INODE_TIME_64BIT
-#define LTIME_FMT "%llu"
-#else
-#define LTIME_FMT "%lu"
-#endif
-
 #ifdef HAVE_GENERIC_PERMISSION_2ARGS
 # define ll_generic_permission(inode, mask, flags, check_acl) \
 	 generic_permission(inode, mask)
@@ -329,6 +322,10 @@ static inline void set_nlink(struct inode *inode, unsigned int nlink)
 # define ll_umode_t	int
 #endif
 
+#ifndef HAVE_VM_FAULT_T
+#define vm_fault_t int
+#endif
+
 #include <linux/dcache.h>
 #ifndef HAVE_D_MAKE_ROOT
 static inline struct dentry *d_make_root(struct inode *root)
@@ -394,15 +391,17 @@ static inline int radix_tree_exceptional_entry(void *arg)
 }
 #endif
 
+#ifndef HAVE_XA_IS_VALUE
+static inline bool xa_is_value(void *entry)
+{
+	return radix_tree_exceptional_entry(entry);
+}
+#endif
+
 #ifndef HAVE_TRUNCATE_INODE_PAGES_FINAL
 static inline void truncate_inode_pages_final(struct address_space *map)
 {
 	truncate_inode_pages(map, 0);
-		/* Workaround for LU-118 */
-	if (map->nrpages) {
-		spin_lock_irq(&map->tree_lock);
-		spin_unlock_irq(&map->tree_lock);
-	}	/* Workaround end */
 }
 #endif
 
@@ -549,34 +548,23 @@ static inline bool is_sxid(umode_t mode)
 #endif
 
 /*
- * Upstream Linux kernel commit e462ec50cb5fad19f6003a3d8087f4a0945dd2b1
- * differentiated the MS_ values from SB_* values. We use SB_*
- * throughout, but account here for older kernels that do not have
- * SB_*. The values below are only the ones currently used in the Lustre
- * code.
+ * mount MS_* flags split from superblock SB_* flags
+ * if the SB_* flags are not available use the MS_* flags
  */
-
-#ifndef SB_RDONLY
-
-#define SB_RDONLY	MS_RDONLY
-#define SB_ACTIVE	MS_ACTIVE
-#define SB_NODIRATIME	MS_NODIRATIME
-
-#if defined(MS_POSIXACL)
-#define SB_POSIXACL MS_POSIXACL
+#if !defined(SB_RDONLY) && defined(MS_RDONLY)
+# define SB_RDONLY MS_RDONLY
 #endif
-
-#if defined(MS_NOSEC)
-#define SB_NOSEC MS_NOSEC
+#if !defined(SB_ACTIVE) && defined(MS_ACTIVE)
+# define SB_ACTIVE MS_ACTIVE
 #endif
-
+#if !defined(SB_NOSEC) && defined(MS_NOSEC)
+# define SB_NOSEC MS_NOSEC
 #endif
-
-#ifndef SB_NOSEC
-static inline void inode_has_no_xattr(struct inode *inode)
-{
-	return;
-}
+#if !defined(SB_POSIXACL) && defined(MS_POSIXACL)
+# define SB_POSIXACL MS_POSIXACL
+#endif
+#if !defined(SB_NODIRATIME) && defined(MS_NODIRATIME)
+# define SB_NODIRATIME MS_NODIRATIME
 #endif
 
 #ifndef HAVE_FILE_OPERATIONS_READ_WRITE_ITER
@@ -704,38 +692,22 @@ static inline struct timespec current_time(struct inode *inode)
 #define __GFP_COLD 0
 #endif
 
-#ifndef HAVE_ADDRESS_SPACE_XARRAY
-static inline void lock_mappings(struct address_space *mappings)
-{
-#ifdef HAVE_ADDRESS_SPACE_IPAGES
-	xa_lock_irq(&mappings->i_pages);
+#ifdef HAVE_I_PAGES
+#define page_tree i_pages
 #else
-	spin_lock_irq(&mappings->tree_lock);
+#define i_pages tree_lock
+#define xa_lock_irq(lockp) spin_lock_irq(lockp)
+#define xa_unlock_irq(lockp) spin_unlock_irq(lockp)
 #endif
-}
 
-static inline void unlock_mappings(struct address_space *mappings)
-{
-#ifdef HAVE_ADDRESS_SPACE_IPAGES
-	xa_unlock_irq(&mappings->i_pages);
-#else
-	spin_unlock_irq(&mappings->tree_lock);
-#endif
-}
-#endif
-
-#ifdef HAVE_TOTALRAM_PAGES_FUNC
-#define TOTALRAM_PAGES totalram_pages()
-#else
-#define TOTALRAM_PAGES totalram_pages
+#ifndef HAVE_LINUX_SELINUX_IS_ENABLED
+#define selinux_is_enabled() 1
 #endif
 
-#ifdef HAVE_VM_OPS_USE_VM_FAULT_ONLY
-# ifdef HAVE_VM_FAULT_T
-#  define VM_FAULT_T vm_fault_t
-# else
-#  define VM_FAULT_T int
-# endif
+#ifndef KMEM_CACHE_USERCOPY
+#define kmem_cache_create_usercopy(name, size, align, flags, useroffset, \
+				   usersize, ctor)			 \
+	kmem_cache_create(name, size, align, flags, ctor)
 #endif
 
 #endif /* _LUSTRE_COMPAT_H */
diff --git a/drivers/staging/lustrefsx/lustre/include/lustre_dlm.h b/drivers/staging/lustrefsx/lustre/include/lustre_dlm.h
index d1cb7c20cf82..3eed4226f85a 100644
--- a/drivers/staging/lustrefsx/lustre/include/lustre_dlm.h
+++ b/drivers/staging/lustrefsx/lustre/include/lustre_dlm.h
@@ -297,7 +297,7 @@ struct ldlm_valblock_ops {
 	/* Return size of lvb data appropriate RPC size can be reserved */
 	int (*lvbo_size)(struct ldlm_lock *lock);
 	/* Called to fill in lvb data to RPC buffer @buf */
-	int (*lvbo_fill)(struct ldlm_lock *lock, void *buf, int buflen);
+	int (*lvbo_fill)(struct ldlm_lock *lock, void *buf, int *buflen);
 };
 
 /**
@@ -416,6 +416,7 @@ struct ldlm_namespace {
 	struct list_head	ns_unused_list;
 	/** Number of locks in the LRU list above */
 	int			ns_nr_unused;
+	struct list_head	*ns_last_pos;
 
 	/**
 	 * Maximum number of locks permitted in the LRU. If 0, means locks
@@ -814,12 +815,6 @@ struct ldlm_lock {
 	 */
 	wait_queue_head_t	l_waitq;
 
-	/**
-	 * Seconds. It will be updated if there is any activity related to
-	 * the lock, e.g. enqueue the lock or send blocking AST.
-	 */
-	time64_t		l_last_activity;
-
 	/**
 	 * Time, in nanoseconds, last used by e.g. being matched by lock match.
 	 */
@@ -844,6 +839,16 @@ struct ldlm_lock {
 	/** Private storage for lock user. Opaque to LDLM. */
 	void			*l_ast_data;
 
+	union {
+	/**
+	 * Seconds. It will be updated if there is any activity related to
+	 * the lock at client, e.g. enqueue the lock. For server it is the
+	 * time when blocking ast was sent.
+	 */
+		time64_t        l_activity;
+		time64_t        l_blast_sent;
+	};
+
 	/*
 	 * Server-side-only members.
 	 */
@@ -1083,7 +1088,7 @@ static inline int ldlm_lvbo_size(struct ldlm_lock *lock)
 	return 0;
 }
 
-static inline int ldlm_lvbo_fill(struct ldlm_lock *lock, void *buf, int len)
+static inline int ldlm_lvbo_fill(struct ldlm_lock *lock, void *buf, int *len)
 {
 	struct ldlm_namespace *ns = ldlm_lock_to_ns(lock);
 	int rc;
diff --git a/drivers/staging/lustrefsx/lustre/include/lustre_dlm_flags.h b/drivers/staging/lustrefsx/lustre/include/lustre_dlm_flags.h
index 179cb71de375..cab4e5f2f702 100644
--- a/drivers/staging/lustrefsx/lustre/include/lustre_dlm_flags.h
+++ b/drivers/staging/lustrefsx/lustre/include/lustre_dlm_flags.h
@@ -161,14 +161,6 @@
 #define ldlm_set_fail_loc(_l)           LDLM_SET_FLAG((  _l), 1ULL << 32)
 #define ldlm_clear_fail_loc(_l)         LDLM_CLEAR_FLAG((_l), 1ULL << 32)
 
-/**
- * Used while processing the unused list to know that we have already
- * handled this lock and decided to skip it. */
-#define LDLM_FL_SKIPPED                 0x0000000200000000ULL // bit  33
-#define ldlm_is_skipped(_l)             LDLM_TEST_FLAG(( _l), 1ULL << 33)
-#define ldlm_set_skipped(_l)            LDLM_SET_FLAG((  _l), 1ULL << 33)
-#define ldlm_clear_skipped(_l)          LDLM_CLEAR_FLAG((_l), 1ULL << 33)
-
 /** this lock is being destroyed */
 #define LDLM_FL_CBPENDING               0x0000000400000000ULL // bit  34
 #define ldlm_is_cbpending(_l)           LDLM_TEST_FLAG(( _l), 1ULL << 34)
diff --git a/drivers/staging/lustrefsx/lustre/include/lustre_fid.h b/drivers/staging/lustrefsx/lustre/include/lustre_fid.h
index 8759b31f9167..43d0c3419417 100644
--- a/drivers/staging/lustrefsx/lustre/include/lustre_fid.h
+++ b/drivers/staging/lustrefsx/lustre/include/lustre_fid.h
@@ -345,7 +345,6 @@ static inline void ost_layout_le_to_cpu(struct ost_layout *dst,
 	dst->ol_comp_id = __le32_to_cpu(src->ol_comp_id);
 }
 
-/* Both filter_fid_*cpu* functions not currently used */
 static inline void filter_fid_cpu_to_le(struct filter_fid *dst,
 					const struct filter_fid *src, int size)
 {
diff --git a/drivers/staging/lustrefsx/lustre/include/lustre_idmap.h b/drivers/staging/lustrefsx/lustre/include/lustre_idmap.h
index 70d647d8a15f..57a192359d11 100644
--- a/drivers/staging/lustrefsx/lustre/include/lustre_idmap.h
+++ b/drivers/staging/lustrefsx/lustre/include/lustre_idmap.h
@@ -58,6 +58,8 @@
 
 #endif /* HAVE_GROUP_INFO_GID */
 
+#include <linux/cred.h>
+
 struct lu_ucred;
 
 extern void lustre_groups_from_list(struct group_info *ginfo, gid_t *glist);
diff --git a/drivers/staging/lustrefsx/lustre/include/obd.h b/drivers/staging/lustrefsx/lustre/include/obd.h
index 9910a189aef4..9d49ce5a2a17 100644
--- a/drivers/staging/lustrefsx/lustre/include/obd.h
+++ b/drivers/staging/lustrefsx/lustre/include/obd.h
@@ -1220,8 +1220,8 @@ static inline void client_adjust_max_dirty(struct client_obd *cli)
 			cli->cl_dirty_max_pages = dirty_max;
 	}
 
-	if (cli->cl_dirty_max_pages > TOTALRAM_PAGES / 8)
-		cli->cl_dirty_max_pages = TOTALRAM_PAGES / 8;
+	if (cli->cl_dirty_max_pages > cfs_totalram_pages() / 8)
+		cli->cl_dirty_max_pages = cfs_totalram_pages() / 8;
 }
 
 #endif /* __OBD_H */
diff --git a/drivers/staging/lustrefsx/lustre/include/obd_support.h b/drivers/staging/lustrefsx/lustre/include/obd_support.h
index 19c179dfb150..59f3ab530c9e 100644
--- a/drivers/staging/lustrefsx/lustre/include/obd_support.h
+++ b/drivers/staging/lustrefsx/lustre/include/obd_support.h
@@ -276,6 +276,8 @@ extern char obd_jobid_var[];
 #define OBD_FAIL_OSD_COMPAT_NO_ENTRY			0x196
 #define OBD_FAIL_OSD_OST_EA_FID_SET			0x197
 
+#define OBD_FAIL_OFD_SET_OID				0x1e0
+
 #define OBD_FAIL_OST                     0x200
 #define OBD_FAIL_OST_CONNECT_NET         0x201
 #define OBD_FAIL_OST_DISCONNECT_NET      0x202
@@ -424,6 +426,8 @@ extern char obd_jobid_var[];
 #define OBD_FAIL_PTLRPC_LONG_REQ_UNLINK  0x51b
 #define OBD_FAIL_PTLRPC_LONG_BOTH_UNLINK 0x51c
 #define OBD_FAIL_PTLRPC_CLIENT_BULK_CB3  0x520
+#define OBD_FAIL_PTLRPC_BULK_ATTACH      0x521
+#define OBD_FAIL_PTLRPC_CONNECT_RACE	 0x531
 
 #define OBD_FAIL_OBD_PING_NET            0x600
 #define OBD_FAIL_OBD_LOG_CANCEL_NET      0x601
diff --git a/drivers/staging/lustrefsx/lustre/include/uapi/linux/lustre_ioctl.h b/drivers/staging/lustrefsx/lustre/include/uapi/linux/lustre_ioctl.h
index cb4ec4637375..9fddf2b1b9bd 100644
--- a/drivers/staging/lustrefsx/lustre/include/uapi/linux/lustre_ioctl.h
+++ b/drivers/staging/lustrefsx/lustre/include/uapi/linux/lustre_ioctl.h
@@ -217,6 +217,7 @@ static inline __u32 obd_ioctl_packlen(struct obd_ioctl_data *data)
 #define OBD_IOC_LLOG_CHECK	_IOWR('f', 195, OBD_IOC_DATA_TYPE)
 /*	OBD_IOC_LLOG_CATINFO	_IOWR('f', 196, OBD_IOC_DATA_TYPE) */
 #define OBD_IOC_NODEMAP		_IOWR('f', 197, OBD_IOC_DATA_TYPE)
+#define OBD_IOC_CLEAR_CONFIGS   _IOWR('f', 198, OBD_IOC_DATA_TYPE)
 
 /*	ECHO_IOC_GET_STRIPE	_IOWR('f', 200, OBD_IOC_DATA_TYPE) */
 /*	ECHO_IOC_SET_STRIPE	_IOWR('f', 201, OBD_IOC_DATA_TYPE) */
diff --git a/drivers/staging/lustrefsx/lustre/ldlm/ldlm_lib.c b/drivers/staging/lustrefsx/lustre/ldlm/ldlm_lib.c
index 208ab5d481c8..9b84a0d0cd21 100644
--- a/drivers/staging/lustrefsx/lustre/ldlm/ldlm_lib.c
+++ b/drivers/staging/lustrefsx/lustre/ldlm/ldlm_lib.c
@@ -415,11 +415,11 @@ int client_obd_setup(struct obd_device *obddev, struct lustre_cfg *lcfg)
 
 	if (!strcmp(name, LUSTRE_MDC_NAME)) {
 		cli->cl_max_rpcs_in_flight = OBD_MAX_RIF_DEFAULT;
-	} else if (TOTALRAM_PAGES >> (20 - PAGE_SHIFT) <= 128 /* MB */) {
+	} else if (cfs_totalram_pages() >> (20 - PAGE_SHIFT) <= 128 /* MB */) {
 		cli->cl_max_rpcs_in_flight = 2;
-	} else if (TOTALRAM_PAGES >> (20 - PAGE_SHIFT) <= 256 /* MB */) {
+	} else if (cfs_totalram_pages() >> (20 - PAGE_SHIFT) <= 256 /* MB */) {
 		cli->cl_max_rpcs_in_flight = 3;
-	} else if (TOTALRAM_PAGES >> (20 - PAGE_SHIFT) <= 512 /* MB */) {
+	} else if (cfs_totalram_pages() >> (20 - PAGE_SHIFT) <= 512 /* MB */) {
 		cli->cl_max_rpcs_in_flight = 4;
 	} else {
 		if (osc_on_mdt(obddev->obd_name))
@@ -1164,6 +1164,7 @@ int target_handle_connect(struct ptlrpc_request *req)
 			 * cause namespace inconsistency */
 			spin_lock(&export->exp_lock);
 			export->exp_connecting = 1;
+			export->exp_conn_cnt = 0;
 			spin_unlock(&export->exp_lock);
 			conn.cookie = export->exp_handle.h_cookie;
 			rc = EALREADY;
@@ -1205,18 +1206,19 @@ int target_handle_connect(struct ptlrpc_request *req)
                               target->obd_name, cluuid.uuid,
                               libcfs_nid2str(req->rq_peer.nid),
 			      atomic_read(&export->exp_refcount));
-                GOTO(out, rc = -EBUSY);
-        } else if (lustre_msg_get_conn_cnt(req->rq_reqmsg) == 1) {
-                if (!strstr(cluuid.uuid, "mdt"))
-                        LCONSOLE_WARN("%s: Rejecting reconnect from the "
-                                      "known client %s (at %s) because it "
-                                      "is indicating it is a new client",
-                                      target->obd_name, cluuid.uuid,
-                                      libcfs_nid2str(req->rq_peer.nid));
-                GOTO(out, rc = -EALREADY);
-        } else {
-                OBD_FAIL_TIMEOUT(OBD_FAIL_TGT_DELAY_RECONNECT, 2 * obd_timeout);
-        }
+			GOTO(out, rc = -EBUSY);
+	} else if (lustre_msg_get_conn_cnt(req->rq_reqmsg) == 1 &&
+		   rc != EALREADY) {
+		if (!strstr(cluuid.uuid, "mdt"))
+			LCONSOLE_WARN("%s: Rejecting reconnect from the "
+				      "known client %s (at %s) because it "
+				      "is indicating it is a new client",
+				      target->obd_name, cluuid.uuid,
+				      libcfs_nid2str(req->rq_peer.nid));
+		GOTO(out, rc = -EALREADY);
+	} else {
+		OBD_FAIL_TIMEOUT(OBD_FAIL_TGT_DELAY_RECONNECT, 2 * obd_timeout);
+	}
 
         if (rc < 0) {
                 GOTO(out, rc);
@@ -2621,9 +2623,9 @@ void target_recovery_fini(struct obd_device *obd)
 }
 EXPORT_SYMBOL(target_recovery_fini);
 
-static void target_recovery_expired(unsigned long castmeharder)
+static void target_recovery_expired(cfs_timer_cb_arg_t data)
 {
-	struct obd_device *obd = (struct obd_device *)castmeharder;
+	struct obd_device *obd = cfs_from_timer(obd, data, obd_recovery_timer);
 	CDEBUG(D_HA, "%s: recovery timed out; %d clients are still in recovery"
 	       " after %llus (%d clients connected)\n",
 	       obd->obd_name, atomic_read(&obd->obd_lock_replay_clients),
@@ -2655,8 +2657,8 @@ void target_recovery_init(struct lu_target *lut, svc_handler_t handler)
         obd->obd_recovery_start = 0;
         obd->obd_recovery_end = 0;
 
-	setup_timer(&obd->obd_recovery_timer, target_recovery_expired,
-		    (unsigned long)obd);
+	cfs_timer_setup(&obd->obd_recovery_timer, target_recovery_expired,
+			(unsigned long)obd, 0);
 	target_start_recovery_thread(lut, handler);
 }
 EXPORT_SYMBOL(target_recovery_init);
diff --git a/drivers/staging/lustrefsx/lustre/ldlm/ldlm_lock.c b/drivers/staging/lustrefsx/lustre/ldlm/ldlm_lock.c
index ca171fe485f0..df28b2d7b513 100644
--- a/drivers/staging/lustrefsx/lustre/ldlm/ldlm_lock.c
+++ b/drivers/staging/lustrefsx/lustre/ldlm/ldlm_lock.c
@@ -233,6 +233,8 @@ int ldlm_lock_remove_from_lru_nolock(struct ldlm_lock *lock)
 		struct ldlm_namespace *ns = ldlm_lock_to_ns(lock);
 
 		LASSERT(lock->l_resource->lr_type != LDLM_FLOCK);
+		if (ns->ns_last_pos == &lock->l_lru)
+			ns->ns_last_pos = lock->l_lru.prev;
 		list_del_init(&lock->l_lru);
 		LASSERT(ns->ns_nr_unused > 0);
 		ns->ns_nr_unused--;
@@ -283,7 +285,6 @@ void ldlm_lock_add_to_lru_nolock(struct ldlm_lock *lock)
 	LASSERT(list_empty(&lock->l_lru));
 	LASSERT(lock->l_resource->lr_type != LDLM_FLOCK);
 	list_add_tail(&lock->l_lru, &ns->ns_unused_list);
-	ldlm_clear_skipped(lock);
 	LASSERT(ns->ns_nr_unused >= 0);
 	ns->ns_nr_unused++;
 }
@@ -482,6 +483,7 @@ static struct ldlm_lock *ldlm_lock_new(struct ldlm_resource *resource)
         lu_ref_init(&lock->l_reference);
         lu_ref_add(&lock->l_reference, "hash", lock);
         lock->l_callback_timeout = 0;
+	lock->l_activity = 0;
 
 #if LUSTRE_TRACKS_LOCK_EXP_REFS
 	INIT_LIST_HEAD(&lock->l_exp_refs_link);
diff --git a/drivers/staging/lustrefsx/lustre/ldlm/ldlm_lockd.c b/drivers/staging/lustrefsx/lustre/ldlm/ldlm_lockd.c
index 356a30231142..465ffda035db 100644
--- a/drivers/staging/lustrefsx/lustre/ldlm/ldlm_lockd.c
+++ b/drivers/staging/lustrefsx/lustre/ldlm/ldlm_lockd.c
@@ -133,8 +133,8 @@ static DEFINE_SPINLOCK(waiting_locks_spinlock); /* BH lock (timer) */
  * All access to it should be under waiting_locks_spinlock.
  */
 static LIST_HEAD(waiting_locks_list);
-static void waiting_locks_callback(unsigned long unused);
-static DEFINE_TIMER(waiting_locks_timer, waiting_locks_callback, 0, 0);
+static void waiting_locks_callback(cfs_timer_cb_arg_t unused);
+static CFS_DEFINE_TIMER(waiting_locks_timer, waiting_locks_callback, 0, 0);
 
 enum elt_state {
 	ELT_STOPPED,
@@ -288,7 +288,7 @@ static int ldlm_lock_busy(struct ldlm_lock *lock)
 }
 
 /* This is called from within a timer interrupt and cannot schedule */
-static void waiting_locks_callback(unsigned long unused)
+static void waiting_locks_callback(cfs_timer_cb_arg_t unused)
 {
 	struct ldlm_lock	*lock;
 	int			need_dump = 0;
@@ -329,7 +329,7 @@ static void waiting_locks_callback(unsigned long unused)
                 ldlm_lock_to_ns(lock)->ns_timeouts++;
 		LDLM_ERROR(lock, "lock callback timer expired after %llds: "
                            "evicting client at %s ",
-			   ktime_get_real_seconds() - lock->l_last_activity,
+			   ktime_get_real_seconds() - lock->l_blast_sent,
                            libcfs_nid2str(
                                    lock->l_export->exp_connection->c_peer.nid));
 
@@ -459,7 +459,7 @@ static int ldlm_add_waiting_lock(struct ldlm_lock *lock)
 	}
 
 	ldlm_set_waited(lock);
-	lock->l_last_activity = ktime_get_real_seconds();
+	lock->l_blast_sent = ktime_get_real_seconds();
 	ret = __ldlm_add_waiting_lock(lock, timeout);
 	if (ret) {
 		/* grab ref on the lock if it has been added to the
@@ -939,8 +939,6 @@ int ldlm_server_blocking_ast(struct ldlm_lock *lock,
         if (AT_OFF)
                 req->rq_timeout = ldlm_get_rq_timeout();
 
-	lock->l_last_activity = ktime_get_real_seconds();
-
         if (lock->l_export && lock->l_export->exp_nid_stats &&
             lock->l_export->exp_nid_stats->nid_ldlm_stats)
                 lprocfs_counter_incr(lock->l_export->exp_nid_stats->nid_ldlm_stats,
@@ -1012,7 +1010,7 @@ int ldlm_server_completion_ast(struct ldlm_lock *lock, __u64 flags, void *data)
 	if (lvb_len > 0) {
 		void *lvb = req_capsule_client_get(&req->rq_pill, &RMF_DLM_LVB);
 
-		lvb_len = ldlm_lvbo_fill(lock, lvb, lvb_len);
+		lvb_len = ldlm_lvbo_fill(lock, lvb, &lvb_len);
 		if (lvb_len < 0) {
 			/* We still need to send the RPC to wake up the blocked
 			 * enqueue thread on the client.
@@ -1029,8 +1027,6 @@ int ldlm_server_completion_ast(struct ldlm_lock *lock, __u64 flags, void *data)
 		}
         }
 
-	lock->l_last_activity = ktime_get_real_seconds();
-
 	LDLM_DEBUG(lock, "server preparing completion AST");
 
         ptlrpc_request_set_replen(req);
@@ -1139,8 +1135,6 @@ int ldlm_server_glimpse_ast(struct ldlm_lock *lock, void *data)
         if (AT_OFF)
                 req->rq_timeout = ldlm_get_rq_timeout();
 
-	lock->l_last_activity = ktime_get_real_seconds();
-
 	req->rq_interpret_reply = ldlm_cb_interpret;
 
         if (lock->l_export && lock->l_export->exp_nid_stats &&
@@ -1267,20 +1261,6 @@ int ldlm_handle_enqueue0(struct ldlm_namespace *ns,
                 GOTO(out, rc = -EFAULT);
         }
 
-	if (exp_connect_flags(req->rq_export) & OBD_CONNECT_IBITS) {
-                if (unlikely(dlm_req->lock_desc.l_resource.lr_type ==
-                             LDLM_PLAIN)) {
-                        DEBUG_REQ(D_ERROR, req,
-                                  "PLAIN lock request from IBITS client?");
-                        GOTO(out, rc = -EPROTO);
-                }
-        } else if (unlikely(dlm_req->lock_desc.l_resource.lr_type ==
-                            LDLM_IBITS)) {
-                DEBUG_REQ(D_ERROR, req,
-                          "IBITS lock request from unaware client?");
-                GOTO(out, rc = -EPROTO);
-        }
-
 	if (unlikely((flags & LDLM_FL_REPLAY) ||
 		     (lustre_msg_get_flags(req->rq_reqmsg) & MSG_RESENT))) {
                 /* Find an existing lock in the per-export lock hash */
@@ -1474,43 +1454,59 @@ int ldlm_handle_enqueue0(struct ldlm_namespace *ns,
 		LDLM_DEBUG(lock, "server-side enqueue handler, sending reply"
 			   "(err=%d, rc=%d)", err, rc);
 
-		if (rc == 0) {
-			if (req_capsule_has_field(&req->rq_pill, &RMF_DLM_LVB,
-						  RCL_SERVER) &&
-			    ldlm_lvbo_size(lock) > 0) {
-				void *buf;
-				int buflen;
-
-				buf = req_capsule_server_get(&req->rq_pill,
-							     &RMF_DLM_LVB);
-				LASSERTF(buf != NULL, "req %p, lock %p\n",
-					 req, lock);
-				buflen = req_capsule_get_size(&req->rq_pill,
-						&RMF_DLM_LVB, RCL_SERVER);
-				/* non-replayed lock, delayed lvb init may
-				 * need to be occur now */
-				if ((buflen > 0) && !(flags & LDLM_FL_REPLAY)) {
-					buflen = ldlm_lvbo_fill(lock, buf,
-								buflen);
-					if (buflen >= 0)
-						req_capsule_shrink(
+		if (rc == 0 &&
+		    req_capsule_has_field(&req->rq_pill, &RMF_DLM_LVB,
+					  RCL_SERVER) &&
+		    ldlm_lvbo_size(lock) > 0) {
+			void *buf;
+			int buflen;
+
+retry:
+			buf = req_capsule_server_get(&req->rq_pill,
+						     &RMF_DLM_LVB);
+			LASSERTF(buf != NULL, "req %p, lock %p\n", req, lock);
+			buflen = req_capsule_get_size(&req->rq_pill,
+					&RMF_DLM_LVB, RCL_SERVER);
+			/* non-replayed lock, delayed lvb init may
+			 * need to be occur now
+			 */
+			if ((buflen > 0) && !(flags & LDLM_FL_REPLAY)) {
+				int rc2;
+
+				rc2 = ldlm_lvbo_fill(lock, buf, &buflen);
+				if (rc2 >= 0) {
+					req_capsule_shrink(&req->rq_pill,
+							   &RMF_DLM_LVB,
+							   rc2, RCL_SERVER);
+				} else if (rc2 == -ERANGE) {
+					rc2 = req_capsule_server_grow(
 							&req->rq_pill,
-							&RMF_DLM_LVB,
-							buflen, RCL_SERVER);
-					else
-						rc = buflen;
-				} else if (flags & LDLM_FL_REPLAY) {
-					/* no LVB resend upon replay */
-					if (buflen > 0)
+							&RMF_DLM_LVB, buflen);
+					if (!rc2) {
+						goto retry;
+					} else {
+						/* if we can't grow the buffer,
+						 * it's ok to return empty lvb
+						 * to client.
+						 */
 						req_capsule_shrink(
 							&req->rq_pill,
-							&RMF_DLM_LVB,
-							0, RCL_SERVER);
-					else
-						rc = buflen;
+							&RMF_DLM_LVB, 0,
+							RCL_SERVER);
+					}
 				} else {
-					rc = buflen;
+					rc = rc2;
 				}
+			} else if (flags & LDLM_FL_REPLAY) {
+				/* no LVB resend upon replay */
+				if (buflen > 0)
+					req_capsule_shrink(&req->rq_pill,
+							   &RMF_DLM_LVB,
+							   0, RCL_SERVER);
+				else
+					rc = buflen;
+			} else {
+				rc = buflen;
 			}
 		}
 
@@ -1695,9 +1691,10 @@ int ldlm_request_cancel(struct ptlrpc_request *req,
                         pres = res;
                 }
 
-		if ((flags & LATF_STATS) && ldlm_is_ast_sent(lock)) {
+		if ((flags & LATF_STATS) && ldlm_is_ast_sent(lock) &&
+		    lock->l_blast_sent != 0) {
 			time64_t delay = ktime_get_real_seconds() -
-					 lock->l_last_activity;
+					 lock->l_blast_sent;
 			LDLM_DEBUG(lock, "server cancels blocked lock after %llds",
 				   (s64)delay);
 			at_measured(&lock->l_export->exp_bl_lock_at, delay);
diff --git a/drivers/staging/lustrefsx/lustre/ldlm/ldlm_request.c b/drivers/staging/lustrefsx/lustre/ldlm/ldlm_request.c
index f932c9900dd2..d15cff5fb27b 100644
--- a/drivers/staging/lustrefsx/lustre/ldlm/ldlm_request.c
+++ b/drivers/staging/lustrefsx/lustre/ldlm/ldlm_request.c
@@ -125,9 +125,9 @@ int ldlm_expired_completion_wait(void *data)
 
 		LDLM_ERROR(lock, "lock timed out (enqueued at %lld, %llds ago); "
 			   "not entering recovery in server code, just going back to sleep",
-			   (s64)lock->l_last_activity,
+			   (s64)lock->l_activity,
 			   (s64)(ktime_get_real_seconds() -
-				 lock->l_last_activity));
+				 lock->l_activity));
                 if (cfs_time_after(cfs_time_current(), next_dump)) {
                         last_dump = next_dump;
                         next_dump = cfs_time_shift(300);
@@ -143,8 +143,8 @@ int ldlm_expired_completion_wait(void *data)
         imp = obd->u.cli.cl_import;
         ptlrpc_fail_import(imp, lwd->lwd_conn_cnt);
 	LDLM_ERROR(lock, "lock timed out (enqueued at %lld, %llds ago), entering recovery for %s@%s",
-		  (s64)lock->l_last_activity,
-		  (s64)(ktime_get_real_seconds() - lock->l_last_activity),
+		  (s64)lock->l_activity,
+		  (s64)(ktime_get_real_seconds() - lock->l_activity),
                   obd2cli_tgt(obd), imp->imp_connection->c_remote_uuid.uuid);
 
         RETURN(0);
@@ -192,7 +192,7 @@ static int ldlm_completion_tail(struct ldlm_lock *lock, void *data)
 		LDLM_DEBUG(lock, "client-side enqueue: granted");
 	} else {
 		/* Take into AT only CP RPC, not immediately granted locks */
-		delay = ktime_get_real_seconds() - lock->l_last_activity;
+		delay = ktime_get_real_seconds() - lock->l_activity;
 		LDLM_DEBUG(lock, "client-side enqueue: granted after %llds",
 			   (s64)delay);
 
@@ -285,7 +285,7 @@ int ldlm_completion_ast(struct ldlm_lock *lock, __u64 flags, void *data)
 	timeout = ldlm_cp_timeout(lock);
 
 	lwd.lwd_lock = lock;
-	lock->l_last_activity = cfs_time_current_sec();
+	lock->l_activity = cfs_time_current_sec();
 
 	if (ldlm_is_no_timeout(lock)) {
                 LDLM_DEBUG(lock, "waiting indefinitely because of NO_TIMEOUT");
@@ -671,14 +671,15 @@ int ldlm_cli_enqueue_fini(struct obd_export *exp, struct ptlrpc_request *req,
 				GOTO(cleanup, rc = -ENOMEM);
 			LDLM_DEBUG(lock, "client-side enqueue, new resource");
 		}
-		if (with_policy)
-			if (!(type == LDLM_IBITS &&
-			      !(exp_connect_flags(exp) & OBD_CONNECT_IBITS)))
-				/* We assume lock type cannot change on server*/
-				ldlm_convert_policy_to_local(exp,
+
+		if (with_policy) {
+			/* We assume lock type cannot change on server*/
+			ldlm_convert_policy_to_local(exp,
 						lock->l_resource->lr_type,
 						&reply->lock_desc.l_policy_data,
 						&lock->l_policy_data);
+		}
+
                 if (type != LDLM_PLAIN)
                         LDLM_DEBUG(lock,"client-side enqueue, new policy data");
         }
@@ -947,7 +948,7 @@ int ldlm_cli_enqueue(struct obd_export *exp, struct ptlrpc_request **reqp,
 	lock->l_export = NULL;
 	lock->l_blocking_ast = einfo->ei_cb_bl;
 	lock->l_flags |= (*flags & (LDLM_FL_NO_LRU | LDLM_FL_EXCL));
-        lock->l_last_activity = cfs_time_current_sec();
+        lock->l_activity = cfs_time_current_sec();
 
 	/* lock not sent to server yet */
 	if (reqp == NULL || *reqp == NULL) {
@@ -1488,9 +1489,6 @@ ldlm_cancel_no_wait_policy(struct ldlm_namespace *ns, struct ldlm_lock *lock,
 			/* Fall through */
 		default:
 			result = LDLM_POLICY_SKIP_LOCK;
-			lock_res_and_lock(lock);
-			ldlm_set_skipped(lock);
-			unlock_res_and_lock(lock);
 			break;
 	}
 
@@ -1711,53 +1709,47 @@ static int ldlm_prepare_lru_list(struct ldlm_namespace *ns,
 				 enum ldlm_lru_flags lru_flags)
 {
 	ldlm_cancel_lru_policy_t pf;
-	struct ldlm_lock *lock, *next;
-	int added = 0, unused, remained;
+	int added = 0;
 	int no_wait = lru_flags & LDLM_LRU_FLAG_NO_WAIT;
-	ENTRY;
 
-	spin_lock(&ns->ns_lock);
-	unused = ns->ns_nr_unused;
-	remained = unused;
+	ENTRY;
 
 	if (!ns_connect_lru_resize(ns))
-		count += unused - ns->ns_max_unused;
+		count += ns->ns_nr_unused - ns->ns_max_unused;
 
 	pf = ldlm_cancel_lru_policy(ns, lru_flags);
 	LASSERT(pf != NULL);
 
-	while (!list_empty(&ns->ns_unused_list)) {
+	/* For any flags, stop scanning if @max is reached. */
+	while (!list_empty(&ns->ns_unused_list) && (max == 0 || added < max)) {
+		struct ldlm_lock *lock;
+		struct list_head *item, *next;
 		enum ldlm_policy_res result;
 		ktime_t last_use = ktime_set(0, 0);
 
-		/* all unused locks */
-		if (remained-- <= 0)
-			break;
-
-		/* For any flags, stop scanning if @max is reached. */
-		if (max && added >= max)
-			break;
+		spin_lock(&ns->ns_lock);
+		item = no_wait ? ns->ns_last_pos : &ns->ns_unused_list;
+		for (item = item->next, next = item->next;
+		     item != &ns->ns_unused_list;
+		     item = next, next = item->next) {
+			lock = list_entry(item, struct ldlm_lock, l_lru);
 
-		list_for_each_entry_safe(lock, next, &ns->ns_unused_list,
-					 l_lru) {
 			/* No locks which got blocking requests. */
 			LASSERT(!ldlm_is_bl_ast(lock));
 
-			if (no_wait && ldlm_is_skipped(lock))
-				/* already processed */
-				continue;
-
-			last_use = lock->l_last_used;
-
-			/* Somebody is already doing CANCEL. No need for this
-			 * lock in LRU, do not traverse it again. */
 			if (!ldlm_is_canceling(lock))
 				break;
 
+			/* Somebody is already doing CANCEL. No need for this
+			 * lock in LRU, do not traverse it again. */
 			ldlm_lock_remove_from_lru_nolock(lock);
 		}
-		if (&lock->l_lru == &ns->ns_unused_list)
+		if (item == &ns->ns_unused_list) {
+			spin_unlock(&ns->ns_lock);
 			break;
+		}
+
+		last_use = lock->l_last_used;
 
 		LDLM_LOCK_GET(lock);
 		spin_unlock(&ns->ns_lock);
@@ -1776,19 +1768,23 @@ static int ldlm_prepare_lru_list(struct ldlm_namespace *ns,
 		 * old locks, but additionally choose them by
 		 * their weight. Big extent locks will stay in
 		 * the cache. */
-		result = pf(ns, lock, unused, added, count);
+		result = pf(ns, lock, ns->ns_nr_unused, added, count);
 		if (result == LDLM_POLICY_KEEP_LOCK) {
-			lu_ref_del(&lock->l_reference,
-				   __FUNCTION__, current);
+			lu_ref_del(&lock->l_reference, __func__, current);
 			LDLM_LOCK_RELEASE(lock);
-			spin_lock(&ns->ns_lock);
 			break;
 		}
+
 		if (result == LDLM_POLICY_SKIP_LOCK) {
-			lu_ref_del(&lock->l_reference,
-				   __func__, current);
+			lu_ref_del(&lock->l_reference, __func__, current);
 			LDLM_LOCK_RELEASE(lock);
-			spin_lock(&ns->ns_lock);
+			if (no_wait) {
+				spin_lock(&ns->ns_lock);
+				if (!list_empty(&lock->l_lru) &&
+				    lock->l_lru.prev == ns->ns_last_pos)
+					ns->ns_last_pos = &lock->l_lru;
+				spin_unlock(&ns->ns_lock);
+			}
 			continue;
 		}
 
@@ -1805,7 +1801,6 @@ static int ldlm_prepare_lru_list(struct ldlm_namespace *ns,
 			unlock_res_and_lock(lock);
 			lu_ref_del(&lock->l_reference, __FUNCTION__, current);
 			LDLM_LOCK_RELEASE(lock);
-			spin_lock(&ns->ns_lock);
 			continue;
 		}
 		LASSERT(!lock->l_readers && !lock->l_writers);
@@ -1840,11 +1835,8 @@ static int ldlm_prepare_lru_list(struct ldlm_namespace *ns,
 		list_add(&lock->l_bl_ast, cancels);
 		unlock_res_and_lock(lock);
 		lu_ref_del(&lock->l_reference, __FUNCTION__, current);
-		spin_lock(&ns->ns_lock);
 		added++;
-		unused--;
 	}
-	spin_unlock(&ns->ns_lock);
 	RETURN(added);
 }
 
diff --git a/drivers/staging/lustrefsx/lustre/ldlm/ldlm_resource.c b/drivers/staging/lustrefsx/lustre/ldlm/ldlm_resource.c
index 225d3a7f01df..8467a9b8abff 100644
--- a/drivers/staging/lustrefsx/lustre/ldlm/ldlm_resource.c
+++ b/drivers/staging/lustrefsx/lustre/ldlm/ldlm_resource.c
@@ -951,6 +951,7 @@ struct ldlm_namespace *ldlm_namespace_new(struct obd_device *obd, char *name,
         ns->ns_connect_flags      = 0;
         ns->ns_stopping           = 0;
 	ns->ns_reclaim_start	  = 0;
+	ns->ns_last_pos		  = &ns->ns_unused_list;
 
 	rc = ldlm_namespace_sysfs_register(ns);
 	if (rc) {
diff --git a/drivers/staging/lustrefsx/lustre/llite/file.c b/drivers/staging/lustrefsx/lustre/llite/file.c
index 165141dc52cb..04cc72f45186 100644
--- a/drivers/staging/lustrefsx/lustre/llite/file.c
+++ b/drivers/staging/lustrefsx/lustre/llite/file.c
@@ -1008,17 +1008,19 @@ int ll_merge_attr(const struct lu_env *env, struct inode *inode)
 	 * if it's at least 'mdd.*.atime_diff' older.
 	 * All in all, the atime in Lustre does not strictly comply with
 	 * POSIX. Solving this problem needs to send an RPC to MDT for each
-	 * read, this will hurt performance. */
-	if (LTIME_S(inode->i_atime) < lli->lli_atime || lli->lli_update_atime) {
-		LTIME_S(inode->i_atime) = lli->lli_atime;
+	 * read, this will hurt performance.
+	 */
+	if (inode->i_atime.tv_sec < lli->lli_atime ||
+	    lli->lli_update_atime) {
+		inode->i_atime.tv_sec = lli->lli_atime;
 		lli->lli_update_atime = 0;
 	}
-	LTIME_S(inode->i_mtime) = lli->lli_mtime;
-	LTIME_S(inode->i_ctime) = lli->lli_ctime;
+	inode->i_mtime.tv_sec = lli->lli_mtime;
+	inode->i_ctime.tv_sec = lli->lli_ctime;
 
-	atime = LTIME_S(inode->i_atime);
-	mtime = LTIME_S(inode->i_mtime);
-	ctime = LTIME_S(inode->i_ctime);
+	mtime = inode->i_mtime.tv_sec;
+	atime = inode->i_atime.tv_sec;
+	ctime = inode->i_ctime.tv_sec;
 
 	cl_object_attr_lock(obj);
 	rc = cl_object_attr_get(env, obj, attr);
@@ -1042,9 +1044,9 @@ int ll_merge_attr(const struct lu_env *env, struct inode *inode)
 	i_size_write(inode, attr->cat_size);
 	inode->i_blocks = attr->cat_blocks;
 
-	LTIME_S(inode->i_atime) = atime;
-	LTIME_S(inode->i_mtime) = mtime;
-	LTIME_S(inode->i_ctime) = ctime;
+	inode->i_mtime.tv_sec = mtime;
+	inode->i_atime.tv_sec = atime;
+	inode->i_ctime.tv_sec = ctime;
 
 out_size_unlock:
 	ll_inode_size_unlock(inode);
@@ -1300,11 +1302,13 @@ ll_file_io_generic(const struct lu_env *env, struct vvp_io_args *args,
 				pos += io->ci_nob;
 
 			args->u.normal.via_iocb->ki_pos = pos;
+			if (io->ci_pio) {
 #ifdef HAVE_KIOCB_KI_LEFT
-			args->u.normal.via_iocb->ki_left = count;
+				args->u.normal.via_iocb->ki_left = count;
 #elif defined(HAVE_KI_NBYTES)
-			args->u.normal.via_iocb->ki_nbytes = count;
+				args->u.normal.via_iocb->ki_nbytes = count;
 #endif
+			}
 		} else {
 			/* for splice */
 			pos = io->u.ci_rw.rw_range.cir_pos;
@@ -3268,7 +3272,7 @@ ll_file_flock(struct file *file, int cmd, struct file_lock *file_lock)
         }
         flock.l_flock.pid = file_lock->fl_pid;
 
-#ifdef HAVE_LM_COMPARE_OWNER
+#if defined(HAVE_LM_COMPARE_OWNER) || defined(lm_compare_owner)
 	/* Somewhat ugly workaround for svc lockd.
 	 * lockd installs custom fl_lmops->lm_compare_owner that checks
 	 * for the fl_owner to be the same (which it always is on local node
@@ -3782,9 +3786,9 @@ ll_inode_revalidate(struct dentry *dentry, __u64 ibits)
 				RETURN(rc);
 		}
 
-		LTIME_S(inode->i_atime) = ll_i2info(inode)->lli_atime;
-		LTIME_S(inode->i_mtime) = ll_i2info(inode)->lli_mtime;
-		LTIME_S(inode->i_ctime) = ll_i2info(inode)->lli_ctime;
+		inode->i_atime.tv_sec = ll_i2info(inode)->lli_atime;
+		inode->i_mtime.tv_sec = ll_i2info(inode)->lli_mtime;
+		inode->i_ctime.tv_sec = ll_i2info(inode)->lli_ctime;
 	} else {
 		/* In case of restore, the MDT has the right size and has
 		 * already send it back without granting the layout lock,
diff --git a/drivers/staging/lustrefsx/lustre/llite/glimpse.c b/drivers/staging/lustrefsx/lustre/llite/glimpse.c
index 55deb8236bd4..d34be28747bd 100644
--- a/drivers/staging/lustrefsx/lustre/llite/glimpse.c
+++ b/drivers/staging/lustrefsx/lustre/llite/glimpse.c
@@ -66,22 +66,12 @@ blkcnt_t dirty_cnt(struct inode *inode)
 {
         blkcnt_t cnt = 0;
 	struct vvp_object *vob = cl_inode2vvp(inode);
-#ifndef HAVE_ADDRESS_SPACE_XARRAY
         void              *results[1];
 
         if (inode->i_mapping != NULL)
-#ifdef HAVE_ADDRESS_SPACE_IPAGES
-                cnt += radix_tree_gang_lookup_tag(&inode->i_mapping->i_pages,
-#else
                 cnt += radix_tree_gang_lookup_tag(&inode->i_mapping->page_tree,
-#endif
                                                   results, 0, 1,
                                                   PAGECACHE_TAG_DIRTY);
-#else
-	if (inode->i_mapping && mapping_tagged(inode->i_mapping,
-				PAGECACHE_TAG_DIRTY))
-		cnt = 1;
-#endif
 	if (cnt == 0 && atomic_read(&vob->vob_mmap_cnt) > 0)
 		cnt = 1;
 
diff --git a/drivers/staging/lustrefsx/lustre/llite/lcommon_cl.c b/drivers/staging/lustrefsx/lustre/llite/lcommon_cl.c
index feaf1769b6e8..f6e429ba182c 100644
--- a/drivers/staging/lustrefsx/lustre/llite/lcommon_cl.c
+++ b/drivers/staging/lustrefsx/lustre/llite/lcommon_cl.c
@@ -86,9 +86,9 @@ int cl_setattr_ost(struct cl_object *obj, const struct iattr *attr,
 	io->ci_obj = obj;
 	io->ci_verify_layout = 1;
 
-	io->u.ci_setattr.sa_attr.lvb_atime = LTIME_S(attr->ia_atime);
-	io->u.ci_setattr.sa_attr.lvb_mtime = LTIME_S(attr->ia_mtime);
-	io->u.ci_setattr.sa_attr.lvb_ctime = LTIME_S(attr->ia_ctime);
+	io->u.ci_setattr.sa_attr.lvb_atime = attr->ia_atime.tv_sec;
+	io->u.ci_setattr.sa_attr.lvb_mtime = attr->ia_mtime.tv_sec;
+	io->u.ci_setattr.sa_attr.lvb_ctime = attr->ia_ctime.tv_sec;
 	io->u.ci_setattr.sa_attr.lvb_size = attr->ia_size;
 	io->u.ci_setattr.sa_attr_flags = attr_flags;
 	io->u.ci_setattr.sa_valid = attr->ia_valid;
@@ -149,37 +149,48 @@ int cl_file_inode_init(struct inode *inode, struct lustre_md *md)
 
 	site = ll_i2sbi(inode)->ll_site;
 	lli  = ll_i2info(inode);
-        fid  = &lli->lli_fid;
-        LASSERT(fid_is_sane(fid));
-
-        if (lli->lli_clob == NULL) {
-                /* clob is slave of inode, empty lli_clob means for new inode,
-                 * there is no clob in cache with the given fid, so it is
-                 * unnecessary to perform lookup-alloc-lookup-insert, just
-                 * alloc and insert directly. */
-                LASSERT(inode->i_state & I_NEW);
-                conf.coc_lu.loc_flags = LOC_F_NEW;
-                clob = cl_object_find(env, lu2cl_dev(site->ls_top_dev),
-                                      fid, &conf);
-                if (!IS_ERR(clob)) {
-                        /*
-                         * No locking is necessary, as new inode is
-                         * locked by I_NEW bit.
-                         */
-                        lli->lli_clob = clob;
-                        lu_object_ref_add(&clob->co_lu, "inode", inode);
-                } else
-                        result = PTR_ERR(clob);
+	fid  = &lli->lli_fid;
+	LASSERT(fid_is_sane(fid));
+
+	if (lli->lli_clob == NULL) {
+		/* clob is slave of inode, empty lli_clob means for new inode,
+		 * there is no clob in cache with the given fid, so it is
+		 * unnecessary to perform lookup-alloc-lookup-insert, just
+		 * alloc and insert directly.
+		 */
+		if (!(inode->i_state & I_NEW)) {
+			result = -EIO;
+			CERROR("%s: unexpected not-NEW inode "DFID": rc = %d\n",
+			       ll_get_fsname(inode->i_sb, NULL, 0), PFID(fid),
+			       result);
+			goto out;
+		}
+
+		conf.coc_lu.loc_flags = LOC_F_NEW;
+		clob = cl_object_find(env, lu2cl_dev(site->ls_top_dev),
+				      fid, &conf);
+		if (!IS_ERR(clob)) {
+			/*
+			 * No locking is necessary, as new inode is
+			 * locked by I_NEW bit.
+			 */
+			lli->lli_clob = clob;
+			lu_object_ref_add(&clob->co_lu, "inode", inode);
+		} else {
+			result = PTR_ERR(clob);
+		}
 	} else {
 		result = cl_conf_set(env, lli->lli_clob, &conf);
 	}
 
-        cl_env_put(env, &refcheck);
+	if (result != 0)
+		CERROR("%s: failed to initialize cl_object "DFID": rc = %d\n",
+			ll_get_fsname(inode->i_sb, NULL, 0), PFID(fid), result);
+
+out:
+	cl_env_put(env, &refcheck);
 
-        if (result != 0)
-                CERROR("Failure to initialize cl object "DFID": %d\n",
-                       PFID(fid), result);
-        return result;
+	return result;
 }
 
 /**
diff --git a/drivers/staging/lustrefsx/lustre/llite/llite_lib.c b/drivers/staging/lustrefsx/lustre/llite/llite_lib.c
index 339dd8f1da4c..297622d3d88f 100644
--- a/drivers/staging/lustrefsx/lustre/llite/llite_lib.c
+++ b/drivers/staging/lustrefsx/lustre/llite/llite_lib.c
@@ -49,6 +49,9 @@
 #include <linux/security.h>
 
 #include <uapi/linux/lustre_ioctl.h>
+#ifdef HAVE_UAPI_LINUX_MOUNT_H
+#include <uapi/linux/mount.h>
+#endif
 #include <lustre_ha.h>
 #include <lustre_dlm.h>
 #include <lprocfs_status.h>
@@ -231,15 +234,15 @@ static int client_common_fill_super(struct super_block *sb, char *md, char *dt,
 	if (OBD_FAIL_CHECK(OBD_FAIL_MDC_LIGHTWEIGHT))
 		/* flag mdc connection as lightweight, only used for test
 		 * purpose, use with care */
-                data->ocd_connect_flags |= OBD_CONNECT_LIGHTWEIGHT;
+		data->ocd_connect_flags |= OBD_CONNECT_LIGHTWEIGHT;
 
-        data->ocd_ibits_known = MDS_INODELOCK_FULL;
-        data->ocd_version = LUSTRE_VERSION_CODE;
+	data->ocd_ibits_known = MDS_INODELOCK_FULL;
+	data->ocd_version = LUSTRE_VERSION_CODE;
 
-        if (sb->s_flags & SB_RDONLY)
-                data->ocd_connect_flags |= OBD_CONNECT_RDONLY;
-        if (sbi->ll_flags & LL_SBI_USER_XATTR)
-                data->ocd_connect_flags |= OBD_CONNECT_XATTR;
+	if (sb->s_flags & SB_RDONLY)
+		data->ocd_connect_flags |= OBD_CONNECT_RDONLY;
+	if (sbi->ll_flags & LL_SBI_USER_XATTR)
+		data->ocd_connect_flags |= OBD_CONNECT_XATTR;
 
 #ifdef SB_NOSEC
 	/* Setting this indicates we correctly support S_NOSEC (See kernel
@@ -248,12 +251,12 @@ static int client_common_fill_super(struct super_block *sb, char *md, char *dt,
 	sb->s_flags |= SB_NOSEC;
 #endif
 
-        if (sbi->ll_flags & LL_SBI_FLOCK)
-                sbi->ll_fop = &ll_file_operations_flock;
-        else if (sbi->ll_flags & LL_SBI_LOCALFLOCK)
-                sbi->ll_fop = &ll_file_operations;
-        else
-                sbi->ll_fop = &ll_file_operations_noflock;
+	if (sbi->ll_flags & LL_SBI_FLOCK)
+		sbi->ll_fop = &ll_file_operations_flock;
+	else if (sbi->ll_flags & LL_SBI_LOCALFLOCK)
+		sbi->ll_fop = &ll_file_operations;
+	else
+		sbi->ll_fop = &ll_file_operations_noflock;
 
 	/* always ping even if server suppress_pings */
 	if (sbi->ll_flags & LL_SBI_ALWAYS_PING)
@@ -266,16 +269,16 @@ static int client_common_fill_super(struct super_block *sb, char *md, char *dt,
 	data->ocd_brw_size = MD_MAX_BRW_SIZE;
 
         err = obd_connect(NULL, &sbi->ll_md_exp, obd, &sbi->ll_sb_uuid, data, NULL);
-        if (err == -EBUSY) {
-                LCONSOLE_ERROR_MSG(0x14f, "An MDT (md %s) is performing "
-                                   "recovery, of which this client is not a "
-                                   "part. Please wait for recovery to complete,"
-                                   " abort, or time out.\n", md);
-                GOTO(out, err);
-        } else if (err) {
-                CERROR("cannot connect to %s: rc = %d\n", md, err);
-                GOTO(out, err);
-        }
+	if (err == -EBUSY) {
+		LCONSOLE_ERROR_MSG(0x14f, "An MDT (md %s) is performing "
+				   "recovery, of which this client is not a "
+				   "part. Please wait for recovery to complete,"
+				   " abort, or time out.\n", md);
+		GOTO(out, err);
+	} else if (err) {
+		CERROR("cannot connect to %s: rc = %d\n", md, err);
+		GOTO(out, err);
+	}
 
 	sbi->ll_md_exp->exp_connect_data = *data;
 
@@ -337,28 +340,28 @@ static int client_common_fill_super(struct super_block *sb, char *md, char *dt,
 	sbi->ll_namelen = osfs->os_namelen;
 	sbi->ll_mnt.mnt = current->fs->root.mnt;
 
-        if ((sbi->ll_flags & LL_SBI_USER_XATTR) &&
-            !(data->ocd_connect_flags & OBD_CONNECT_XATTR)) {
-                LCONSOLE_INFO("Disabling user_xattr feature because "
-                              "it is not supported on the server\n");
-                sbi->ll_flags &= ~LL_SBI_USER_XATTR;
-        }
+	if ((sbi->ll_flags & LL_SBI_USER_XATTR) &&
+	    !(data->ocd_connect_flags & OBD_CONNECT_XATTR)) {
+		LCONSOLE_INFO("Disabling user_xattr feature because "
+			      "it is not supported on the server\n");
+		sbi->ll_flags &= ~LL_SBI_USER_XATTR;
+	}
 
-        if (data->ocd_connect_flags & OBD_CONNECT_ACL) {
+	if (data->ocd_connect_flags & OBD_CONNECT_ACL) {
 #ifdef SB_POSIXACL
-                sb->s_flags |= SB_POSIXACL;
+		sb->s_flags |= SB_POSIXACL;
 #endif
-                sbi->ll_flags |= LL_SBI_ACL;
-        } else {
-                LCONSOLE_INFO("client wants to enable acl, but mdt not!\n");
+		sbi->ll_flags |= LL_SBI_ACL;
+	} else {
+		LCONSOLE_INFO("client wants to enable acl, but mdt not!\n");
 #ifdef SB_POSIXACL
-                sb->s_flags &= ~SB_POSIXACL;
+		sb->s_flags &= ~SB_POSIXACL;
 #endif
-                sbi->ll_flags &= ~LL_SBI_ACL;
-        }
+		sbi->ll_flags &= ~LL_SBI_ACL;
+	}
 
-        if (data->ocd_connect_flags & OBD_CONNECT_64BITHASH)
-                sbi->ll_flags |= LL_SBI_64BIT_HASH;
+	if (data->ocd_connect_flags & OBD_CONNECT_64BITHASH)
+		sbi->ll_flags |= LL_SBI_64BIT_HASH;
 
 	if (data->ocd_connect_flags & OBD_CONNECT_LAYOUTLOCK)
 		sbi->ll_flags |= LL_SBI_LAYOUT_LOCK;
@@ -723,7 +726,7 @@ void ll_kill_super(struct super_block *sb)
 	struct ll_sb_info *sbi;
 	ENTRY;
 
-        /* not init sb ?*/
+	/* not init sb ?*/
 	if (!(sb->s_flags & SB_ACTIVE))
 		return;
 
@@ -1230,9 +1233,9 @@ static struct inode *ll_iget_anon_dir(struct super_block *sb,
 		LASSERTF(S_ISDIR(inode->i_mode), "Not slave inode "DFID"\n",
 			 PFID(fid));
 
-		LTIME_S(inode->i_mtime) = 0;
-		LTIME_S(inode->i_atime) = 0;
-		LTIME_S(inode->i_ctime) = 0;
+		inode->i_mtime.tv_sec = 0;
+		inode->i_atime.tv_sec = 0;
+		inode->i_ctime.tv_sec = 0;
 		inode->i_rdev = 0;
 
 #ifdef HAVE_BACKING_DEV_INFO
@@ -1459,11 +1462,6 @@ void ll_clear_inode(struct inode *inode)
 #ifdef CONFIG_FS_POSIX_ACL
 	forget_all_cached_acls(inode);
 	if (lli->lli_posix_acl) {
-#ifdef HAVE_POSIX_ACL_REFCOUNT
-		LASSERT(refcount_read(&lli->lli_posix_acl->a_refcount) == 1);
-#else
-		LASSERT(atomic_read(&lli->lli_posix_acl->a_refcount) == 1);
-#endif
 		posix_acl_release(lli->lli_posix_acl);
 		lli->lli_posix_acl = NULL;
 	}
@@ -1615,10 +1613,9 @@ int ll_setattr_raw(struct dentry *dentry, struct iattr *attr, bool hsm_import)
         }
 
         if (attr->ia_valid & (ATTR_MTIME | ATTR_CTIME))
-		CDEBUG(D_INODE, "setting mtime " LTIME_FMT ", ctime "
-		       LTIME_FMT ", now = %llu\n",
-                       LTIME_S(attr->ia_mtime), LTIME_S(attr->ia_ctime),
-		       (s64)ktime_get_real_seconds());
+		CDEBUG(D_INODE, "setting mtime %lld, ctime %lld, now = %lld\n",
+		       (s64)attr->ia_mtime.tv_sec, (s64)attr->ia_ctime.tv_sec,
+		       ktime_get_real_seconds());
 
 	if (S_ISREG(inode->i_mode)) {
 		if (attr->ia_valid & ATTR_SIZE)
@@ -1892,24 +1889,25 @@ int ll_update_inode(struct inode *inode, struct lustre_md *md)
 	inode->i_generation = cl_fid_build_gen(&body->mbo_fid1);
 
 	if (body->mbo_valid & OBD_MD_FLATIME) {
-		if (body->mbo_atime > LTIME_S(inode->i_atime))
-			LTIME_S(inode->i_atime) = body->mbo_atime;
+		if (body->mbo_atime > inode->i_atime.tv_sec)
+			inode->i_atime.tv_sec = body->mbo_atime;
 		lli->lli_atime = body->mbo_atime;
 	}
 
 	if (body->mbo_valid & OBD_MD_FLMTIME) {
-		if (body->mbo_mtime > LTIME_S(inode->i_mtime)) {
-			CDEBUG(D_INODE, "setting ino %lu mtime from " LTIME_FMT
-			       "to %llu\n", inode->i_ino,
-			       LTIME_S(inode->i_mtime), body->mbo_mtime);
-			LTIME_S(inode->i_mtime) = body->mbo_mtime;
+		if (body->mbo_mtime > inode->i_mtime.tv_sec) {
+			CDEBUG(D_INODE,
+			       "setting ino %lu mtime from %lld to %llu\n",
+			       inode->i_ino, (s64)inode->i_mtime.tv_sec,
+			       body->mbo_mtime);
+			inode->i_mtime.tv_sec = body->mbo_mtime;
 		}
 		lli->lli_mtime = body->mbo_mtime;
 	}
 
 	if (body->mbo_valid & OBD_MD_FLCTIME) {
-		if (body->mbo_ctime > LTIME_S(inode->i_ctime))
-			LTIME_S(inode->i_ctime) = body->mbo_ctime;
+		if (body->mbo_ctime > inode->i_ctime.tv_sec)
+			inode->i_ctime.tv_sec = body->mbo_ctime;
 		lli->lli_ctime = body->mbo_ctime;
 	}
 
@@ -1995,11 +1993,12 @@ int ll_read_inode2(struct inode *inode, void *opaque)
         /* Core attributes from the MDS first.  This is a new inode, and
          * the VFS doesn't zero times in the core inode so we have to do
          * it ourselves.  They will be overwritten by either MDS or OST
-         * attributes - we just need to make sure they aren't newer. */
-        LTIME_S(inode->i_mtime) = 0;
-        LTIME_S(inode->i_atime) = 0;
-        LTIME_S(inode->i_ctime) = 0;
-        inode->i_rdev = 0;
+	 * attributes - we just need to make sure they aren't newer.
+	 */
+	inode->i_mtime.tv_sec = 0;
+	inode->i_atime.tv_sec = 0;
+	inode->i_ctime.tv_sec = 0;
+	inode->i_rdev = 0;
 	rc = ll_update_inode(inode, md);
 	if (rc != 0)
 		RETURN(rc);
@@ -2038,6 +2037,8 @@ int ll_read_inode2(struct inode *inode, void *opaque)
 void ll_delete_inode(struct inode *inode)
 {
 	struct ll_inode_info *lli = ll_i2info(inode);
+	struct address_space *mapping = &inode->i_data;
+	unsigned long nrpages;
 	ENTRY;
 
 	if (S_ISREG(inode->i_mode) && lli->lli_clob != NULL)
@@ -2045,11 +2046,26 @@ void ll_delete_inode(struct inode *inode)
 		 * otherwise we may lose data while umount */
 		cl_sync_file_range(inode, 0, OBD_OBJECT_EOF, CL_FSYNC_LOCAL, 1);
 
-	truncate_inode_pages_final(&inode->i_data);
+	truncate_inode_pages_final(mapping);
 
-	LASSERTF(inode->i_data.nrpages == 0, "inode="DFID"(%p) nrpages=%lu, "
-		 "see https://jira.hpdd.intel.com/browse/LU-118\n",
-		 PFID(ll_inode2fid(inode)), inode, inode->i_data.nrpages);
+	/* Workaround for LU-118: Note nrpages may not be totally updated when
+	 * truncate_inode_pages() returns, as there can be a page in the process
+	 * of deletion (inside __delete_from_page_cache()) in the specified
+	 * range. Thus mapping->nrpages can be non-zero when this function
+	 * returns even after truncation of the whole mapping.  Only do this if
+	 * npages isn't already zero.
+	 */
+	nrpages = mapping->nrpages;
+	if (nrpages) {
+		xa_lock_irq(&mapping->i_pages);
+		nrpages = mapping->nrpages;
+		xa_unlock_irq(&mapping->i_pages);
+	} /* Workaround end */
+
+	LASSERTF(nrpages == 0, "%s: inode="DFID"(%p) nrpages=%lu, "
+		 "see https://jira.whamcloud.com/browse/LU-118\n",
+		 ll_get_fsname(inode->i_sb, NULL, 0),
+		 PFID(ll_inode2fid(inode)), inode, nrpages);
 
 #ifdef HAVE_SBOPS_EVICT_INODE
 	ll_clear_inode(inode);
@@ -2212,34 +2228,34 @@ void ll_umount_begin(struct super_block *sb)
 
 int ll_remount_fs(struct super_block *sb, int *flags, char *data)
 {
-        struct ll_sb_info *sbi = ll_s2sbi(sb);
-        char *profilenm = get_profile_name(sb);
-        int err;
-        __u32 read_only;
-
-        if ((*flags & SB_RDONLY) != (sb->s_flags & SB_RDONLY)) {
-                read_only = *flags & SB_RDONLY;
-                err = obd_set_info_async(NULL, sbi->ll_md_exp,
-                                         sizeof(KEY_READ_ONLY),
-                                         KEY_READ_ONLY, sizeof(read_only),
-                                         &read_only, NULL);
-                if (err) {
-                        LCONSOLE_WARN("Failed to remount %s %s (%d)\n",
-                                      profilenm, read_only ?
-                                      "read-only" : "read-write", err);
-                        return err;
-                }
+	struct ll_sb_info *sbi = ll_s2sbi(sb);
+	char *profilenm = get_profile_name(sb);
+	int err;
+	__u32 read_only;
+
+	if ((*flags & MS_RDONLY) != (sb->s_flags & SB_RDONLY)) {
+		read_only = *flags & MS_RDONLY;
+		err = obd_set_info_async(NULL, sbi->ll_md_exp,
+					 sizeof(KEY_READ_ONLY),
+					 KEY_READ_ONLY, sizeof(read_only),
+					 &read_only, NULL);
+		if (err) {
+			LCONSOLE_WARN("Failed to remount %s %s (%d)\n",
+				      profilenm, read_only ?
+				      "read-only" : "read-write", err);
+			return err;
+		}
 
-                if (read_only)
-                        sb->s_flags |= SB_RDONLY;
-                else
-                        sb->s_flags &= ~SB_RDONLY;
+		if (read_only)
+			sb->s_flags |= SB_RDONLY;
+		else
+			sb->s_flags &= ~SB_RDONLY;
 
-                if (sbi->ll_flags & LL_SBI_VERBOSE)
-                        LCONSOLE_WARN("Remounted %s %s\n", profilenm,
-                                      read_only ?  "read-only" : "read-write");
-        }
-        return 0;
+		if (sbi->ll_flags & LL_SBI_VERBOSE)
+			LCONSOLE_WARN("Remounted %s %s\n", profilenm,
+				      read_only ?  "read-only" : "read-write");
+	}
+	return 0;
 }
 
 /**
diff --git a/drivers/staging/lustrefsx/lustre/llite/llite_mmap.c b/drivers/staging/lustrefsx/lustre/llite/llite_mmap.c
index bf3c8636dff5..839b71076455 100644
--- a/drivers/staging/lustrefsx/lustre/llite/llite_mmap.c
+++ b/drivers/staging/lustrefsx/lustre/llite/llite_mmap.c
@@ -251,7 +251,7 @@ static inline int to_fault_error(int result)
  * \retval VM_FAULT_ERROR on general error
  * \retval NOPAGE_OOM not have memory for allocate new page
  */
-static int ll_fault0(struct vm_area_struct *vma, struct vm_fault *vmf)
+static vm_fault_t ll_fault0(struct vm_area_struct *vma, struct vm_fault *vmf)
 {
 	struct lu_env           *env;
 	struct cl_io            *io;
@@ -330,16 +330,16 @@ static int ll_fault0(struct vm_area_struct *vma, struct vm_fault *vmf)
 }
 
 #ifdef HAVE_VM_OPS_USE_VM_FAULT_ONLY
-static VM_FAULT_T ll_fault(struct vm_fault *vmf)
+static vm_fault_t ll_fault(struct vm_fault *vmf)
 {
 	struct vm_area_struct *vma = vmf->vma;
 #else
-static int ll_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
+static vm_fault_t ll_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
 {
 #endif
 	int count = 0;
 	bool printed = false;
-	int result;
+	vm_fault_t result;
 	sigset_t set;
 
 	/* Only SIGKILL and SIGTERM is allowed for fault/nopage/mkwrite
@@ -380,17 +380,18 @@ static int ll_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
 }
 
 #ifdef HAVE_VM_OPS_USE_VM_FAULT_ONLY
-static VM_FAULT_T ll_page_mkwrite(struct vm_fault *vmf)
+static vm_fault_t ll_page_mkwrite(struct vm_fault *vmf)
 {
 	struct vm_area_struct *vma = vmf->vma;
 #else
-static int ll_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)
+static vm_fault_t ll_page_mkwrite(struct vm_area_struct *vma,
+				  struct vm_fault *vmf)
 {
 #endif
 	int count = 0;
 	bool printed = false;
 	bool retry;
-	int result;
+	vm_fault_t result;
 
 	ll_stats_ops_tally(ll_i2sbi(file_inode(vma->vm_file)),
 			   LPROC_LL_MKWRITE, 1);
diff --git a/drivers/staging/lustrefsx/lustre/llite/lproc_llite.c b/drivers/staging/lustrefsx/lustre/llite/lproc_llite.c
index d794bf9cd5f6..93c767207f3e 100755
--- a/drivers/staging/lustrefsx/lustre/llite/lproc_llite.c
+++ b/drivers/staging/lustrefsx/lustre/llite/lproc_llite.c
@@ -308,12 +308,12 @@ ll_max_readahead_mb_seq_write(struct file *file, const char __user *buffer,
 
 	pages_number >>= PAGE_SHIFT;
 
-	if (pages_number < 0 || pages_number > TOTALRAM_PAGES / 2) {
+	if (pages_number < 0 || pages_number > cfs_totalram_pages() / 2) {
 		/* 1/2 of RAM */
 		CERROR("%s: can't set max_readahead_mb=%lu > %luMB\n",
 		       ll_get_fsname(sb, NULL, 0),
 		       (unsigned long)pages_number >> (20 - PAGE_SHIFT),
-		       TOTALRAM_PAGES >> (20 - PAGE_SHIFT + 1));
+		       cfs_totalram_pages() >> (20 - PAGE_SHIFT + 1));
 		return -ERANGE;
 	}
 
@@ -479,10 +479,10 @@ ll_max_cached_mb_seq_write(struct file *file, const char __user *buffer,
 
 	pages_number >>= PAGE_SHIFT;
 
-	if (pages_number < 0 || pages_number > TOTALRAM_PAGES) {
+	if (pages_number < 0 || pages_number > cfs_totalram_pages()) {
 		CERROR("%s: can't set max cache more than %lu MB\n",
 		       ll_get_fsname(sb, NULL, 0),
-		       TOTALRAM_PAGES >> (20 - PAGE_SHIFT));
+		       cfs_totalram_pages() >> (20 - PAGE_SHIFT));
 		RETURN(-ERANGE);
 	}
 	/* Allow enough cache so clients can make well-formed RPCs */
diff --git a/drivers/staging/lustrefsx/lustre/llite/namei.c b/drivers/staging/lustrefsx/lustre/llite/namei.c
index 268e11a161e0..622f9a44f407 100644
--- a/drivers/staging/lustrefsx/lustre/llite/namei.c
+++ b/drivers/staging/lustrefsx/lustre/llite/namei.c
@@ -699,17 +699,33 @@ static struct dentry *ll_lookup_nd(struct inode *parent, struct dentry *dentry,
 	return de;
 }
 
+#ifdef FMODE_CREATED /* added in Linux v4.18-rc1-20-g73a09dd */
+# define ll_is_opened(o, f)		((f)->f_mode & FMODE_OPENED)
+# define ll_finish_open(f, d, o)	finish_open((f), (d), NULL)
+# define ll_last_arg
+# define ll_set_created(o, f)						\
+do {									\
+	(f)->f_mode |= FMODE_CREATED;					\
+} while (0)
+
+#else
+# define ll_is_opened(o, f)		(*(o))
+# define ll_finish_open(f, d, o)	finish_open((f), (d), NULL, (o))
+# define ll_last_arg			, int *opened
+# define ll_set_created(o, f)						\
+do {									\
+	*(o) |= FILE_CREATED;						\
+} while (0)
+
+#endif
+
 /*
  * For cached negative dentry and new dentry, handle lookup/create/open
  * together.
  */
 static int ll_atomic_open(struct inode *dir, struct dentry *dentry,
 			  struct file *file, unsigned open_flags,
-			  umode_t mode
-#ifndef HAVE_ATOMIC_OPEN_NO_OPENED
-			  , int *opened
-#endif
-			  )
+			  umode_t mode ll_last_arg)
 {
 	struct lookup_intent *it;
 	struct dentry *de;
@@ -719,17 +735,11 @@ static int ll_atomic_open(struct inode *dir, struct dentry *dentry,
 	int rc = 0;
 	ENTRY;
 
-#ifdef HAVE_ATOMIC_OPEN_NO_OPENED
-	CDEBUG(D_VFSTRACE, "VFS Op:name=%.*s, dir="DFID"(%p), file %p,"
-			   "open_flags %x, mode %x\n",
-	       dentry->d_name.len, dentry->d_name.name,
-	       PFID(ll_inode2fid(dir)), dir, file, open_flags, mode);
-#else
 	CDEBUG(D_VFSTRACE, "VFS Op:name=%.*s, dir="DFID"(%p), file %p,"
 			   "open_flags %x, mode %x opened %d\n",
 	       dentry->d_name.len, dentry->d_name.name,
-	       PFID(ll_inode2fid(dir)), dir, file, open_flags, mode, *opened);
-#endif
+	       PFID(ll_inode2fid(dir)), dir, file, open_flags, mode,
+	       ll_is_opened(opened, file));
 
 	/* Only negative dentries enter here */
 	LASSERT(dentry->d_inode == NULL);
@@ -782,11 +792,7 @@ static int ll_atomic_open(struct inode *dir, struct dentry *dentry,
 					dput(de);
 				goto out_release;
 			}
-#ifdef HAVE_ATOMIC_OPEN_NO_OPENED
-			file->f_mode |= FMODE_CREATED;
-#else
-			*opened |= FILE_CREATED;
-#endif
+			ll_set_created(opened, file);
 		}
 		if (dentry->d_inode && it_disposition(it, DISP_OPEN_OPEN)) {
 			/* Open dentry. */
@@ -797,11 +803,7 @@ static int ll_atomic_open(struct inode *dir, struct dentry *dentry,
 				rc = finish_no_open(file, de);
 			} else {
 				file->private_data = it;
-#ifdef HAVE_ATOMIC_OPEN_NO_OPENED
-				rc = finish_open(file, dentry, NULL);
-#else
-				rc = finish_open(file, dentry, NULL, opened);
-#endif
+				rc = ll_finish_open(file, dentry, opened);
 				/* We dget in ll_splice_alias. finish_open takes
 				 * care of dget for fd open.
 				 */
@@ -1022,16 +1024,17 @@ void ll_update_times(struct ptlrpc_request *request, struct inode *inode)
 
 	LASSERT(body);
 	if (body->mbo_valid & OBD_MD_FLMTIME &&
-	    body->mbo_mtime > LTIME_S(inode->i_mtime)) {
-		CDEBUG(D_INODE, "setting fid "DFID" mtime from " LTIME_FMT
-		       " to %llu\n", PFID(ll_inode2fid(inode)),
-		       LTIME_S(inode->i_mtime), body->mbo_mtime);
-		LTIME_S(inode->i_mtime) = body->mbo_mtime;
+	    body->mbo_mtime > inode->i_mtime.tv_sec) {
+		CDEBUG(D_INODE,
+		       "setting fid " DFID " mtime from %lld to %llu\n",
+		       PFID(ll_inode2fid(inode)),
+		       (s64)inode->i_mtime.tv_sec, body->mbo_mtime);
+		inode->i_mtime.tv_sec = body->mbo_mtime;
 	}
 
 	if (body->mbo_valid & OBD_MD_FLCTIME &&
-	    body->mbo_ctime > LTIME_S(inode->i_ctime))
-		LTIME_S(inode->i_ctime) = body->mbo_ctime;
+	    body->mbo_ctime > inode->i_ctime.tv_sec)
+		inode->i_ctime.tv_sec = body->mbo_ctime;
 }
 
 static int ll_new_node(struct inode *dir, struct dentry *dchild,
diff --git a/drivers/staging/lustrefsx/lustre/llite/vvp_io.c b/drivers/staging/lustrefsx/lustre/llite/vvp_io.c
index 9de5f9b40cf2..404cee02a469 100644
--- a/drivers/staging/lustrefsx/lustre/llite/vvp_io.c
+++ b/drivers/staging/lustrefsx/lustre/llite/vvp_io.c
@@ -41,6 +41,7 @@
 #include <obd.h>
 #include "llite_internal.h"
 #include "vvp_internal.h"
+#include <libcfs/linux/linux-misc.h>
 
 static struct vvp_io *cl2vvp_io(const struct lu_env *env,
 				const struct cl_io_slice *slice)
@@ -427,6 +428,8 @@ static int vvp_mmap_locks(const struct lu_env *env, struct cl_io *io)
 	union ldlm_policy_data policy;
 	struct iovec iov;
 	struct iov_iter i;
+	unsigned long addr;
+	ssize_t count;
 	int result = 0;
 	ENTRY;
 
@@ -439,9 +442,15 @@ static int vvp_mmap_locks(const struct lu_env *env, struct cl_io *io)
 	if (mm == NULL)
 		RETURN(0);
 
-	iov_for_each(iov, i, io->u.ci_rw.rw_iter) {
-		unsigned long addr = (unsigned long)iov.iov_base;
-		size_t count = iov.iov_len;
+	if (!iter_is_iovec(&io->u.ci_rw.rw_iter) && !iov_iter_is_kvec(&io->u.ci_rw.rw_iter))
+		RETURN(0);
+
+	for (i = io->u.ci_rw.rw_iter;
+	     iov_iter_count(&i);
+	     iov_iter_advance(&i, iov.iov_len)) {
+		iov = iov_iter_iovec(&i);
+		addr = (unsigned long)iov.iov_base;
+		count = iov.iov_len;
 
                 if (count == 0)
                         continue;
diff --git a/drivers/staging/lustrefsx/lustre/llite/vvp_object.c b/drivers/staging/lustrefsx/lustre/llite/vvp_object.c
index 8904e4591838..fd7211f60c61 100644
--- a/drivers/staging/lustrefsx/lustre/llite/vvp_object.c
+++ b/drivers/staging/lustrefsx/lustre/llite/vvp_object.c
@@ -178,9 +178,9 @@ static int vvp_object_glimpse(const struct lu_env *env,
 	struct inode *inode = vvp_object_inode(obj);
 
 	ENTRY;
-	lvb->lvb_mtime = LTIME_S(inode->i_mtime);
-	lvb->lvb_atime = LTIME_S(inode->i_atime);
-	lvb->lvb_ctime = LTIME_S(inode->i_ctime);
+	lvb->lvb_mtime = inode->i_mtime.tv_sec;
+	lvb->lvb_atime = inode->i_atime.tv_sec;
+	lvb->lvb_ctime = inode->i_ctime.tv_sec;
 
 	/*
 	 * LU-417: Add dirty pages block count lest i_blocks reports 0, some
diff --git a/drivers/staging/lustrefsx/lustre/llite/xattr.c b/drivers/staging/lustrefsx/lustre/llite/xattr.c
index e1e6e34dc0e0..e76e0130d666 100644
--- a/drivers/staging/lustrefsx/lustre/llite/xattr.c
+++ b/drivers/staging/lustrefsx/lustre/llite/xattr.c
@@ -34,7 +34,9 @@
 #include <linux/sched.h>
 #include <linux/mm.h>
 #include <linux/xattr.h>
+#ifdef HAVE_LINUX_SELINUX_IS_ENABLED
 #include <linux/selinux.h>
+#endif
 
 #define DEBUG_SUBSYSTEM S_LLITE
 
@@ -52,6 +54,17 @@ static inline const char *xattr_prefix(const struct xattr_handler *handler)
 }
 #endif
 
+#ifdef HAVE_LINUX_SELINUX_IS_ENABLED
+# define test_xattr_is_selinux_disabled(handler, name) \
+		((handler)->flags == XATTR_SECURITY_T && \
+		!selinux_is_enabled() && \
+		strcmp((name), "selinux") == 0)
+#else
+# define test_xattr_is_selinux_disabled(handler, name) \
+		((handler)->flags == XATTR_SECURITY_T && \
+		strcmp((name), "selinux") == 0)
+#endif
+
 const struct xattr_handler *get_xattr_type(const char *name)
 {
 	int i;
@@ -136,8 +149,7 @@ static int ll_xattr_set_common(const struct xattr_handler *handler,
 		RETURN(0);
 
 	/* LU-549:  Disable security.selinux when selinux is disabled */
-	if (handler->flags == XATTR_SECURITY_T && !selinux_is_enabled() &&
-	    strcmp(name, "selinux") == 0)
+	if (test_xattr_is_selinux_disabled(handler, name))
 		RETURN(-EOPNOTSUPP);
 
 	/*
@@ -431,8 +443,7 @@ static int ll_xattr_get_common(const struct xattr_handler *handler,
 		RETURN(rc);
 
 	/* LU-549:  Disable security.selinux when selinux is disabled */
-	if (handler->flags == XATTR_SECURITY_T && !selinux_is_enabled() &&
-	    !strcmp(name, "selinux"))
+	if (test_xattr_is_selinux_disabled(handler, name))
 		RETURN(-EOPNOTSUPP);
 
 #ifdef CONFIG_FS_POSIX_ACL
diff --git a/drivers/staging/lustrefsx/lustre/llite/xattr_security.c b/drivers/staging/lustrefsx/lustre/llite/xattr_security.c
index 82019cc8caef..5a7970231871 100644
--- a/drivers/staging/lustrefsx/lustre/llite/xattr_security.c
+++ b/drivers/staging/lustrefsx/lustre/llite/xattr_security.c
@@ -33,7 +33,9 @@
 
 #include <linux/types.h>
 #include <linux/security.h>
+#ifdef HAVE_LINUX_SELINUX_IS_ENABLED
 #include <linux/selinux.h>
+#endif
 #include <linux/xattr.h>
 #include "llite_internal.h"
 
@@ -55,7 +57,8 @@ int ll_dentry_init_security(struct dentry *dentry, int mode, struct qstr *name,
 #ifdef HAVE_SECURITY_DENTRY_INIT_SECURITY
 	int rc;
 
-	/* security_dentry_init_security() is strange. Like
+	/*
+	 * security_dentry_init_security() is strange. Like
 	 * security_inode_init_security() it may return a context (provided a
 	 * Linux security module is enabled) but unlike
 	 * security_inode_init_security() it does not return to us the name of
@@ -65,13 +68,16 @@ int ll_dentry_init_security(struct dentry *dentry, int mode, struct qstr *name,
 	 * SELinux is the only module that implements
 	 * security_dentry_init_security(). Note that the NFS client code just
 	 * calls it and assumes that if anything is returned then it must come
-	 * from SELinux. */
+	 * from SELinux.
+	 */
 
 	if (!selinux_is_enabled())
 		return 0;
 
 	rc = security_dentry_init_security(dentry, mode, name, secctx,
 					   secctx_size);
+	if (rc == -EOPNOTSUPP)
+		return 0;
 	if (rc < 0)
 		return rc;
 
@@ -135,11 +141,17 @@ int
 ll_inode_init_security(struct dentry *dentry, struct inode *inode,
 		       struct inode *dir)
 {
+	int rc;
+
 	if (!selinux_is_enabled())
 		return 0;
 
-	return ll_security_inode_init_security(inode, dir, NULL, NULL, 0,
-					       &ll_initxattrs, dentry);
+	rc = ll_security_inode_init_security(inode, dir, NULL, NULL, 0,
+					      &ll_initxattrs, dentry);
+	if (rc == -EOPNOTSUPP)
+		return 0;
+
+	return rc;
 }
 #else /* !HAVE_SECURITY_IINITSEC_CALLBACK */
 /**
diff --git a/drivers/staging/lustrefsx/lustre/lmv/lmv_intent.c b/drivers/staging/lustrefsx/lustre/lmv/lmv_intent.c
index 08a5a609e3fd..bb792e751e94 100644
--- a/drivers/staging/lustrefsx/lustre/lmv/lmv_intent.c
+++ b/drivers/staging/lustrefsx/lustre/lmv/lmv_intent.c
@@ -233,9 +233,9 @@ int lmv_revalidate_slaves(struct obd_export *exp,
 			i_size_write(inode, body->mbo_size);
 			inode->i_blocks = body->mbo_blocks;
 			set_nlink(inode, body->mbo_nlink);
-			LTIME_S(inode->i_atime) = body->mbo_atime;
-			LTIME_S(inode->i_ctime) = body->mbo_ctime;
-			LTIME_S(inode->i_mtime) = body->mbo_mtime;
+			inode->i_atime.tv_sec = body->mbo_atime;
+			inode->i_ctime.tv_sec = body->mbo_ctime;
+			inode->i_mtime.tv_sec = body->mbo_mtime;
 		}
 
 		md_set_lock_data(tgt->ltd_exp, lockh, inode, NULL);
diff --git a/drivers/staging/lustrefsx/lustre/lmv/lmv_obd.c b/drivers/staging/lustrefsx/lustre/lmv/lmv_obd.c
index 15589c5b9c76..8b073a6d9846 100644
--- a/drivers/staging/lustrefsx/lustre/lmv/lmv_obd.c
+++ b/drivers/staging/lustrefsx/lustre/lmv/lmv_obd.c
@@ -678,6 +678,7 @@ static int lmv_fid2path(struct obd_export *exp, int len, void *karg,
 	if (remote_gf != NULL) {
 		struct getinfo_fid2path *ori_gf;
 		char *ptr;
+		int len;
 
 		ori_gf = (struct getinfo_fid2path *)karg;
 		if (strlen(ori_gf->gf_u.gf_path) +
@@ -686,13 +687,12 @@ static int lmv_fid2path(struct obd_export *exp, int len, void *karg,
 
 		ptr = ori_gf->gf_u.gf_path;
 
-		memmove(ptr + strlen(gf->gf_u.gf_path) + 1, ptr,
-			strlen(ori_gf->gf_u.gf_path));
-
-		strncpy(ptr, gf->gf_u.gf_path,
-			strlen(gf->gf_u.gf_path));
-		ptr += strlen(gf->gf_u.gf_path);
-		*ptr = '/';
+		len = strlen(gf->gf_u.gf_path);
+		/* move the current path to the right to release space
+		 * for closer-to-root part */
+		memmove(ptr + len + 1, ptr, strlen(ori_gf->gf_u.gf_path));
+		memcpy(ptr, gf->gf_u.gf_path, len);
+		ptr[len] = '/';
 	}
 
 	CDEBUG(D_INFO, "%s: get path %s "DFID" rec: %llu ln: %u\n",
@@ -3096,13 +3096,12 @@ static int lmv_merge_attr(struct obd_export *exp,
 	for (i = 0; i < lsm->lsm_md_stripe_count; i++) {
 		struct inode *inode = lsm->lsm_md_oinfo[i].lmo_root;
 
-		CDEBUG(D_INFO, ""DFID" size %llu, blocks %llu nlink %u,"
-		       " atime " LTIME_FMT " ctime " LTIME_FMT
-		       ", mtime " LTIME_FMT ".\n",
+		CDEBUG(D_INFO,
+		       "" DFID " size %llu, blocks %llu nlink %u, atime %lld ctime %lld, mtime %lld.\n",
 		       PFID(&lsm->lsm_md_oinfo[i].lmo_fid),
 		       i_size_read(inode), (unsigned long long)inode->i_blocks,
-		       inode->i_nlink, LTIME_S(inode->i_atime),
-		       LTIME_S(inode->i_ctime), LTIME_S(inode->i_mtime));
+		       inode->i_nlink, (s64)inode->i_atime.tv_sec,
+		       (s64)inode->i_ctime.tv_sec, (s64)inode->i_mtime.tv_sec);
 
 		/* for slave stripe, it needs to subtract nlink for . and .. */
 		if (i != 0)
@@ -3113,14 +3112,14 @@ static int lmv_merge_attr(struct obd_export *exp,
 		attr->cat_size += i_size_read(inode);
 		attr->cat_blocks += inode->i_blocks;
 
-		if (attr->cat_atime < LTIME_S(inode->i_atime))
-			attr->cat_atime = LTIME_S(inode->i_atime);
+		if (attr->cat_atime < inode->i_atime.tv_sec)
+			attr->cat_atime = inode->i_atime.tv_sec;
 
-		if (attr->cat_ctime < LTIME_S(inode->i_ctime))
-			attr->cat_ctime = LTIME_S(inode->i_ctime);
+		if (attr->cat_ctime < inode->i_ctime.tv_sec)
+			attr->cat_ctime = inode->i_ctime.tv_sec;
 
-		if (attr->cat_mtime < LTIME_S(inode->i_mtime))
-			attr->cat_mtime = LTIME_S(inode->i_mtime);
+		if (attr->cat_mtime < inode->i_mtime.tv_sec)
+			attr->cat_mtime = inode->i_mtime.tv_sec;
 	}
 	return 0;
 }
diff --git a/drivers/staging/lustrefsx/lustre/lov/lov_obd.c b/drivers/staging/lustrefsx/lustre/lov/lov_obd.c
index e494abbaedf8..8cdd60fc9017 100644
--- a/drivers/staging/lustrefsx/lustre/lov/lov_obd.c
+++ b/drivers/staging/lustrefsx/lustre/lov/lov_obd.c
@@ -377,25 +377,8 @@ static int lov_set_osc_active(struct obd_device *obd, struct obd_uuid *uuid,
 		tgt = lov->lov_tgts[index];
 		if (!tgt)
 			continue;
-		/*
-		 * LU-642, initially inactive OSC could miss the obd_connect,
-		 * we make up for it here.
-		 */
-		if (ev == OBD_NOTIFY_ACTIVATE && tgt->ltd_exp == NULL &&
-		    obd_uuid_equals(uuid, &tgt->ltd_uuid)) {
-			struct obd_uuid lov_osc_uuid = {"LOV_OSC_UUID"};
-
-			obd_connect(NULL, &tgt->ltd_exp, tgt->ltd_obd,
-				    &lov_osc_uuid, &lov->lov_ocd, NULL);
-		}
-		if (!tgt->ltd_exp)
-			continue;
-
-		CDEBUG(D_INFO, "lov idx %d is %s conn %#llx\n",
-                       index, obd_uuid2str(&tgt->ltd_uuid),
-                       tgt->ltd_exp->exp_handle.h_cookie);
-                if (obd_uuid_equals(uuid, &tgt->ltd_uuid))
-                        break;
+		if (obd_uuid_equals(uuid, &tgt->ltd_uuid))
+			break;
         }
 
         if (index == lov->desc.ld_tgt_count)
@@ -404,6 +387,27 @@ static int lov_set_osc_active(struct obd_device *obd, struct obd_uuid *uuid,
         if (ev == OBD_NOTIFY_DEACTIVATE || ev == OBD_NOTIFY_ACTIVATE) {
                 activate = (ev == OBD_NOTIFY_ACTIVATE) ? 1 : 0;
 
+		/*
+		 * LU-642, initially inactive OSC could miss the obd_connect,
+		 * we make up for it here.
+		 */
+		if (activate && !tgt->ltd_exp) {
+			int rc;
+			struct obd_uuid lov_osc_uuid = {"LOV_OSC_UUID"};
+
+			rc = obd_connect(NULL, &tgt->ltd_exp, tgt->ltd_obd,
+					 &lov_osc_uuid, &lov->lov_ocd, NULL);
+			if (rc || tgt->ltd_exp == NULL)
+				GOTO(out, index = rc);
+			rc = obd_set_info_async(NULL, tgt->ltd_exp,
+						sizeof(KEY_CACHE_SET),
+						KEY_CACHE_SET,
+						sizeof(struct cl_client_cache),
+						lov->lov_cache, NULL);
+			if (rc < 0)
+				GOTO(out, index = rc);
+		}
+
                 if (lov->lov_tgts[index]->ltd_activate == activate) {
                         CDEBUG(D_INFO, "OSC %s already %sactivate!\n",
                                uuid->uuid, activate ? "" : "de");
@@ -438,6 +442,10 @@ static int lov_set_osc_active(struct obd_device *obd, struct obd_uuid *uuid,
 		       ev, uuid->uuid);
 	}
 
+	if (tgt->ltd_exp)
+		CDEBUG(D_INFO, "%s: lov idx %d conn %llx\n", obd_uuid2str(uuid),
+		       index, tgt->ltd_exp->exp_handle.h_cookie);
+
  out:
 	obd_putref(obd);
 	RETURN(index);
diff --git a/drivers/staging/lustrefsx/lustre/lov/lov_object.c b/drivers/staging/lustrefsx/lustre/lov/lov_object.c
index 87d496d8a68e..c1cf76367697 100644
--- a/drivers/staging/lustrefsx/lustre/lov/lov_object.c
+++ b/drivers/staging/lustrefsx/lustre/lov/lov_object.c
@@ -1062,8 +1062,13 @@ int lov_io_init(const struct lu_env *env, struct cl_object *obj,
 	       PFID(lu_object_fid(&obj->co_lu)), io, io->ci_type,
 	       io->ci_ignore_layout, io->ci_verify_layout);
 
+	/* IO type CIT_MISC with ci_ignore_layout set are usually invoked from
+	 * the OSC layer. It shouldn't take lov layout conf lock in that case,
+	 * because as long as the OSC object exists, the layout can't be
+	 * reconfigured. */
 	return LOV_2DISPATCH_MAYLOCK(cl2lov(obj), llo_io_init,
-				     !io->ci_ignore_layout, env, obj, io);
+			!(io->ci_ignore_layout && io->ci_type == CIT_MISC),
+			env, obj, io);
 }
 
 /**
diff --git a/drivers/staging/lustrefsx/lustre/lov/lov_pack.c b/drivers/staging/lustrefsx/lustre/lov/lov_pack.c
index 940888afffda..dd29ff51dcc1 100644
--- a/drivers/staging/lustrefsx/lustre/lov/lov_pack.c
+++ b/drivers/staging/lustrefsx/lustre/lov/lov_pack.c
@@ -56,13 +56,13 @@ void lov_dump_lmm_common(int level, void *lmmp)
 	struct ost_id	oi;
 
 	lmm_oi_le_to_cpu(&oi, &lmm->lmm_oi);
-	CDEBUG(level, "objid "DOSTID", magic 0x%08x, pattern %#x\n",
-	       POSTID(&oi), le32_to_cpu(lmm->lmm_magic),
-	       le32_to_cpu(lmm->lmm_pattern));
-	CDEBUG(level, "stripe_size %u, stripe_count %u, layout_gen %u\n",
-	       le32_to_cpu(lmm->lmm_stripe_size),
-	       le16_to_cpu(lmm->lmm_stripe_count),
-	       le16_to_cpu(lmm->lmm_layout_gen));
+	CDEBUG_LIMIT(level, "objid "DOSTID", magic 0x%08x, pattern %#x\n",
+		     POSTID(&oi), le32_to_cpu(lmm->lmm_magic),
+		     le32_to_cpu(lmm->lmm_pattern));
+	CDEBUG_LIMIT(level, "stripe_size %u, stripe_count %u, layout_gen %u\n",
+		     le32_to_cpu(lmm->lmm_stripe_size),
+		     le16_to_cpu(lmm->lmm_stripe_count),
+		     le16_to_cpu(lmm->lmm_layout_gen));
 }
 
 static void lov_dump_lmm_objects(int level, struct lov_ost_data *lod,
@@ -71,8 +71,9 @@ static void lov_dump_lmm_objects(int level, struct lov_ost_data *lod,
 	int i;
 
 	if (stripe_count > LOV_V1_INSANE_STRIPE_COUNT) {
-		CDEBUG(level, "bad stripe_count %u > max_stripe_count %u\n",
-		       stripe_count, LOV_V1_INSANE_STRIPE_COUNT);
+		CDEBUG_LIMIT(level,
+			     "bad stripe_count %u > max_stripe_count %u\n",
+			     stripe_count, LOV_V1_INSANE_STRIPE_COUNT);
 		return;
 	}
 
@@ -80,8 +81,8 @@ static void lov_dump_lmm_objects(int level, struct lov_ost_data *lod,
 		struct ost_id oi;
 
 		ostid_le_to_cpu(&lod->l_ost_oi, &oi);
-		CDEBUG(level, "stripe %u idx %u subobj "DOSTID"\n", i,
-		       le32_to_cpu(lod->l_ost_idx), POSTID(&oi));
+		CDEBUG_LIMIT(level, "stripe %u idx %u subobj "DOSTID"\n", i,
+			     le32_to_cpu(lod->l_ost_idx), POSTID(&oi));
 	}
 }
 
@@ -95,7 +96,7 @@ void lov_dump_lmm_v1(int level, struct lov_mds_md_v1 *lmm)
 void lov_dump_lmm_v3(int level, struct lov_mds_md_v3 *lmm)
 {
 	lov_dump_lmm_common(level, lmm);
-	CDEBUG(level, "pool_name "LOV_POOLNAMEF"\n", lmm->lmm_pool_name);
+	CDEBUG_LIMIT(level, "pool_name "LOV_POOLNAMEF"\n", lmm->lmm_pool_name);
 	lov_dump_lmm_objects(level, lmm->lmm_objects,
 			     le16_to_cpu(lmm->lmm_stripe_count));
 }
@@ -113,8 +114,8 @@ void lov_dump_lmm(int level, void *lmm)
 		lov_dump_lmm_v3(level, (struct lov_mds_md_v3 *)lmm);
 		break;
 	default:
-		CDEBUG(level, "unrecognized lmm_magic %x, assuming %x\n",
-		       magic, LOV_MAGIC_V1);
+		CDEBUG_LIMIT(level, "unrecognized lmm_magic %x, assuming %x\n",
+			     magic, LOV_MAGIC_V1);
 		lov_dump_lmm_common(level, lmm);
 		break;
 	}
diff --git a/drivers/staging/lustrefsx/lustre/mdc/mdc_lib.c b/drivers/staging/lustrefsx/lustre/mdc/mdc_lib.c
index f02a8de80d4f..c93ec985f658 100644
--- a/drivers/staging/lustrefsx/lustre/mdc/mdc_lib.c
+++ b/drivers/staging/lustrefsx/lustre/mdc/mdc_lib.c
@@ -344,9 +344,9 @@ static void mdc_setattr_pack_rec(struct mdt_rec_setattr *rec,
 	rec->sa_projid = op_data->op_projid;
 	rec->sa_size   = op_data->op_attr.ia_size;
 	rec->sa_blocks = op_data->op_attr_blocks;
-	rec->sa_atime  = LTIME_S(op_data->op_attr.ia_atime);
-	rec->sa_mtime  = LTIME_S(op_data->op_attr.ia_mtime);
-	rec->sa_ctime  = LTIME_S(op_data->op_attr.ia_ctime);
+	rec->sa_atime = op_data->op_attr.ia_atime.tv_sec;
+	rec->sa_mtime = op_data->op_attr.ia_mtime.tv_sec;
+	rec->sa_ctime = op_data->op_attr.ia_ctime.tv_sec;
 	rec->sa_attr_flags = op_data->op_attr_flags;
 	if ((op_data->op_attr.ia_valid & ATTR_GID) &&
 	     in_group_p(op_data->op_attr.ia_gid))
diff --git a/drivers/staging/lustrefsx/lustre/mdc/mdc_locks.c b/drivers/staging/lustrefsx/lustre/mdc/mdc_locks.c
index 4a532f0a7b50..cb809c2ce4b8 100644
--- a/drivers/staging/lustrefsx/lustre/mdc/mdc_locks.c
+++ b/drivers/staging/lustrefsx/lustre/mdc/mdc_locks.c
@@ -613,14 +613,14 @@ static int mdc_finish_enqueue(struct obd_export *exp,
          * It's important that we do this first!  Otherwise we might exit the
          * function without doing so, and try to replay a failed create
          * (bug 3440) */
-        if (it->it_op & IT_OPEN && req->rq_replay &&
+	if (it->it_op & IT_OPEN && req->rq_replay &&
 	    (!it_disposition(it, DISP_OPEN_OPEN) || it->it_status != 0))
 		mdc_clear_replay_flag(req, it->it_status);
 
-	DEBUG_REQ(D_RPCTRACE, req, "op: %d disposition: %x, status: %d",
+	DEBUG_REQ(D_RPCTRACE, req, "op: %x disposition: %x, status: %d",
 		  it->it_op, it->it_disposition, it->it_status);
 
-        /* We know what to expect, so we do any byte flipping required here */
+	/* We know what to expect, so we do any byte flipping required here */
 	if (it_has_reply_body(it)) {
                 struct mdt_body *body;
 
@@ -683,6 +683,8 @@ static int mdc_finish_enqueue(struct obd_export *exp,
 		/* maybe the lock was granted right away and layout
 		 * is packed into RMF_DLM_LVB of req */
 		lvb_len = req_capsule_get_size(pill, &RMF_DLM_LVB, RCL_SERVER);
+		CDEBUG(D_INFO, "%s: layout return lvb %d transno %lld\n",
+		       class_exp2obd(exp)->obd_name, lvb_len, req->rq_transno);
 		if (lvb_len > 0) {
 			lvb_data = req_capsule_server_sized_get(pill,
 							&RMF_DLM_LVB, lvb_len);
diff --git a/drivers/staging/lustrefsx/lustre/mdc/mdc_reint.c b/drivers/staging/lustrefsx/lustre/mdc/mdc_reint.c
index 5b7be3d8af58..db2e66565874 100644
--- a/drivers/staging/lustrefsx/lustre/mdc/mdc_reint.c
+++ b/drivers/staging/lustrefsx/lustre/mdc/mdc_reint.c
@@ -131,10 +131,9 @@ int mdc_setattr(struct obd_export *exp, struct md_op_data *op_data,
 	}
 
         if (op_data->op_attr.ia_valid & (ATTR_MTIME | ATTR_CTIME))
-		CDEBUG(D_INODE, "setting mtime " LTIME_FMT ", ctime "
-		       LTIME_FMT "\n",
-                       LTIME_S(op_data->op_attr.ia_mtime),
-                       LTIME_S(op_data->op_attr.ia_ctime));
+		CDEBUG(D_INODE, "setting mtime %lld, ctime %lld\n",
+		       (s64)op_data->op_attr.ia_mtime.tv_sec,
+		       (s64)op_data->op_attr.ia_ctime.tv_sec);
 	mdc_setattr_pack(req, op_data, ea, ealen);
 
 	req_capsule_set_size(&req->rq_pill, &RMF_ACL, RCL_SERVER,
diff --git a/drivers/staging/lustrefsx/lustre/mdc/mdc_request.c b/drivers/staging/lustrefsx/lustre/mdc/mdc_request.c
index 1530f5e8c342..6c8da5866a8b 100644
--- a/drivers/staging/lustrefsx/lustre/mdc/mdc_request.c
+++ b/drivers/staging/lustrefsx/lustre/mdc/mdc_request.c
@@ -990,34 +990,16 @@ static struct page *mdc_page_locate(struct address_space *mapping, __u64 *hash,
 	 */
 	unsigned long offset = hash_x_index(*hash, hash64);
 	struct page *page;
-#ifdef HAVE_ADDRESS_SPACE_XARRAY
-	XA_STATE(xas, &mapping->i_pages, offset);
-
-	xas_lock_irq(&xas);
-	page = xas_find(&xas, ULONG_MAX);
-	if (xa_is_value(page))
-		page = NULL;
-	if (page) {
-#else
 	int found;
 
-	lock_mappings(mapping);
-#ifdef HAVE_ADDRESS_SPACE_IPAGES
-	found = radix_tree_gang_lookup(&mapping->i_pages,
-#else
+	xa_lock_irq(&mapping->i_pages);
 	found = radix_tree_gang_lookup(&mapping->page_tree,
-#endif
 				       (void **)&page, offset, 1);
-	if (found > 0 && !radix_tree_exceptional_entry(page)) {
-#endif
+	if (found > 0 && !xa_is_value(page)) {
 		struct lu_dirpage *dp;
 
 		get_page(page);
-#ifdef HAVE_ADDRESS_SPACE_XARRAY
-		xas_unlock_irq(&xas);
-#else
-		unlock_mappings(mapping);
-#endif
+		xa_unlock_irq(&mapping->i_pages);
 		/*
 		 * In contrast to find_lock_page() we are sure that directory
 		 * page cannot be truncated (while DLM lock is held) and,
@@ -1066,12 +1048,8 @@ static struct page *mdc_page_locate(struct address_space *mapping, __u64 *hash,
 			page = ERR_PTR(-EIO);
 		}
 	} else {
-#ifdef HAVE_ADDRESS_SPACE_XARRAY
-		xas_unlock_irq(&xas);
-#else
-		unlock_mappings(mapping);
+		xa_unlock_irq(&mapping->i_pages);
 		page = NULL;
-#endif
 	}
 	return page;
 }
diff --git a/drivers/staging/lustrefsx/lustre/nodist b/drivers/staging/lustrefsx/lustre/nodist
new file mode 100644
index 000000000000..24f55bb96b97
--- /dev/null
+++ b/drivers/staging/lustrefsx/lustre/nodist
@@ -0,0 +1,9 @@
+obd-*/obd-*
+CVS
+*~
+make.rules
+config.*
+*.o
+*.orig
+*.backup
+.depfiles
diff --git a/drivers/staging/lustrefsx/lustre/obdclass/class_obd.c b/drivers/staging/lustrefsx/lustre/obdclass/class_obd.c
index 8e2d803fe3bc..b6576eb9b52e 100644
--- a/drivers/staging/lustrefsx/lustre/obdclass/class_obd.c
+++ b/drivers/staging/lustrefsx/lustre/obdclass/class_obd.c
@@ -540,10 +540,10 @@ static int __init obdclass_init(void)
 	/* Default the dirty page cache cap to 1/2 of system memory.
 	 * For clients with less memory, a larger fraction is needed
 	 * for other purposes (mostly for BGL). */
-	if (TOTALRAM_PAGES <= 512 << (20 - PAGE_SHIFT))
-		obd_max_dirty_pages = TOTALRAM_PAGES / 4;
+	if (cfs_totalram_pages() <= 512 << (20 - PAGE_SHIFT))
+		obd_max_dirty_pages = cfs_totalram_pages() / 4;
 	else
-		obd_max_dirty_pages = TOTALRAM_PAGES / 2;
+		obd_max_dirty_pages = cfs_totalram_pages() / 2;
 
 	err = obd_init_caches();
 	if (err)
diff --git a/drivers/staging/lustrefsx/lustre/obdclass/dt_object.c b/drivers/staging/lustrefsx/lustre/obdclass/dt_object.c
index a8f144fd4c0e..a48e7cbe7ec1 100644
--- a/drivers/staging/lustrefsx/lustre/obdclass/dt_object.c
+++ b/drivers/staging/lustrefsx/lustre/obdclass/dt_object.c
@@ -136,24 +136,6 @@ int dt_txn_hook_stop(const struct lu_env *env, struct thandle *th)
 }
 EXPORT_SYMBOL(dt_txn_hook_stop);
 
-void dt_txn_hook_commit(struct thandle *th)
-{
-	struct dt_txn_callback *cb;
-
-	if (th->th_local)
-		return;
-
-	list_for_each_entry(cb, &th->th_dev->dd_txn_callbacks,
-			    dtc_linkage) {
-		/* Right now, the bottom device (OSD) will use this hook
-		 * commit to notify OSP, so we do not check and replace
-		 * the thandle to top thandle now */
-		if (cb->dtc_txn_commit)
-			cb->dtc_txn_commit(th, cb->dtc_cookie);
-	}
-}
-EXPORT_SYMBOL(dt_txn_hook_commit);
-
 int dt_device_init(struct dt_device *dev, struct lu_device_type *t)
 {
 	INIT_LIST_HEAD(&dev->dd_txn_callbacks);
diff --git a/drivers/staging/lustrefsx/lustre/obdclass/genops.c b/drivers/staging/lustrefsx/lustre/obdclass/genops.c
index c2b1e35fe86e..ef84bfe45c93 100644
--- a/drivers/staging/lustrefsx/lustre/obdclass/genops.c
+++ b/drivers/staging/lustrefsx/lustre/obdclass/genops.c
@@ -366,7 +366,7 @@ struct obd_device *class_newdev(const char *type_name, const char *name,
 
 	newdev->obd_conn_inprogress = 0;
 
-	strncpy(newdev->obd_uuid.uuid, uuid, strlen(uuid));
+	strncpy(newdev->obd_uuid.uuid, uuid, UUID_MAX);
 
 	CDEBUG(D_IOCTL, "Allocate new device %s (%p)\n",
 	       newdev->obd_name, newdev);
@@ -839,9 +839,9 @@ int obd_init_caches(void)
 	ENTRY;
 
 	LASSERT(obd_device_cachep == NULL);
-	obd_device_cachep = kmem_cache_create("ll_obd_dev_cache",
-					      sizeof(struct obd_device),
-					      0, 0, NULL);
+	obd_device_cachep = kmem_cache_create_usercopy("ll_obd_dev_cache",
+				sizeof(struct obd_device),
+				0, 0, 0, sizeof(struct obd_device), NULL);
 	if (!obd_device_cachep)
 		GOTO(out, rc = -ENOMEM);
 
diff --git a/drivers/staging/lustrefsx/lustre/obdclass/linux/linux-sysctl.c b/drivers/staging/lustrefsx/lustre/obdclass/linux/linux-sysctl.c
index a531c970c3fb..e8016c77c750 100644
--- a/drivers/staging/lustrefsx/lustre/obdclass/linux/linux-sysctl.c
+++ b/drivers/staging/lustrefsx/lustre/obdclass/linux/linux-sysctl.c
@@ -111,7 +111,7 @@ static ssize_t max_dirty_mb_store(struct kobject *kobj, struct attribute *attr,
 
 	val *= 1 << (20 - PAGE_SHIFT); /* convert to pages */
 
-	if (val > ((TOTALRAM_PAGES / 10) * 9)) {
+	if (val > ((cfs_totalram_pages() / 10) * 9)) {
 		/* Somebody wants to assign too much memory to dirty pages */
 		return -EINVAL;
 	}
diff --git a/drivers/staging/lustrefsx/lustre/obdclass/llog_cat.c b/drivers/staging/lustrefsx/lustre/obdclass/llog_cat.c
index 058d87e7fb3d..e85e08bbd10c 100644
--- a/drivers/staging/lustrefsx/lustre/obdclass/llog_cat.c
+++ b/drivers/staging/lustrefsx/lustre/obdclass/llog_cat.c
@@ -386,8 +386,7 @@ static struct llog_handle *llog_cat_current_log(struct llog_handle *cathandle,
 
 		down_write_nested(&loghandle->lgh_lock, LLOGH_LOG);
 		llh = loghandle->lgh_hdr;
-		LASSERT(llh);
-		if (!llog_is_full(loghandle))
+		if (llh == NULL || !llog_is_full(loghandle))
 			GOTO(out_unlock, loghandle);
 		else
 			up_write(&loghandle->lgh_lock);
diff --git a/drivers/staging/lustrefsx/lustre/obdclass/lu_object.c b/drivers/staging/lustrefsx/lustre/obdclass/lu_object.c
index 96ebb4cf9b01..21a137bad0ba 100644
--- a/drivers/staging/lustrefsx/lustre/obdclass/lu_object.c
+++ b/drivers/staging/lustrefsx/lustre/obdclass/lu_object.c
@@ -888,7 +888,7 @@ static unsigned long lu_htable_order(struct lu_device *top)
          *
          * Size of lu_object is (arbitrary) taken as 1K (together with inode).
          */
-	cache_size = TOTALRAM_PAGES;
+	cache_size = cfs_totalram_pages();
 
 #if BITS_PER_LONG == 32
         /* limit hashtable size for lowmem systems to low RAM */
diff --git a/drivers/staging/lustrefsx/lustre/obdclass/obd_config.c b/drivers/staging/lustrefsx/lustre/obdclass/obd_config.c
index 936f1db0d70b..46b2b941bae5 100644
--- a/drivers/staging/lustrefsx/lustre/obdclass/obd_config.c
+++ b/drivers/staging/lustrefsx/lustre/obdclass/obd_config.c
@@ -1752,7 +1752,7 @@ static struct lcfg_type_data {
 	{ LCFG_DEL_CONN, "del_conn", { "1", "2", "3", "4" }  },
 	{ LCFG_LOV_ADD_OBD, "add_osc", { "ost", "index", "gen", "UUID" } },
 	{ LCFG_LOV_DEL_OBD, "del_osc", { "1", "2", "3", "4" } },
-	{ LCFG_PARAM, "set_param", { "parameter", "value", "3", "4" } },
+	{ LCFG_PARAM, "conf_param", { "parameter", "value", "3", "4" } },
 	{ LCFG_MARKER, "marker", { "1", "2", "3", "4" } },
 	{ LCFG_LOG_START, "log_start", { "1", "2", "3", "4" } },
 	{ LCFG_LOG_END, "log_end", { "1", "2", "3", "4" } },
@@ -1766,6 +1766,7 @@ static struct lcfg_type_data {
 	{ LCFG_POOL_DEL, "del_pool", { "fsname", "pool", "3", "4" } },
 	{ LCFG_SET_LDLM_TIMEOUT, "set_ldlm_timeout",
 	  { "parameter", "2", "3", "4" } },
+	{ LCFG_SET_PARAM, "set_param", { "parameter", "value", "3", "4" } },
 	{ 0, NULL, { NULL, NULL, NULL, NULL } }
 };
 
@@ -1793,11 +1794,11 @@ static struct lcfg_type_data *lcfg_cmd2data(__u32 cmd)
  */
 int class_config_yaml_output(struct llog_rec_hdr *rec, char *buf, int size)
 {
-	struct lustre_cfg	*lcfg = (struct lustre_cfg *)(rec + 1);
-	char			*ptr = buf;
-	char			*end = buf + size;
-	int			 rc = 0, i;
-	struct lcfg_type_data	*ldata;
+	struct lustre_cfg *lcfg = (struct lustre_cfg *)(rec + 1);
+	char *ptr = buf;
+	char *end = buf + size;
+	int rc = 0, i;
+	struct lcfg_type_data *ldata;
 
 	LASSERT(rec->lrh_type == OBD_CFG_REC);
 	rc = lustre_cfg_sanity_check(lcfg, rec->lrh_len);
@@ -1814,35 +1815,82 @@ int class_config_yaml_output(struct llog_rec_hdr *rec, char *buf, int size)
 	/* form YAML entity */
 	ptr += snprintf(ptr, end - ptr, "- { index: %u, event: %s",
 			rec->lrh_index, ldata->ltd_name);
+	if (end - ptr <= 0)
+		goto out_overflow;
 
-	if (lcfg->lcfg_flags)
+	if (lcfg->lcfg_flags) {
 		ptr += snprintf(ptr, end - ptr, ", flags: %#08x",
 				lcfg->lcfg_flags);
-	if (lcfg->lcfg_num)
+		if (end - ptr <= 0)
+			goto out_overflow;
+	}
+	if (lcfg->lcfg_num) {
 		ptr += snprintf(ptr, end - ptr, ", num: %#08x",
 				lcfg->lcfg_num);
+		if (end - ptr <= 0)
+			goto out_overflow;
+	}
 	if (lcfg->lcfg_nid) {
 		char nidstr[LNET_NIDSTR_SIZE];
 
 		libcfs_nid2str_r(lcfg->lcfg_nid, nidstr, sizeof(nidstr));
 		ptr += snprintf(ptr, end - ptr, ", nid: %s(%#llx)",
 				nidstr, lcfg->lcfg_nid);
+		if (end - ptr <= 0)
+			goto out_overflow;
 	}
 
-	if (LUSTRE_CFG_BUFLEN(lcfg, 0) > 0)
+	if (LUSTRE_CFG_BUFLEN(lcfg, 0) > 0) {
 		ptr += snprintf(ptr, end - ptr, ", device: %s",
 				lustre_cfg_string(lcfg, 0));
+		if (end - ptr <= 0)
+			goto out_overflow;
+	}
+
+	if (lcfg->lcfg_command == LCFG_SET_PARAM) {
+		/*
+		 * set_param -P parameters have param=val here, separate
+		 * them through pointer magic and print them out in
+		 * native yamlese
+		 */
+		char *cfg_str = lustre_cfg_string(lcfg, 1);
+		char *tmp = strchr(cfg_str, '=');
+		size_t len;
+
+		if (tmp == NULL)
+			goto out_done;
+
+		ptr += snprintf(ptr, end - ptr, ", %s: ", ldata->ltd_bufs[0]);
+		len = tmp - cfg_str + 1;
+		snprintf(ptr, len, "%s", cfg_str);
+		ptr += len - 1;
+
+		ptr += snprintf(ptr, end - ptr, ", %s: ", ldata->ltd_bufs[1]);
+		ptr += snprintf(ptr, end - ptr, "%s", tmp + 1);
+
+		goto out_done;
+	}
 
 	for (i = 1; i < lcfg->lcfg_bufcount; i++) {
-		if (LUSTRE_CFG_BUFLEN(lcfg, i) > 0)
+		if (LUSTRE_CFG_BUFLEN(lcfg, i) > 0) {
 			ptr += snprintf(ptr, end - ptr, ", %s: %s",
 					ldata->ltd_bufs[i - 1],
 					lustre_cfg_string(lcfg, i));
+			if (end - ptr <= 0)
+				goto out_overflow;
+		}
 	}
 
+out_done:
 	ptr += snprintf(ptr, end - ptr, " }\n");
-	/* return consumed bytes */
+out_overflow:
+	/* Return consumed bytes.  If the buffer overflowed, zero last byte */
 	rc = ptr - buf;
+	if (rc > size) {
+		rc = -EOVERFLOW;
+		*(end - 1) = '\0';
+	}
+
 	return rc;
 }
 
diff --git a/drivers/staging/lustrefsx/lustre/obdclass/obd_mount_server.c b/drivers/staging/lustrefsx/lustre/obdclass/obd_mount_server.c
index 204fc889da45..b1f59d8f6b30 100644
--- a/drivers/staging/lustrefsx/lustre/obdclass/obd_mount_server.c
+++ b/drivers/staging/lustrefsx/lustre/obdclass/obd_mount_server.c
@@ -43,7 +43,9 @@
 #define PRINT_MASK (D_SUPER | D_CONFIG)
 
 #include <linux/types.h>
+#ifdef HAVE_LINUX_SELINUX_IS_ENABLED
 #include <linux/selinux.h>
+#endif
 #include <linux/statfs.h>
 #include <linux/version.h>
 #ifdef HAVE_KERNEL_LOCKED
@@ -559,7 +561,7 @@ void lustre_notify_lwp_list(struct obd_export *exp)
 }
 EXPORT_SYMBOL(lustre_notify_lwp_list);
 
-static int lustre_lwp_connect(struct obd_device *lwp)
+static int lustre_lwp_connect(struct obd_device *lwp, bool is_mdt)
 {
 	struct lu_env		 env;
 	struct lu_context	 session_ctx;
@@ -585,11 +587,14 @@ static int lustre_lwp_connect(struct obd_device *lwp)
 
 	data->ocd_connect_flags = OBD_CONNECT_VERSION | OBD_CONNECT_INDEX;
 	data->ocd_version = LUSTRE_VERSION_CODE;
-	data->ocd_connect_flags |= OBD_CONNECT_MDS_MDS | OBD_CONNECT_FID |
-		OBD_CONNECT_AT | OBD_CONNECT_LRU_RESIZE |
-		OBD_CONNECT_FULL20 | OBD_CONNECT_LVB_TYPE |
-		OBD_CONNECT_LIGHTWEIGHT | OBD_CONNECT_LFSCK |
-		OBD_CONNECT_BULK_MBITS;
+	data->ocd_connect_flags |= OBD_CONNECT_FID | OBD_CONNECT_AT |
+		OBD_CONNECT_LRU_RESIZE | OBD_CONNECT_FULL20 |
+		OBD_CONNECT_LVB_TYPE | OBD_CONNECT_LIGHTWEIGHT |
+		OBD_CONNECT_LFSCK | OBD_CONNECT_BULK_MBITS;
+
+	if (is_mdt)
+		data->ocd_connect_flags |= OBD_CONNECT_MDS_MDS;
+
 	OBD_ALLOC_PTR(uuid);
 	if (uuid == NULL)
 		GOTO(out, rc = -ENOMEM);
@@ -673,7 +678,7 @@ static int lustre_lwp_setup(struct lustre_cfg *lcfg, struct lustre_sb_info *lsi,
 	obd = class_name2obd(lwpname);
 	LASSERT(obd != NULL);
 
-	rc = lustre_lwp_connect(obd);
+	rc = lustre_lwp_connect(obd, strstr(lsi->lsi_svname, "-MDT") != NULL);
 	if (rc == 0) {
 		obd->u.cli.cl_max_mds_easize = MAX_MD_SIZE;
 		spin_lock(&lsi->lsi_lwp_lock);
diff --git a/drivers/staging/lustrefsx/lustre/obdclass/obdo.c b/drivers/staging/lustrefsx/lustre/obdclass/obdo.c
index a7f7be397322..7d14851f799f 100644
--- a/drivers/staging/lustrefsx/lustre/obdclass/obdo.c
+++ b/drivers/staging/lustrefsx/lustre/obdclass/obdo.c
@@ -69,21 +69,20 @@ void obdo_from_inode(struct obdo *dst, struct inode *src, u64 valid)
 	u64 newvalid = 0;
 
 	if (valid & (OBD_MD_FLCTIME | OBD_MD_FLMTIME))
-		CDEBUG(D_INODE, "valid %#llx, new time "
-			LTIME_FMT "/" LTIME_FMT "\n",
-			valid, LTIME_S(src->i_mtime),
-			LTIME_S(src->i_ctime));
+		CDEBUG(D_INODE, "valid %#llx, new time %lld/%lld\n",
+		       valid, (s64) src->i_mtime.tv_sec,
+		       (s64) src->i_ctime.tv_sec);
 
         if (valid & OBD_MD_FLATIME) {
-                dst->o_atime = LTIME_S(src->i_atime);
+		dst->o_atime = src->i_atime.tv_sec;
                 newvalid |= OBD_MD_FLATIME;
         }
         if (valid & OBD_MD_FLMTIME) {
-                dst->o_mtime = LTIME_S(src->i_mtime);
+		dst->o_mtime = src->i_mtime.tv_sec;
                 newvalid |= OBD_MD_FLMTIME;
         }
         if (valid & OBD_MD_FLCTIME) {
-                dst->o_ctime = LTIME_S(src->i_ctime);
+		dst->o_ctime = src->i_ctime.tv_sec;
                 newvalid |= OBD_MD_FLCTIME;
         }
         if (valid & OBD_MD_FLSIZE) {
diff --git a/drivers/staging/lustrefsx/lustre/obdecho/echo_client.c b/drivers/staging/lustrefsx/lustre/obdecho/echo_client.c
index 769d59ed21b7..26065b110e59 100644
--- a/drivers/staging/lustrefsx/lustre/obdecho/echo_client.c
+++ b/drivers/staging/lustrefsx/lustre/obdecho/echo_client.c
@@ -1454,45 +1454,41 @@ static int echo_attr_get_complex(const struct lu_env *env,
 {
 	struct echo_thread_info	*info = echo_env_info(env);
 	struct lu_buf		*buf = &info->eti_buf;
-	umode_t		 mode = lu_object_attr(&next->mo_lu);
-	int			 need = ma->ma_need;
+	umode_t			 mode = lu_object_attr(&next->mo_lu);
 	int			 rc = 0, rc2;
 
 	ENTRY;
 
 	ma->ma_valid = 0;
 
-	if (need & MA_INODE) {
-		ma->ma_need = MA_INODE;
+	if (ma->ma_need & MA_INODE) {
 		rc = mo_attr_get(env, next, ma);
 		if (rc)
 			GOTO(out, rc);
 		ma->ma_valid |= MA_INODE;
 	}
 
-	if (need & MA_LOV) {
-		if (S_ISREG(mode) || S_ISDIR(mode)) {
-			LASSERT(ma->ma_lmm_size > 0);
-			buf->lb_buf = ma->ma_lmm;
-			buf->lb_len = ma->ma_lmm_size;
-			rc2 = mo_xattr_get(env, next, buf, XATTR_NAME_LOV);
-			if (rc2 > 0) {
-				ma->ma_lmm_size = rc2;
-				ma->ma_valid |= MA_LOV;
-			} else if (rc2 == -ENODATA) {
-				/* no LOV EA */
-				ma->ma_lmm_size = 0;
-			} else if (rc2 == -ERANGE) {
-				rc2 = echo_big_lmm_get(env, next, ma);
-				if (rc2 < 0)
-					GOTO(out, rc = rc2);
-			} else {
+	if ((ma->ma_need & MA_LOV) && (S_ISREG(mode) || S_ISDIR(mode))) {
+		LASSERT(ma->ma_lmm_size > 0);
+		buf->lb_buf = ma->ma_lmm;
+		buf->lb_len = ma->ma_lmm_size;
+		rc2 = mo_xattr_get(env, next, buf, XATTR_NAME_LOV);
+		if (rc2 > 0) {
+			ma->ma_lmm_size = rc2;
+			ma->ma_valid |= MA_LOV;
+		} else if (rc2 == -ENODATA) {
+			/* no LOV EA */
+			ma->ma_lmm_size = 0;
+		} else if (rc2 == -ERANGE) {
+			rc2 = echo_big_lmm_get(env, next, ma);
+			if (rc2 < 0)
 				GOTO(out, rc = rc2);
-			}
+		} else {
+			GOTO(out, rc = rc2);
 		}
 	}
 
-	if (need & MA_LMV && S_ISDIR(mode)) {
+	if ((ma->ma_need & MA_LMV) && S_ISDIR(mode)) {
 		LASSERT(ma->ma_lmm_size > 0);
 		buf->lb_buf = ma->ma_lmm;
 		buf->lb_len = ma->ma_lmm_size;
@@ -1513,7 +1509,7 @@ static int echo_attr_get_complex(const struct lu_env *env,
 	}
 
 #ifdef CONFIG_FS_POSIX_ACL
-	if (need & MA_ACL_DEF && S_ISDIR(mode)) {
+	if ((ma->ma_need & MA_ACL_DEF) && S_ISDIR(mode)) {
 		buf->lb_buf = ma->ma_acl;
 		buf->lb_len = ma->ma_acl_size;
 		rc2 = mo_xattr_get(env, next, buf, XATTR_NAME_ACL_DEFAULT);
@@ -1529,7 +1525,6 @@ static int echo_attr_get_complex(const struct lu_env *env,
 	}
 #endif
 out:
-	ma->ma_need = need;
 	CDEBUG(D_INODE, "after getattr rc = %d, ma_valid = %#llx ma_lmm=%p\n",
 	       rc, ma->ma_valid, ma->ma_lmm);
 	RETURN(rc);
diff --git a/drivers/staging/lustrefsx/lustre/osc/lproc_osc.c b/drivers/staging/lustrefsx/lustre/osc/lproc_osc.c
index 6c71d4c6b19d..5c9a8c6c2219 100644
--- a/drivers/staging/lustrefsx/lustre/osc/lproc_osc.c
+++ b/drivers/staging/lustrefsx/lustre/osc/lproc_osc.c
@@ -160,7 +160,7 @@ static ssize_t osc_max_dirty_mb_seq_write(struct file *file,
 
 	if (pages_number <= 0 ||
 	    pages_number >= OSC_MAX_DIRTY_MB_MAX << (20 - PAGE_SHIFT) ||
-	    pages_number > TOTALRAM_PAGES / 4) /* 1/4 of RAM */
+	    pages_number > cfs_totalram_pages() / 4) /* 1/4 of RAM */
 		return -ERANGE;
 
 	spin_lock(&cli->cl_loi_list_lock);
diff --git a/drivers/staging/lustrefsx/lustre/osc/osc_request.c b/drivers/staging/lustrefsx/lustre/osc/osc_request.c
index db6ca2da2e4d..b50f4d6ee501 100644
--- a/drivers/staging/lustrefsx/lustre/osc/osc_request.c
+++ b/drivers/staging/lustrefsx/lustre/osc/osc_request.c
@@ -697,11 +697,12 @@ static void osc_announce_cached(struct client_obd *cli, struct obdo *oa,
 		oa->o_undirty = 0;
 	} else {
 		unsigned long nrpages;
+		unsigned long undirty;
 
 		nrpages = cli->cl_max_pages_per_rpc;
 		nrpages *= cli->cl_max_rpcs_in_flight + 1;
 		nrpages = max(nrpages, cli->cl_dirty_max_pages);
-		oa->o_undirty = nrpages << PAGE_SHIFT;
+		undirty = nrpages << PAGE_SHIFT;
 		if (OCD_HAS_FLAG(&cli->cl_import->imp_connect_data,
 				 GRANT_PARAM)) {
 			int nrextents;
@@ -710,8 +711,13 @@ static void osc_announce_cached(struct client_obd *cli, struct obdo *oa,
 			 * grant space */
 			nrextents = (nrpages + cli->cl_max_extent_pages - 1)  /
 				     cli->cl_max_extent_pages;
-			oa->o_undirty += nrextents * cli->cl_grant_extent_tax;
+			undirty += nrextents * cli->cl_grant_extent_tax;
 		}
+		/* Do not ask for more than OBD_MAX_GRANT - a margin for server
+		 * to add extent tax, etc.
+		 */
+		oa->o_undirty = min(undirty, OBD_MAX_GRANT -
+				    (PTLRPC_MAX_BRW_PAGES << PAGE_SHIFT)*4UL);
         }
 	oa->o_grant = cli->cl_avail_grant + cli->cl_reserved_grant;
         oa->o_dropped = cli->cl_lost_grant;
@@ -1048,7 +1054,7 @@ static inline int can_merge_pages(struct brw_page *p1, struct brw_page *p2)
                  * safe to combine */
                 if (unlikely((p1->flag & mask) != (p2->flag & mask))) {
                         CWARN("Saw flags 0x%x and 0x%x in the same brw, please "
-                              "report this at https://jira.hpdd.intel.com/\n",
+                              "report this at https://jira.whamcloud.com/\n",
                               p1->flag, p2->flag);
                 }
                 return 0;
diff --git a/drivers/staging/lustrefsx/lustre/ptlrpc/client.c b/drivers/staging/lustrefsx/lustre/ptlrpc/client.c
index d127e5e63bfd..9642a5644009 100644
--- a/drivers/staging/lustrefsx/lustre/ptlrpc/client.c
+++ b/drivers/staging/lustrefsx/lustre/ptlrpc/client.c
@@ -1896,10 +1896,6 @@ int ptlrpc_check_set(const struct lu_env *env, struct ptlrpc_request_set *set)
 					spin_lock(&req->rq_lock);
 					req->rq_resend = 1;
 					spin_unlock(&req->rq_lock);
-
-					if (req->rq_bulk != NULL &&
-					    !ptlrpc_unregister_bulk(req, 1))
-						continue;
                                 }
                                 /*
                                  * rq_wait_ctx is only touched by ptlrpcd,
@@ -1926,6 +1922,12 @@ int ptlrpc_check_set(const struct lu_env *env, struct ptlrpc_request_set *set)
 					spin_unlock(&req->rq_lock);
 				}
 
+				/* In any case, the previous bulk should be
+				 * cleaned up to prepare for the new sending */
+				if (req->rq_bulk != NULL &&
+				    !ptlrpc_unregister_bulk(req, 1))
+					continue;
+
 				rc = ptl_send_rpc(req, 0);
 				if (rc == -ENOMEM) {
 					spin_lock(&imp->imp_lock);
diff --git a/drivers/staging/lustrefsx/lustre/ptlrpc/import.c b/drivers/staging/lustrefsx/lustre/ptlrpc/import.c
index 8338095a43bb..827a989f1e13 100644
--- a/drivers/staging/lustrefsx/lustre/ptlrpc/import.c
+++ b/drivers/staging/lustrefsx/lustre/ptlrpc/import.c
@@ -37,6 +37,7 @@
 #define DEBUG_SUBSYSTEM S_RPC
 
 #include <linux/kthread.h>
+#include <linux/delay.h>
 #include <obd_support.h>
 #include <lustre_ha.h>
 #include <lustre_net.h>
@@ -292,6 +293,10 @@ void ptlrpc_invalidate_import(struct obd_import *imp)
 	if (!imp->imp_invalid || imp->imp_obd->obd_no_recov)
 		ptlrpc_deactivate_import(imp);
 
+	if (OBD_FAIL_PRECHECK(OBD_FAIL_PTLRPC_CONNECT_RACE)) {
+		OBD_RACE(OBD_FAIL_PTLRPC_CONNECT_RACE);
+		msleep(10 * MSEC_PER_SEC);
+	}
 	CFS_FAIL_TIMEOUT(OBD_FAIL_MGS_CONNECT_NET, 3 * cfs_fail_val / 2);
 	LASSERT(imp->imp_invalid);
 
@@ -666,6 +671,7 @@ int ptlrpc_connect_import(struct obd_import *imp)
 		CERROR("already connected\n");
 		RETURN(0);
 	} else if (imp->imp_state == LUSTRE_IMP_CONNECTING ||
+		   imp->imp_state == LUSTRE_IMP_EVICTED ||
 		   imp->imp_connected) {
 		spin_unlock(&imp->imp_lock);
 		CERROR("already connecting\n");
@@ -796,18 +802,6 @@ static int ptlrpc_connect_set_flags(struct obd_import *imp,
 	static bool warned;
 	struct client_obd *cli = &imp->imp_obd->u.cli;
 
-	if ((imp->imp_connect_flags_orig & OBD_CONNECT_IBITS) &&
-	    !(ocd->ocd_connect_flags & OBD_CONNECT_IBITS)) {
-		LCONSOLE_WARN("%s: MDS %s does not support ibits "
-			      "lock, either very old or invalid: "
-			      "requested %#llx, replied %#llx\n",
-			      imp->imp_obd->obd_name,
-			      imp->imp_connection->c_remote_uuid.uuid,
-			      imp->imp_connect_flags_orig,
-			      ocd->ocd_connect_flags);
-		return -EPROTO;
-	}
-
 	spin_lock(&imp->imp_lock);
 	list_del(&imp->imp_conn_current->oic_item);
 	list_add(&imp->imp_conn_current->oic_item,
diff --git a/drivers/staging/lustrefsx/lustre/ptlrpc/lproc_ptlrpc.c b/drivers/staging/lustrefsx/lustre/ptlrpc/lproc_ptlrpc.c
index 93871b4c7d09..711c77650a56 100644
--- a/drivers/staging/lustrefsx/lustre/ptlrpc/lproc_ptlrpc.c
+++ b/drivers/staging/lustrefsx/lustre/ptlrpc/lproc_ptlrpc.c
@@ -321,7 +321,7 @@ ptlrpc_lprocfs_req_history_max_seq_write(struct file *file,
 	 * far. */
 	bufpages = (svc->srv_buf_size + PAGE_SIZE - 1) >>
 							PAGE_SHIFT;
-	if (val > TOTALRAM_PAGES/(2 * bufpages))
+	if (val > cfs_totalram_pages() / (2 * bufpages))
 		return -ERANGE;
 
 	spin_lock(&svc->srv_lock);
diff --git a/drivers/staging/lustrefsx/lustre/ptlrpc/recover.c b/drivers/staging/lustrefsx/lustre/ptlrpc/recover.c
index c526e9e5c65f..aacb929beae2 100644
--- a/drivers/staging/lustrefsx/lustre/ptlrpc/recover.c
+++ b/drivers/staging/lustrefsx/lustre/ptlrpc/recover.c
@@ -346,6 +346,8 @@ int ptlrpc_recover_import(struct obd_import *imp, char *new_uuid, int async)
         if (rc)
                 GOTO(out, rc);
 
+	OBD_RACE(OBD_FAIL_PTLRPC_CONNECT_RACE);
+
         rc = ptlrpc_connect_import(imp);
         if (rc)
                 GOTO(out, rc);
diff --git a/drivers/staging/lustrefsx/lustre/ptlrpc/sec_bulk.c b/drivers/staging/lustrefsx/lustre/ptlrpc/sec_bulk.c
index 488b2398e434..42841f0c0aaf 100644
--- a/drivers/staging/lustrefsx/lustre/ptlrpc/sec_bulk.c
+++ b/drivers/staging/lustrefsx/lustre/ptlrpc/sec_bulk.c
@@ -155,7 +155,7 @@ int sptlrpc_proc_enc_pool_seq_show(struct seq_file *m, void *v)
 		   "max waitqueue depth:     %u\n"
 		   "max wait time:           %ld/%lu\n"
 		   "out of mem:              %lu\n",
-		   TOTALRAM_PAGES, PAGES_PER_POOL,
+		   cfs_totalram_pages(), PAGES_PER_POOL,
 		   page_pools.epp_max_pages,
 		   page_pools.epp_max_pools,
 		   page_pools.epp_total_pages,
@@ -775,9 +775,9 @@ int sptlrpc_enc_pool_init(void)
 	DEF_SHRINKER_VAR(shvar, enc_pools_shrink,
 			 enc_pools_shrink_count, enc_pools_shrink_scan);
 
-	page_pools.epp_max_pages = TOTALRAM_PAGES / 8;
+	page_pools.epp_max_pages = cfs_totalram_pages() / 8;
 	if (enc_pool_max_memory_mb > 0 &&
-	    enc_pool_max_memory_mb <= (TOTALRAM_PAGES >> mult))
+	    enc_pool_max_memory_mb <= (cfs_totalram_pages() >> mult))
 		page_pools.epp_max_pages = enc_pool_max_memory_mb << mult;
 
 	page_pools.epp_max_pools = npages_to_npools(page_pools.epp_max_pages);
diff --git a/drivers/staging/lustrefsx/lustre/ptlrpc/wirehdr.c b/drivers/staging/lustrefsx/lustre/ptlrpc/wirehdr.c
new file mode 100644
index 000000000000..3a9daf899c26
--- /dev/null
+++ b/drivers/staging/lustrefsx/lustre/ptlrpc/wirehdr.c
@@ -0,0 +1,44 @@
+/*
+ * GPL HEADER START
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 only,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License version 2 for more details (a copy is included
+ * in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License
+ * version 2 along with this program; If not, see
+ * http://www.gnu.org/licenses/gpl-2.0.html
+ *
+ * GPL HEADER END
+ */
+/*
+ * Copyright (c) 2007, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Use is subject to license terms.
+ *
+ * Copyright (c) 2011, 2014, Intel Corporation.
+ */
+/*
+ * This file is part of Lustre, http://www.lustre.org/
+ * Lustre is a trademark of Sun Microsystems, Inc.
+ */
+
+#define DEBUG_SUBSYSTEM S_RPC
+
+#ifdef CONFIG_FS_POSIX_ACL
+# include <linux/fs.h>
+# include <linux/posix_acl_xattr.h>
+#endif /* CONFIG_FS_POSIX_ACL */
+
+#include <obd_support.h>
+#include <obd_class.h>
+#include <lustre_net.h>
+#include <lustre/lustre_lfsck_user.h>
+#include <lustre_disk.h>
diff --git a/drivers/staging/lustrefsx/lustre/target/out_lib.c b/drivers/staging/lustrefsx/lustre/target/out_lib.c
index 8e60dfff9995..c267ed20bf48 100644
--- a/drivers/staging/lustrefsx/lustre/target/out_lib.c
+++ b/drivers/staging/lustrefsx/lustre/target/out_lib.c
@@ -657,10 +657,6 @@ int out_attr_set_add_exec(const struct lu_env *env, struct dt_object *dt_obj,
 	if (rc != 0)
 		return rc;
 
-	if (attr->la_valid & LA_FLAGS &&
-	    attr->la_flags & LUSTRE_SET_SYNC_FL)
-		th->th_sync |= 1;
-
 	arg = tx_add_exec(ta, out_tx_attr_set_exec, out_tx_attr_set_undo,
 			  file, line);
 	if (IS_ERR(arg))
diff --git a/drivers/staging/lustrefsx/lustre/target/tgt_grant.c b/drivers/staging/lustrefsx/lustre/target/tgt_grant.c
index 78876235dcfd..bedf54ee863d 100644
--- a/drivers/staging/lustrefsx/lustre/target/tgt_grant.c
+++ b/drivers/staging/lustrefsx/lustre/target/tgt_grant.c
@@ -890,9 +890,10 @@ static long tgt_grant_alloc(struct obd_export *exp, u64 curgrant,
 	     tgd->tgd_grant_compat_disable) || left == 0 || exp->exp_failed)
 		RETURN(0);
 
-	if (want > 0x7fffffff) {
-		CERROR("%s: client %s/%p requesting > 2GB grant %llu\n",
-		       obd->obd_name, exp->exp_client_uuid.uuid, exp, want);
+	if (want > OBD_MAX_GRANT) {
+		CERROR("%s: client %s/%p requesting > max (%lu), %llu\n",
+		       obd->obd_name, exp->exp_client_uuid.uuid, exp,
+		       OBD_MAX_GRANT, want);
 		RETURN(0);
 	}
 
@@ -927,6 +928,14 @@ static long tgt_grant_alloc(struct obd_export *exp, u64 curgrant,
 	if ((grant > chunk) && conservative)
 		grant = chunk;
 
+	/*
+	 * Limit grant so that export' grant does not exceed what the
+	 * client would like to have by more than grants for 2 full
+	 * RPCs
+	 */
+	if (ted->ted_grant + grant > want + chunk)
+		grant = want + chunk - ted->ted_grant;
+
 	tgd->tgd_tot_granted += grant;
 	ted->ted_grant += grant;
 
diff --git a/drivers/staging/lustrefsx/lustre/target/tgt_main.c b/drivers/staging/lustrefsx/lustre/target/tgt_main.c
index 4d3923723b2f..12f9fdc1c213 100644
--- a/drivers/staging/lustrefsx/lustre/target/tgt_main.c
+++ b/drivers/staging/lustrefsx/lustre/target/tgt_main.c
@@ -218,7 +218,6 @@ int tgt_init(const struct lu_env *env, struct lu_target *lut,
 	/* prepare transactions callbacks */
 	lut->lut_txn_cb.dtc_txn_start = tgt_txn_start_cb;
 	lut->lut_txn_cb.dtc_txn_stop = tgt_txn_stop_cb;
-	lut->lut_txn_cb.dtc_txn_commit = NULL;
 	lut->lut_txn_cb.dtc_cookie = lut;
 	lut->lut_txn_cb.dtc_tag = LCT_DT_THREAD | LCT_MD_THREAD;
 	INIT_LIST_HEAD(&lut->lut_txn_cb.dtc_linkage);
diff --git a/drivers/staging/lustrefsx/undef.h b/drivers/staging/lustrefsx/undef.h
index c0f5f459ae9c..64189a1ac260 100644
--- a/drivers/staging/lustrefsx/undef.h
+++ b/drivers/staging/lustrefsx/undef.h
@@ -323,6 +323,9 @@
 /* get_user_pages takes gup_flags in arguments */
 #undef HAVE_GET_USER_PAGES_GUP_FLAGS
 
+/* get_user_pages takes gup_flags in arguments with 7 args */
+#undef HAVE_GET_USER_PAGES_GUP_FLAGS_7ARGS
+
 /* struct group_info has member gid */
 #undef HAVE_GROUP_INFO_GID
 
@@ -359,6 +362,9 @@
 /* struct ib_device.attrs is defined */
 #undef HAVE_IB_DEVICE_ATTRS
 
+/* if struct ib_device_ops is defined */
+#undef HAVE_IB_DEVICE_OPS
+
 /* ib_get_dma_mr is defined */
 #undef HAVE_IB_GET_DMA_MR
 
@@ -371,9 +377,15 @@
 /* ib_map_mr_sg has 5 arguments */
 #undef HAVE_IB_MAP_MR_SG_5ARGS
 
+/* ib_post_send and ib_post_recv have const parameters */
+#undef HAVE_IB_POST_SEND_RECV_CONST
+
 /* struct ib_rdma_wr is defined */
 #undef HAVE_IB_RDMA_WR
 
+/* if ib_sg_dma_address wrapper exists */
+#undef HAVE_IB_SG_DMA_ADDRESS
+
 /* inode_operations .getattr member function can gather advance stats */
 #undef HAVE_INODEOPS_ENHANCED_GETATTR
 
@@ -428,6 +440,9 @@
 /* inode_operations has {get,set,remove}xattr members */
 #undef HAVE_IOP_XATTR
 
+/* if iov_iter has member type */
+#undef HAVE_IOV_ITER_HAS_TYPE_MEMBER
+
 /* iov_iter_init handles directional tag */
 #undef HAVE_IOV_ITER_INIT_DIRECTION
 
@@ -437,9 +452,15 @@
 /* iov_iter_truncate exists */
 #undef HAVE_IOV_ITER_TRUNCATE
 
+/* if iov_iter_type exists */
+#undef HAVE_IOV_ITER_TYPE
+
 /* is_sxid is defined */
 #undef HAVE_IS_SXID
 
+/* struct address_space has i_pages */
+#undef HAVE_I_PAGES
+
 /* i_uid_read is present */
 #undef HAVE_I_UID_READ
 
@@ -449,6 +470,9 @@
 /* 'struct sock' accept function requires bool argument */
 #undef HAVE_KERN_SOCK_ACCEPT_FLAG_ARG
 
+/* 'getname' has two args */
+#undef HAVE_KERN_SOCK_GETNAME_2ARGS
+
 /* struct key_match_data exist */
 #undef HAVE_KEY_MATCH_DATA
 
@@ -489,6 +513,9 @@
 /* kernel has kstrtoul */
 #undef HAVE_KSTRTOUL
 
+/* kernel has ksys_close */
+#undef HAVE_KSYS_CLOSE
+
 /* kthread_worker found */
 #undef HAVE_KTHREAD_WORK
 
@@ -546,6 +573,9 @@
 /* Define to 1 if you have the <linux/random.h> header file. */
 #undef HAVE_LINUX_RANDOM_H
 
+/* if linux/selinux.h exists */
+#undef HAVE_LINUX_SELINUX_IS_ENABLED
+
 /* Define to 1 if you have the <linux/types.h> header file. */
 #undef HAVE_LINUX_TYPES_H
 
@@ -555,6 +585,9 @@
 /* Define to 1 if you have the <linux/version.h> header file. */
 #undef HAVE_LINUX_VERSION_H
 
+/* lock_manager_operations has lm_compare_owner */
+#undef HAVE_LM_COMPARE_OWNER
+
 /* lock-manager ops renamed to lm_xxx */
 #undef HAVE_LM_XXX_LOCK_MANAGER_OPS
 
@@ -734,6 +767,9 @@
 /* stacktrace_ops.warning is exist */
 #undef HAVE_STACKTRACE_WARNING
 
+/* stack_trace_print() exists */
+#undef HAVE_STACK_TRACE_PRINT
+
 /* Define to 1 if you have the <stdint.h> header file. */
 #undef HAVE_STDINT_H
 
@@ -794,6 +830,9 @@
 /* tcp_sendpage use socket as first parameter */
 #undef HAVE_TCP_SENDPAGE_USE_SOCKET
 
+/* timer_setup has replaced setup_timer */
+#undef HAVE_TIMER_SETUP
+
 /* 'struct timespec64' is available */
 #undef HAVE_TIMESPEC64
 
@@ -806,12 +845,18 @@
 /* topology_sibling_cpumask is available */
 #undef HAVE_TOPOLOGY_SIBLING_CPUMASK
 
+/* if totalram_pages is a function */
+#undef HAVE_TOTALRAM_PAGES_AS_FUNC
+
 /* kernel export truncate_complete_page */
 #undef HAVE_TRUNCATE_COMPLETE_PAGE
 
 /* kernel has truncate_inode_pages_final */
 #undef HAVE_TRUNCATE_INODE_PAGES_FINAL
 
+/* if MS_RDONLY was moved to uapi/linux/mount.h */
+#undef HAVE_UAPI_LINUX_MOUNT_H
+
 /* uidgid.h is present */
 #undef HAVE_UIDGID_HEADER
 
@@ -833,6 +878,9 @@
 /* virtual_address has been replaced by address field */
 #undef HAVE_VM_FAULT_ADDRESS
 
+/* if vm_fault_t type exists */
+#undef HAVE_VM_FAULT_T
+
 /* 'struct vm_operations' remove struct vm_area_struct argument */
 #undef HAVE_VM_OPS_USE_VM_FAULT_ONLY
 
@@ -845,9 +893,15 @@
 /* needs inode parameter */
 #undef HAVE_XATTR_HANDLER_INODE_PARAM
 
+/* xattr_handler has a name member */
+#undef HAVE_XATTR_HANDLER_NAME
+
 /* handler pointer is parameter */
 #undef HAVE_XATTR_HANDLER_SIMPLIFIED
 
+/* xa_is_value exist */
+#undef HAVE_XA_IS_VALUE
+
 /* Have zap_add_by_dnode() in ZFS */
 #undef HAVE_ZAP_ADD_BY_DNODE
 
-- 
2.32.0

